<html>
<head>
	<meta charset=utf-8 />
	<title>Sounding</title>
	<link href="TTTXT.css" rel="stylesheet">
	<script src="sitesDat.js"></script>
	<script src="../BTAT/btat_obsDat.js"></script>
	<script src="../BTAT/btat_metDat.js"></script>
	<link href="../ATAT/map/leaflet2.css" rel="stylesheet">
	<script src="../ATAT/map/leaflet.js"></script>
	<script src="../ATAT/map/esri-leaflet.js"></script>
	
<style>  
	body{
		margin:0px;
		color:White;
		background-color: #2b3e50;
		font-size: 11px;
	}
	a:link{
		color:#04B4AE
	}
	input.prof{
		font-size: 11px;
	}
	#map {
	  height: 400px;
	  width: 700px;
	  margin: 0;
	  padding: 0;
	}
	.tbldk{
		background-color: #505050;
	}
	.tbllt{
		background-color: #626262;
	}
</style>
  	
<script>
WD = 850
HT = 850
HODOSZ = 550
HoMPx = HODOSZ/2
HoMPy = HODOSZ/2
HOPXEXPAN = 1
SHIFTt = 300
STORMMOTION = [0,0]
atmT=[]
atmDP=[]
atmRH=[]
atmP=[]
atmZ=[]
atmWND = []
atmWB = []
atmEnDAT = []
atmDCAPE = []
atmMSE0 = []
atmMSEbar = []
atmMSEstar = []
mapPts = []
iMU = 0
iHR = 0
iPARCEL = 0
iDPAR = 0
iniPrR = 6

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Data Handeling
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function startUpDoc(){
	let winURL = location.href;
	icaoURL = winURL.split('?')
	if (icaoURL[1]){icao=icaoURL[1]}else{icao='KTUS'}
	document.getElementById("manICAO").value = icao
	loadCSV()
}

//Imports Profile data from CSV file on drives
function loadCSV() {
	icao = document.getElementById("manICAO").value
	var xcsv = new XMLHttpRequest();
	xcsv.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
		//document.getElementById("divtest").innerHTML = "Loading profileDat_"+icao+".csv"
		csvBreakOut(this.responseText)
		document.title = icao + " Sounding"
		//document.getElementById("divtest").innerHTML = "Posted profileDat_"+icao+".csv"
    }
	if (this.readyState == 4 && this.status == 404) {
		document.getElementById("skewtCaption").innerHTML = "No Data Found"
    }
  };
  xcsv.open("GET", "data/profileDat_"+icao+".csv", true);
  xcsv.send();
  urlOB = "https://aviationweather.gov/data/metar/?id=" + icao + "&hours=96&include_taf=yes"
  
} 

//Hyperlinks to ADDS METAR URL based on ICAO
function getObsMetar(){window.open(urlOB)}

//Reads imported data and pushes it to global variable storage 
function csvBreakOut(textCSV) {
	profDat = []
	hrs_txt = textCSV.split("<HRS>")
	for(t=0;t<hrs_txt.length-2;t++){
		profile=[]
		lvls = hrs_txt[t].split("<LVL>")
		for(z=0;z<lvls.length;z++){
			params = lvls[z].split(",")
			lvl=[]
			for(x=0;x<params.length;x++){
				lvl.push(parseFloat(params[x]))
			}
			profile.push(lvl)
		}
		profDat.push(profile)
	}
	validTimes = hrs_txt[hrs_txt.length-1].split(",")
	iHR = 0
	siteICAO = icao 
	centerGraph()
	getProfDat()
	//document.getElementById("divtest").innerHTML = "CSV Break5"
}

//Pan Skew-T Left or Right based on SFC Temps
function centerGraph(){
	SHIFTt = 350
	for(var t=0;t<profDat.length-1;t++){
		//Hot Temps - Pan Right
		if (profDat[t][0][3]>35){
			SHIFTt = 250
			break
		}else if (profDat[t][0][3]>25){
			SHIFTt = 300
		}
		//Cold Temps - Pan Left
		if ( (profDat[t][0][0]>=900 && (profDat[t][0][3]<-20 || profDat[t][0][4]<-35)) || (profDat[t][0][0]<900 && (profDat[t][0][3]<-25 || profDat[t][0][4]<-40)) ){
			SHIFTt = 450
			break
		}
	}
	//document.getElementById("divtest").innerHTML = "SHIFT: " + SHIFTt
}

//Change Forecast Hour
function nextHR(iterHR){
	iHR = iHR + iterHR
	if (iHR<0){iHR=0}
	if (iHR>profDat.length-1){iHR=profDat.length-1}
	getProfDat()
}

// Display the Hodograph Effective Inflow Editor Table
function viewMapLoad(){
	var calTbl = document.getElementById("mcMap").style
	calTbl.visibility = "visible"
	calTbl.top = 20
	calTbl.left = 20
}

// Load new site location from the map
function mapLoad(icao){
	document.getElementById("manICAO").value = icao
	loadCSV()
	document.getElementById("mcMap").style.visibility = "hidden"
}

function clrMap(){
	document.getElementById("mcMap").style.visibility = "hidden"
}

//Pulls Data from js file to put into global variable atmosphere arrays
function getProfDat(){
	atmT=[]
	atmDP=[]
	atmRH=[]
	atmP=[]
	atmZ=[]
	atmM=[]
	atmWND = []
	atmWB = []
	for (var i=0;i<profDat[iHR].length;i++){
			atmP.push(profDat[iHR][i][0])
			atmT.push(profDat[iHR][i][3])
			atmDP.push(profDat[iHR][i][4])
			//atmRH.push(profDat[iHR][i][5])
			rh = Math.round(1000*ES(profDat[iHR][i][4])/ES(profDat[iHR][i][3]))/10
			atmRH.push(rh)
			atmZ.push(profDat[iHR][i][2])
			atmM.push(profDat[iHR][i][1])
			atmWND.push(getWndUV(profDat[iHR][i][6],profDat[iHR][i][7]))
			atmWB.push(getWetBulbTemp(i))
	}
	document.getElementById("mcInterrogate").style.visibility ="hidden"
	newProfDisplay()
}

function labelCaption(){
	document.getElementById("skewtCaption").innerHTML = siteICAO + ": " + validTimes[iHR]
}

//Builds Tool Tip Text in HTML 
function addTTT(mainDispTxt, tipTxt){
	dispTxt = '<div class="tooltip">' + mainDispTxt + '<span class="tooltiptext"><br>' + tipTxt + '<br><br></span></div>'
	return dispTxt
}

// Updates the Parcel Being Displayed on the skew-t 
function dispParcel(lvl){
	if (document.getElementById("mcDCAPE").style.visibility != "visible"){
		iPARCEL = lvl
		plotClear()
		BGHighlights()
		BGShadeEnergy()
		drawBGlines()
		drawProfTemps()
		drawParcelTemps()
		markParcel()
		plotWindBarbs()
		plotHeights()
		plotMargin()
		updraftInfo()
		if (document.getElementById("mcParcel").style.visibility == "visible" || document.getElementById("mcHail").style.visibility == "visible" || document.getElementById("mcTorn").style.visibility == "visible" || document.getElementById("mcDCAPE").style.visibility == "visible"){
			eParDat = calcECAPEparcel(iPARCEL)
			if (atmEnDAT[iPARCEL][4]>300){
				drawECAPEparcel(eParDat)
			}
		}else{
			plotWinds()
		}
	}else{
		plotDCAPE(iDPAR)
	}
}

function basicPlot(){
	plotClear()
	BGHighlights()
	drawBGlines()
	drawProfTemps()
	drawParcelTemps()
	plotWindBarbs()
	plotHeights()
	plotWinds()
}

//New Hour or updated profile parameters 
function newProfDisplay(){
	//document.getElementById("divtest").innerHTML = ""
	labelCaption()
	iPARCEL = 0
	proEnergy()
	dispParcel(0)
	iniHodograph()
	calcPEKEvals()
	if (document.getElementById("mcMxTx").style.visibility == "visible"){iniMxTx()}
	if (document.getElementById("mcFZpro").style.visibility == "visible"){iniFZpro()}
	if (document.getElementById("mcParcel").style.visibility == "visible"){iniTSdisp()}
	if (document.getElementById("mcDCAPE").style.visibility == "visible"){iniDCAPE()}
	if (document.getElementById("mcEditor").style.visibility == "visible"){iniEditor()}
	if (document.getElementById("mcHail").style.visibility == "visible"){iniHail()}
	if (document.getElementById("mcTorn").style.visibility == "visible"){iniTorn()}
	if (document.getElementById("mcFog").style.visibility == "visible"){iniFog()}
	if (document.getElementById("mcTurb").style.visibility == "visible"){iniTurb()}
	compObs()
}

function refreshDisplay(){
	plotClear()
	BGHighlights()
	BGShadeEnergy()
	drawBGlines()
	drawProfTemps()
	drawParcelTemps()
	plotWindBarbs()
	plotHeights()
	plotMargin()
	plotWinds()
	iniHodograph()
	if (document.getElementById("mcMxTx").style.visibility == "visible"){iniMxTx()}
	if (document.getElementById("mcFZpro").style.visibility == "visible"){iniFZpro()}
	if (document.getElementById("mcParcel").style.visibility == "visible"){iniTSdisp()}
	if (document.getElementById("mcDCAPE").style.visibility == "visible"){iniDCAPE()}
	if (document.getElementById("mcEditor").style.visibility == "visible"){iniEditor()}
	if (document.getElementById("mcHail").style.visibility == "visible"){iniHail()}
	if (document.getElementById("mcTorn").style.visibility == "visible"){iniTorn()}
	if (document.getElementById("mcFog").style.visibility == "visible"){iniFog()}
	compObs()
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Skew-T Drawing Functions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Press, Temp to X,Y Coordinate Mapping System
function coordX(t,p){return (10*t) + SHIFTt + (800-coordY(p))}
function coordY(p){return (Math.log(p)*375)-1775}
function y2Press(y){return Math.exp((y/375)+(71/15))}

//################ Sounding extends up to 140mb #####################################
//function coordY(p){return (Math.log(p)*415)-2055}
//function y2Press(y){return Math.exp((y/415)+(411/83))}

//################ Sounding extends up to 130mb #####################################
//function coordY(p){return (Math.log(p)*400)-1945}
//function y2Press(y){return Math.exp((y/400)+(389/80))}

//################ Sounding extends up to 115mb #####################################
//function coordY(p){return (Math.log(p)*375)-1775}
//function y2Press(y){return Math.exp((y/375)+(71/15))}

//################ Sounding extends up to 100mb #####################################
//function coordY(p){return (Math.log(p)*350)-1600}
//function y2Press(y){return Math.exp((y/350)+(32/7))}

//################ Sounding extends up to 75mb #####################################
//function coordY(p){return (Math.log(p)*315)-1355}
//function y2Press(y){return Math.exp((y/315)+(271/63))}

//Draw Skew-T Lines
function drawBGlines(){
	drawMixRatios()
	drawMoistAdiabats()
	drawDryAdiabats()
	drawIsobars()
	drawIsotherms()
}

//Clear Skew-T
function plotClear(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	ctx.clearRect(0,0,WD,HT);
}

function drawIsotherms(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	pStart = 1100
	Temps = [-140,-130,-120,-110,-100,-90,-80,-70,-60,-50,-40,-30,-20,-10,0,10,20,30,40,50,60]
	ctx.strokeStyle = 'gray';
	ctx.fillStyle = 'black';
	ctx.font = "13px Arial";
	ctx.lineWidth = 1;
	ctx.setLineDash([])
	for (var i=0;i<Temps.length;i++){
		x1 = coordX(Temps[i],pStart)
		y1 = coordY(pStart)
		x2 = coordX(Temps[i],50)
		y2 = coordY(50)
		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.fillText(Temps[i], x1, HT-1);
		ctx.stroke();	
	}
	//Freezing Isotherm Highlight
	ctx.lineWidth = 2;
	ctx.fillStyle = 'red';
	ctx.setLineDash([2,2])
	ctx.strokeStyle = '#FF00F7';
	x1 = coordX(0,pStart)
	y1 = coordY(pStart)
	x2 = coordX(0,50)
	y2 = coordY(50)
	ctx.beginPath()
	ctx.moveTo(x1,y1);
	ctx.lineTo(x2,y2);
	ctx.fillText(0, x1, HT-1);
	ctx.stroke();
	
	//-10 Isotherm Highlight - Hail Growth Zone
	ctx.lineWidth = 2;
	ctx.setLineDash([2,2])
	ctx.strokeStyle = '#00FFFF';
	x1 = coordX(-10,pStart)
	y1 = coordY(pStart)
	x2 = coordX(-10,50)
	y2 = coordY(50)
	ctx.beginPath()
	ctx.moveTo(x1,y1);
	ctx.lineTo(x2,y2);
	ctx.stroke();
	//-30 Isotherm Highlight - Hail Growth Zone
	x1 = coordX(-30,pStart)
	y1 = coordY(pStart)
	x2 = coordX(-30,50)
	y2 = coordY(50)
	ctx.beginPath()
	ctx.moveTo(x1,y1);
	ctx.lineTo(x2,y2);
	ctx.stroke();
	
}

function drawIsobars(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	Plvls = [1000,900,800,700,600,500,400,300,250,200,150,100]
	
	ctx.lineWidth = 1;
	ctx.strokeStyle = 'black';
	ctx.fillStyle = 'black';
	ctx.font = "13px Arial";
	ctx.setLineDash([])
	for (var i=0;i<Plvls.length;i++){
		y = coordY(Plvls[i])
		ctx.beginPath();
		ctx.moveTo(0, y);
		ctx.lineTo(WD, y);
		ctx.fillText(Plvls[i], 0, y-2);
		ctx.stroke();
	}
}

function drawDryAdiabats(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	isentrops = [-40,-30,-20,-10,0,10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160]
	ctx.lineWidth = 1;
	ctx.strokeStyle = 'brown';
	ctx.font = "12px Arial";
	ctx.setLineDash([])
	for (var i=0;i<isentrops.length;i++){
		ctx.beginPath();
		x1 = coordX(isentrops[i],1100) 
		y1 = coordY(1100)
		ctx.moveTo(x1,y1);
		for (var z=1100;z>50;z=z-25){
			x2 = coordX(DALRtemp(isentrops[i],z),z) 
			y2 = coordY(z)
			ctx.lineTo(x2, y2)
		}
		ctx.stroke();
	}
}

function drawMoistAdiabats(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	thWs = [-30,-25,-20,-15,-10,-5,0,5,10,15,20,25,30,35,40,45,50,55,60]
	//isentrops = [250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430]
	ctx.lineWidth = 1;
	ctx.strokeStyle = 'green';
	ctx.font = "12px Arial";
	ctx.setLineDash([])
	for (var i=0;i<thWs.length;i++){
		ctx.beginPath();
		x1 = coordX(thWs[i],1100) 
		y1 = coordY(1100)
		ctx.moveTo(x1, y1);
		lastT = thWs[i]
		dp = 25
		for (var z=1100-dp;z>50;z=z-dp){
			nextT = dtMALR(z+dp,lastT,dp)
			x2 = coordX(nextT,z) 
			y2 = coordY(z)
			lastT = nextT
			ctx.lineTo(x2, y2)
		}
		ctx.stroke();
	}
}

function drawMixRatios(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	mxras = [0,0.1,0.25,0.5,1,1.5,2.5,4,6,8,10,13,17,22,28,35,43,52,62,73,85,100,120,150]
	ctx.lineWidth = 1;
	ctx.strokeStyle = 'green';
	ctx.font = "12px Arial";
	ctx.setLineDash([5, 15])
	for (var i=0;i<mxras.length;i++){
		ctx.beginPath();
		x1 = coordX(mxratio(mxras[i],1100),1100) 
		y1 = coordY(1100)
		ctx.moveTo(x1, y1);
		for (var z=1100;z>275;z=z-25){
			x2 = coordX(mxratio(mxras[i],z),z) 
			y2 = coordY(z)
			ctx.lineTo(x2, y2)
		}
		ctx.stroke();
	}
}

function BGHighlights(){
	//#DFECFA - Background Color
	
	//Snow
	if (document.getElementById("mcFZpro").style.visibility == "visible" && document.getElementById("tblFZpro").caption.innerHTML=="Snow"){
		BGareaT(-22,-8,'#C9DCF9')
		BGareaT(-18,-12,'#ECC2F9')
		BGareaT(-5,-0,'#F4F3DB')
	}
	
	//FZDZ
	if (document.getElementById("mcFZpro").style.visibility == "visible" && document.getElementById("tblFZpro").caption.innerHTML=="Freezing Drizzle"){
		BGareaT(-22,-13,'#F7EBD2')
		BGareaT(-13,-12,'#EBF1D9')
		BGareaT(-12,-11,'#E6F0E4')
		BGareaT(-11,-10,'#E2F1F1')
		BGareaT(-10,-9,'#C5F3F3')
		BGareaT(-9,-1,'#9CFFFF')
		BGareaT(-1,0,'#BFF7F7')
		BGareaT(0,10,'#FED8D8')
	}
	
	//FZRA
	if (document.getElementById("mcFZpro").style.visibility == "visible" && document.getElementById("tblFZpro").caption.innerHTML=="Freezing Rain"){
		BGareaT(-10,0,'#D2D8FE')
		BGareaT(0,10,'#FED8D8')
	}
	
	//Hail
	if (document.getElementById("mcHail").style.visibility == "visible"){
		BGareaT(-30,-10,'#ECF2F8')
	}
	
	//Surface - Shade Below Ground
	BGareaBGL()
}

// Colors area on skew-t below ground level 
function BGareaBGL(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	
	rgbCode = "#C3CDD7" // Color for Below surface
	Psfc = atmP[0]
	
	ctx.lineWidth = 1;
	ctx.fillStyle = rgbCode
	ctx.setLineDash([])
	ctx.strokeStyle = rgbCode
	x1 = 0
	y1 = HT
	x2 = 0
	y2 = coordY(Psfc)
	x3 = WD
	y3 = coordY(Psfc)
	x4 = WD
	y4 = HT
	if (y2<HT){
		ctx.beginPath()
		ctx.moveTo(x1,y1);
		ctx.lineTo(x2,y2);
		ctx.lineTo(x3,y3);
		ctx.lineTo(x4,y4);
		ctx.fill()
		ctx.stroke();
	}
}

// Colors area on skew-t between isotherms in BGHighlights()
function BGareaT(lT,hT,rgbCode){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	
	ctx.lineWidth = 1;
	ctx.fillStyle = rgbCode
	ctx.setLineDash([])
	ctx.strokeStyle = rgbCode
	x1 = coordX(lT,1100)
	y1 = coordY(1100)
	x2 = coordX(lT,50)
	y2 = coordY(50)
	x3 = coordX(hT,50)
	y3 = coordY(50)
	x4 = coordX(hT,1100)
	y4 = coordY(1100)
	ctx.beginPath()
	ctx.moveTo(x1,y1);
	ctx.lineTo(x2,y2);
	ctx.lineTo(x3,y3);
	ctx.lineTo(x4,y4);
	ctx.fill()
	ctx.stroke();
}

// Draw Environmental Temperature Profile (T,Td,Twb)
function drawProfTemps(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	
	ctx.lineWidth = 2;
	ctx.strokeStyle = '#CB79E1';
	ctx.setLineDash([5,2])
	for (var i=0;i<atmWB.length-1;i++){
		y1 = coordY(atmP[i])
		y2 = coordY(atmP[i+1])
		x1 = coordX(atmWB[i],atmP[i]) 
		x2 = coordX(atmWB[i+1],atmP[i+1])
		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.stroke();	
	}	
	
	ctx.lineWidth = 3;
	ctx.strokeStyle = 'red';
	ctx.setLineDash([])
	for (var i=0;i<atmP.length-1;i++){
		y1 = coordY(atmP[i])
		y2 = coordY(atmP[i+1])
		x1 = coordX(atmT[i],atmP[i]) 
		x2 = coordX(atmT[i+1],atmP[i+1])
		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.stroke();	
	}
	
	ctx.lineWidth = 3;
	ctx.strokeStyle = 'blue';
	ctx.setLineDash([])
	for (var i=0;i<atmP.length-1;i++){
		y1 = coordY(atmP[i])
		y2 = coordY(atmP[i+1])
		x1 = coordX(atmDP[i],atmP[i]) 
		x2 = coordX(atmDP[i+1],atmP[i+1])
		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.stroke();	
	}
	
}

// Draw the Comparison Environmental Temperature Profile (T,Td)
function plotCompProf(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	timeDiff = 24
	//shadow color #B3BDC8
	compT=[]
	compDP=[]
	compP=[]
	
	vsHR = iHR + timeDiff
	
	if (vsHR >= 0 && vsHR < profDat.length){ 
	
		for (var i=0;i<profDat[vsHR].length-1;i++){
				compT.push(profDat[vsHR][i][3])
				compDP.push(profDat[vsHR][i][4])
				compP.push(profDat[vsHR][i][0])
		}
		
		ctx.lineWidth = 3;
		ctx.strokeStyle = '#F3F9FF';
		ctx.setLineDash([])
		for (var i=0;i<compP.length-1;i++){
			y1 = coordY(compP[i])
			y2 = coordY(compP[i+1])
			x1 = coordX(compT[i],compP[i]) 
			x2 = coordX(compT[i+1],compP[i+1])
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();	
		}
			
		ctx.lineWidth = 1;
		ctx.strokeStyle = '#D02A2A';
		ctx.setLineDash([])
		for (var i=0;i<compP.length-1;i++){
			y1 = coordY(compP[i])
			y2 = coordY(compP[i+1])
			x1 = coordX(compT[i],compP[i]) 
			x2 = coordX(compT[i+1],compP[i+1])
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();	
		}
		
		ctx.lineWidth = 3;
		ctx.strokeStyle = '#F3F9FF';
		ctx.setLineDash([])
		for (var i=0;i<compP.length-1;i++){
			y1 = coordY(compP[i])
			y2 = coordY(compP[i+1])
			x1 = coordX(compDP[i],compP[i]) 
			x2 = coordX(compDP[i+1],compP[i+1])
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();	
		}
		
		ctx.lineWidth = 1;
		ctx.strokeStyle = '#2027C8';
		ctx.setLineDash([])
		for (var i=0;i<compP.length-1;i++){
			y1 = coordY(compP[i])
			y2 = coordY(compP[i+1])
			x1 = coordX(compDP[i],compP[i]) 
			x2 = coordX(compDP[i+1],compP[i+1])
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();	
		}
	}	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Margin Plots
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function calcThetaEpro(){
	thE = []
	for(var i=0;i<atmP.length;i++){
		val = calcThetaE(atmP[i],atmT[i],atmDP[i])
		thE.push(Math.round(val+273.15))
	}
	return thE
}

function calcThetapro(){
	th = []
	for(var i=0;i<atmP.length;i++){
		val = DALRtheta(atmT[i],atmP[i])
		th.push(Math.round(val+273.15))
	}
	return th
}

// Draw Wind Barb Plots on Skew-T of Environmental Wind Profile 
function plotWindBarbs(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	yBot = coordY(atmP[0])
	
	ctx.clearRect(795,0,WD,yBot+30);
	
	// Gray out Below Ground section
	ctx.fillStyle = "#C3CDD7"
	ctx.strokeStyle = "#C3CDD7"
	ctx.beginPath();
	ctx.rect(795,yBot,WD-795,30)
	ctx.fill();
	ctx.stroke();
	
	
	x1 = 824
	barbLen = 22
	//Buffer Division--Higher Number smaller buffer space
	stLen = 2.5 
	stBuf = 8 
	//SkewT X,Y coordinate System x = +v; y = -u
	for (var i=0;i<atmP.length-1;i++){
		if (atmP[i]<700 || i%2 == 0){
			ss = getWndMag(atmWND[i][0],atmWND[i][1])
			p = atmP[i]
			y1 = coordY(p)
			
			ctx.lineWidth = 1
			ctx.fillStyle = '#000000'
			ctx.strokeStyle = '#000000'
			ctx.setLineDash([])

			if (ss < 2.5){
				//CALM Wind Circle
				ctx.beginPath()
				ctx.arc(x1,y1,5,0,2*Math.PI)
				ctx.stroke()
			}else{
				h=0
				for (var f=1;h<barbLen;f++){
					u = atmWND[i][0]*(f/(20+ss))
					v = atmWND[i][1]*(f/(20+ss))
					h = Math.sqrt((u*u)+(v*v))
				}
				
				//Draw Direction barb base line
				x2 = x1 + v
				y2 = y1 - u
				
				ctx.beginPath()
				ctx.moveTo(x1,y1)
				ctx.lineTo(x2,y2)
				ctx.stroke()
				
				flags = Math.floor(ss/50)
				ssLT50 = ss%50
				if (ssLT50 >= 47.5){
					flags++
					ssLT50 = 0
				}
				
				stix = Math.floor(ssLT50/10)
				ssLT10 = ssLT50%10
				if (ssLT10 >= 7.5){
					stix++
					ssLT10 = 0
				}
				
				miniStix = 0
				if (ssLT10 >= 2.5 ){miniStix = 1}
				
				while (flags > 0){
					//Perpen Stix
					x3 = x2 + (u/stLen)
					y3 = y2 + (v/stLen)
					//Angel to Base
					x4 = x2 - (v/7)
					y4 = y2 + (u/7)
					//Draw Flag Triangle
					ctx.beginPath()
					ctx.moveTo(x2,y2)
					ctx.lineTo(x3,y3)
					ctx.lineTo(x4,y4)
					ctx.fill()
					ctx.stroke()
					//Buffer next point up base
					x2 = x4 - (v/(stBuf+6))
					y2 = y4 + (u/(stBuf+6))
					flags--
				}
				
				while (stix > 0){
					//Perpen Stix
					x3 = x2 + (u/stLen)
					y3 = y2 + (v/stLen)
					ctx.beginPath()
					ctx.moveTo(x2,y2)
					ctx.lineTo(x3,y3)
					ctx.stroke()
					//Buffer next point up base
					x2 = x2 - (v/stBuf)
					y2 = y2 + (u/stBuf)
					stix--
				}
				
				if (miniStix){
					//Big Buffer for the 5kt flag
					if (ss < 10){
						x2 = x2 - (v/4)
						y2 = y2 + (u/4)
					}
					//Perpen Stix
					x3 = x2 + (u/(stLen+1.5))
					y3 = y2 + (v/(stLen+1.5))
					ctx.beginPath()
					ctx.moveTo(x2,y2)
					ctx.lineTo(x3,y3)
					ctx.stroke()
				}
			}
		}
	}
}

// Mark Heights AGL
function plotHeights(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	
	x = 28
	//Flight Levels in Feet
	fltLvls = [0,1000,2000,3000,4000,5000,10000,15000,20000,25000,30000,35000,40000,45000,50000,55000,60000]
	
	ctx.lineWidth = 1
	ctx.fillStyle = '#5D2609'
	ctx.strokeStyle = '#5D2609'
	ctx.font = "10px Arial";
	ctx.setLineDash([])
	for (var z=0;z<fltLvls.length-1;z++){
		ctx.beginPath()
		y = coordY(interpLvl("P",conFT2M(fltLvls[z]),"AGL"))
		//if (y<100){break}

		ctx.moveTo(x,y)
		ctx.lineTo(x+12,y)
		//Formats the text for Height Labels 
		if (z==0){
			txtfl = 'SFC'
		}else if (fltLvls[z]<10000){
			txtfl = '0' + (fltLvls[z]/100)
		}else{
			txtfl = fltLvls[z]/100
		}
		ctx.fillText(txtfl, x+15, y+4);
		ctx.stroke()
	}
}

// Display alphanumeric Environmental Wind Profile on Margin
function plotWinds(){
	//Bulid offset to start at 150mb
	for(var x=0;atmP[atmP.length-1-x]<=100;x++)
	//Populate Right Margin Table With Values
	for (var r=0;r<39;r++){
		var rc=document.getElementById("rmarg").rows[r].cells
		var lc=document.getElementById("lmarg").rows[r].cells
		if ((atmP.length-1-r-x)>=0){
			rc[0].style.color = "white"
			rc[1].style.color = "white"
			wind = UVwndDisp(atmWND[atmWND.length-1-r-x])
			rc[0].innerHTML = wind[0]+"<b> | </b>"+wind[1]
			rc[1].innerHTML = ""
		}else{
			rc[0].innerHTML = ""
			rc[1].innerHTML = ""
			//lc[0].innerHTML = ""
			//lc[1].innerHTML = ""
		}
	}
}

// Left Margin Values
function plotMargin(){
	paramType = document.getElementById("lmargParam").value 
	margStyle = 'margin'
	
	switch(paramType) {
		case 'mAGL':	// Elevation meters AGL
			paramList = atmZ
			break;
		case 'ftAGL': 	// Elevation feet AGL
			paramList = atmZ.map(conM2FTint)
			break;
		case 'mMSL': 
			paramList = atmM
			break;
		case 'ftMSL': 
			paramList = atmM.map(conM2FTint)
			break;
		case 'RH': 
			paramList = atmRH
			margStyle = 'relhum'
			break;
		case 'Temp': 
			paramList = atmT
			margStyle = 'tmptmp'
			break;
		case 'Theta': 
			paramList = calcThetapro()
			margStyle = 'tmptheta'
			break;
		case 'ThetaE': 
			paramList = calcThetaEpro()
			margStyle = 'tmpthetae'
			break;
		case 'Press': 
			paramList = atmP
			break;
	}

	//document.getElementById("divtest").innerHTML = paramList
	
	//Bulid offset to start at 125mb
	for(var x=0;atmP[atmP.length-1-x]<=100;x++)
	//Populate Right Margin Table With Values
	for (var r=0;r<39;r++){
		var lc=document.getElementById("lmarg").rows[r].cells
		if ((atmP.length-1-r-x)>=0){
			lc[0].innerHTML = paramList[paramList.length-1-r-x]
			fmtCell(lc[0], paramList[paramList.length-1-r-x], margStyle)
			lc[1].innerHTML = ""//Math.round(atmDP[atmP.length-1-r-x])
		}else{
			lc[0].innerHTML = ""
			lc[1].innerHTML = ""
		}
	}
	document.getElementById("lmarg").rows[0].cells[0].innerHTML = paramType
	document.getElementById("lmarg").rows[0].cells[0].style.color = "#ffffff"
}

function changeLmarg(){plotMargin()}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Thermodynamic Functions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CONSTANTS
var TTRIP = 273.15 		//Triple Point Temperature Ttrip
var ZEROCNK = 273.15	//Triple Point Temp - C2K
var RD = 287.04 		//Gas Constant for Dry Air
var RV = 461.5 			//Gas Constant for Water Vapor
var EPS = 0.622			//Epsilon Rd/Rv
var CP = 1005 			//Heat Capacity of Dry Air @ Const Pressure
var ROCP = 0.2856		//R over Cp
var GAM = RD/CP			//Potental Temperature Exponent
var G = 9.81 			//Gravitational Constant 
var DALRGAM = G/CP 		//Dry Adiabatic Lapse RATE
var XLV = 2501000 		//Latent Heat of Vapor at Triple Point Temperature (Ttrip)
var XLS = 2834000 		//Latent Heat of Sublimation at Ttrip
var CPV = 1870 			//Heat Capacity of water vapor at const Pressure
var CPL = 4190 			//Heat Capacity of Liquid Water
var CPI = 2106 			//Heat Capacity of Ice 
var PREF = 611.65 		//Reference Vapor Pressure at Ttrip
var EREF = 611.2 		//Reference Pressure at Ttrip


// Math function returns Heaviside step function
function getHeaviside(x1,x2){
	if(x1<0){
		val = 0
	}else if (x1>0){
		val = 1
	}else{
		val = x2
	}
	return val
}

//descriminator function between liquid and ice (IE omega defined in the beginning of section 2e Peters et al 2022)
function omega(T,T1,T2){
    return ((T - T1)/(T2-T1))*getHeaviside((T - T1)/(T2-T1),1)*getHeaviside((1 - (T - T1)/(T2-T1)),1) + getHeaviside(-(1 - (T - T1)/(T2-T1)),1)
}

function domega(T,T1,T2){
    return (getHeaviside(T1-T,1) - getHeaviside(T2-T,1))/(T2-T1)
}

// Calculates the Saturation Mixing Ratio using integrate Clausius Clapeyron (eqns 7-12 Peters 2022)
// Formula to get qs (saturation mass fraction) from rs (mixing ratio): qs = (1-qt)*rs 
// total water mass fraction qt
function calcRsat(t,p){
    //t temp (in K)
	t = t + ZEROCNK
	//p pres (in Pa)
	p = p*100
		
	//iceflag (0,1,2) with respect to liquid (0), combo liquid and ice (1), or ice (2)
    //t1 warmest mixed-phase temperature
	t1 = 273
    //t2 coldest mixed-phase temperature
	t2 = 233
	
	omeg = omega(t,t1,t2)
	
	if(t>t1){
		//iceflag=0 qSat WRT: Liquid Only
		term1 = (CPV/CPL)/RV
		term2 = (XLV-TTRIP*(CPV-CPL))/RV
		termExp = (t-TTRIP)*term2/(t*TTRIP)
		esl = Math.exp(termExp)*EREF*(t/TTRIP)**(term1)
		qsat = EPS*esl/(p-esl)
	}else if(t<t2){
		//iceflag=2 qSat WRT: Ice only
		term1 = (CPV/CPI)/RV
        term2 = (XLS-TTRIP*(CPV-CPI))/RV
		esl = Math.exp((t-TTRIP)*term2/(t*TTRIP))*EREF*(t/TTRIP)**(term1)
        esl = Math.min(esl, p*0.5 )
        qsat = EPS*esl/(p-esl)
	}else{
		//iceflag=1 qSat WRT: Mixed Phase
		term1 = (CPV/CPL)/RV
		term2 = (XLV-TTRIP*(CPV-CPL))/RV
		esl = Math.exp((t-TTRIP)*term2/(t*TTRIP))*EREF*(t/TTRIP)**(term1)
		qsatL = EPS*esl/(p-esl)
		term1 = (CPV/CPI)/RV
        term2 = (XLS-TTRIP*(CPV-CPI))/RV
		esl = Math.exp((t-TTRIP)*term2/(t*TTRIP))*EREF*(t/TTRIP)**(term1)
        qsatI = EPS*esl/(p-esl)
		qsat=(1-omeg)*qsatL + (omeg)*qsatI
	}
    return qsat
}

//SHARPPY Function for Mixing Ratio
function mxRatSPy(t,p){
    /*
    Returns the mixing ratio (g/kg) of a parcel

    Parameters
    ----------
    p : number, numpy array
        Pressure of the parcel (hPa)
    t : number, numpy array
        Temperature of the parcel (C?)

    Returns
    -------
    Mixing Ratio (g/kg) of the given parcel

    */
    x = 0.02 * (t - 12.5 + (7500. / p))
    wfw = 1. + (0.0000045 * p) + (0.0014 * x * x)
    fwesw = wfw * vappres(t)
    return 621.97 * (fwesw / (p - fwesw))
}

//SHARPPY Function for Vapor Pressure
function vappres(t){
    /*
    Returns the vapor pressure of dry air at given temperature

    Parameters
    ------
    t : number, numpy array
        Temperature of the parcel (C)

    Returns
    -------
    Vapor Pressure of dry air

    */
    pol = t * (1.1112018e-17 + (t * -3.0994571e-20))
    pol = t * (2.1874425e-13 + (t * (-1.789232e-15 + pol)))
    pol = t * (4.3884180e-09 + (t * (-2.988388e-11 + pol)))
    pol = t * (7.8736169e-05 + (t * (-6.111796e-07 + pol)))
    pol = 0.99999683 + (t * (-9.082695e-03 + pol))
    return 6.1078 / pol**8
}
	
// specific humidity calculation
function calcqv(p,dp){
	w = calcRsat(dp,p)
	qv = (w/(1+w))
	return qv
}

function calcqvOLD(p,dp){
	w = Ws(dp,p)/1000
	qv = (w/(1+w))
	return qv
}

// specific humidity calculation
function calcqv2(p,dp){
	e = ES(dp)*100
	pa = p*100
	qv = (0.622*e)/(pa-(0.378*e))
	return qv
}

// specific humidity calculation
function calcqv(p,dp){
	e = ES(dp)
	pa = p*100
	qv = (0.622*e)/(pa-(0.378*e))
	return qv
}

//Calculate ThetaE of parcel
function calcThetaE(p,t,dp){
	lclVals = findLCL(t,dp,p)
	iT = lclVals[0]
	iP = lclVals[1]
	intervalP = 10
	while (iP - intervalP > 100){
		iT = dtMALR(iP,iT,intervalP)
		iP = iP - intervalP
	}
	the = DALRtheta(iT,iP)
	return the
}

//Get Temperature Along Dry Adiabat (C in/out)
function DALRtemp(theta,p){
	t = (theta + ZEROCNK) * Math.pow(p/1000.,ROCP)
	return t-ZEROCNK
}

// Get Potential Temperature from temp and press
function DALRtheta(t,p){
    return (t+ZEROCNK)*Math.pow(1000./p,ROCP) - ZEROCNK
}

// Get Pressure Level from Dry Adiabat given temp
function DALRpress(th,t){
    return 1000. / (Math.pow(((th+ZEROCNK)/(t+ZEROCNK)),(1./ROCP)))
}
	
//Get Temperature Along Moist Adibat
function dtMALR(p,t,dp){
	kelvin = t + ZEROCNK
    lsbc = (XLV / RV) * ((1.0 / ZEROCNK) - (1.0 / kelvin))
    rw = 6.11 * Math.exp(lsbc) * (EPS / p)
    lrwbt = (XLV * rw) / (RD * kelvin)
    nume = ((RD * kelvin) / (CP * p)) * (1.0 + lrwbt)
    deno = 1.0 + (lrwbt * ((EPS * XLV) / (CP * kelvin)))
    gradi = nume / deno
    dt = dp * gradi
	return t-dt
}

//Get Temperature Along Mixing Ratio
function mxratio(w,p){
	c1 = 0.0498646455
	c2 = 2.4082965
	c3 = 7.07475
	c4 = 38.9114
	c5 = 0.0915
	c6 = 1.2035
	es = (p * w) / (w + 622.0)
	logthing = Math.pow((Math.log(es / 6.11)), (-1.0))
	temp = Math.pow(((17.269 / 237.3) * (logthing - (1.0 / 17.269))), (-1.0))
    return temp
}

// Get the Temperature of the Lifted Condensation Level (LCL)	
function findLCL(t,td,p){
    dd = t - td
    dlt = dd * (1.2185 + 0.001278 * t + dd * (-0.00219 + 1.173e-5 * dd - 0.0000052 * t))
	Tlcl = t - dlt
	Plcl = DALRpress(DALRtheta(t,p),Tlcl)
    return [Tlcl,Plcl]
}

// Find Atmospheric Temperature & Dew Point at Interpolated Pressure 
function getWetBulbTemp(lvl){
	lclVals = findLCL(atmT[lvl],atmDP[lvl],atmP[lvl])
	iT = lclVals[0]
	iP = lclVals[1]
	intervalP = -10
	while (iP - intervalP < atmP[lvl]){
		iT = dtMALR(iP,iT,intervalP)
		iP = iP - intervalP
	}
	Twb = dtMALR(iP,iT,iP-atmP[lvl])
	return Math.min(Twb,atmT[lvl])
}

// Get Saturation Vapor Pressure (HUANG 2018) (celcius)
function ES(t){
    if (t >= 0){
        es = Math.exp(34.494 - (4924.99/(t+237.1)))/Math.pow(t+105,1.57)
    }else{
        es = Math.exp(43.494 - (6545.8/(t+278)))/Math.pow(t+868,2)
	}
    return es/100
}

// Get Saturation Mixing Ratio from temp and press
function Ws(t,p){
    sat_vapor_press = ES(t)
    return 1000*EPS*sat_vapor_press/(p-sat_vapor_press)
}

// Virtual Temperature Conversion
function virtTemp(t,w){    
    w = w/1000.
    return ((t+ZEROCNK)*(w + EPS)/(1 + w)/EPS)-ZEROCNK
}

// Find Atmospheric Temperature & Dew Point at Interpolated Pressure 
function interpolateEnvTemp(p){
	temp = interpLvl("T",p,"P")
	dwpt = interpLvl("DP",p,"P")
	zht = interpLvl("Z",p,"P")
	return [temp,dwpt,zht]
}

//1-LowerLevel 2-UpperLevel, x:feature to be interpolated, z:Level parameter, lvl - level to interpolate at
function getIntpWt(z1,z2,lvl){
	rangeZ = Math.abs(z2-z1)
	dz1 = Math.abs(lvl - z1)
	dz2 = Math.abs(lvl - z2)
	wt1 = dz2/rangeZ
	wt2 = dz1/rangeZ
	return[wt1,wt2]
}

// Find Weather Type at Interpolated Level 
function interpLvl(wxtype,lvl,lvltype){
	if(wxtype == "T"){
		vals = atmT
	}else if(wxtype == "DP"){
		vals = atmDP
	}else if(wxtype == "RH"){
		vals = atmRH
	}else if(wxtype == "WND"){
		vals = atmWND
	}else if(wxtype == "P"){
		vals = atmP
	}else if(wxtype == "AGL"){
		vals = atmZ
	}else if(wxtype == "MSL"){
		vals = atmM
	}else if(wxtype == "WB"){
		vals = atmWB
	}else if(wxtype == "MSEb"){
		vals = atmMSEbar
	}else if(wxtype == "MSEs"){
		vals = atmMSEstar
	}
		
	if(lvltype == "P" || lvltype == "T" || lvltype == "WB"){
		if (lvltype == "P"){lvls = atmP}
		if (lvltype == "T"){lvls = atmT}
		if (lvltype == "WB"){lvls = atmWB}
		for (var i=0;i<lvls.length;i++){
			if (lvls[i]==lvl){
				wx = vals[i]
				wt1 = 1
				break		
			}else if (lvl < lvls[i] && lvl > lvls[i+1]){
				x1 = vals[i]
				x2 = vals[i+1]
				z1 = lvls[i]
				z2 = lvls[i+1]
				wts = getIntpWt(z1,z2,lvl)
				wt1 = wts[0]
				wt2 = wts[1]
				break
			}		
		}
	}else if(lvltype == "AGL"){
		lvls = atmZ
		for (var i=0;i<lvls.length;i++){
			if (lvls[i]==lvl){
				wx = vals[i]
				wt1 = 1
				break		
			}else if (lvl > lvls[i] && lvl < lvls[i+1]){
				x1 = vals[i]
				x2 = vals[i+1]
				z1 = lvls[i]
				z2 = lvls[i+1]
				wts = getIntpWt(z1,z2,lvl)
				wt1 = wts[0]
				wt2 = wts[1]
				break
			}		
		}	
	}
	if(wt1!=1){	
		if(wxtype == "WND"){
			wx = [(x1[0]*wt1)+(x2[0]*wt2),(x1[1]*wt1)+(x2[1]*wt2)]
		}else{
			wx = (x1*wt1)+(x2*wt2)
		}
	}
	return wx
}

// Find approximate press level of intersect when temperature paths cross (LFC/EL etc)
function xSectPts(eXt,pXt,eXb,pXb,Pt,Pb){
	dTop = Math.abs(eXt-pXt)
	dBot = Math.abs(eXb-pXb)
	dTot = dTop + dBot
	wtT =  dBot/dTot
	wtB =  dTop/dTot
	p = (wtT*Pt) + (wtB*Pb)
	return p
}

// Display the ECAPE Values in the default Energy Table 
function calcPEKEvals(){
	//ML Parcel
	lvl = atmEnDAT.length-1
	Etilde = calcETILDE(lvl)
	wmax = Math.sqrt(2*Etilde[0])
		
	var mcEnergy=document.getElementById("tblEnergy").rows[2].cells
	var mcTorn=document.getElementById("tblFCup").rows[2].cells
	
	mcEnergy[3].innerHTML = Math.round(Etilde[0])
	fmtCell(mcEnergy[3],Etilde[0],'cape')
	mcTorn[3].innerHTML = Math.round(Etilde[0])
	fmtCell(mcTorn[3],Etilde[0],'svrcape')
	mcTorn[4].innerHTML = Math.round(wmax*10)/10
	fmtCell(mcTorn[4],Etilde[0],'svrcape')
	
	//document.getElementById("divtest").innerHTML = "peke_ml"
	///////////////////////////////////////////////////////////////
	//MU Parcel  
	lvl = iMU
	Etilde = calcETILDE(lvl)
	eParDat = calcECAPEparcel(iMU)
	ewmax = Math.sqrt(2*eParDat[2])

	eParTP = eParDat[0]
	if (eParTP.length>0){OSTp = eParTP[eParTP.length-1][1]}else{OSTp = atmEnDAT[lvl][9]}
	OSTm = interpLvl("AGL",OSTp,"P")
	fplm = interpLvl("AGL",eParDat[3],"P")
	hailDepthZ = OSTm - fplm
	
	//Exhaust - Storm Relative Flow at ECAPE LNB
	if (eParDat[1]==null){lnb = 6000}else{lnb = interpLvl("AGL",eParDat[1],"P")}
	wndZwt = wndAvgHgtWt(lnb*0.65,lnb)
	stMo = getWndUV(document.getElementById("smF").value,document.getElementById("smM").value)
	wndExhaust = [wndZwt[0]-stMo[0],wndZwt[1]-stMo[1]]
	
	var mcSRFlo=document.getElementById("tblSRFlo").rows[0].cells
	var mcEnergy=document.getElementById("tblEnergy").rows[1].cells
	var mcHailE=document.getElementById("tblGRemb").rows[1].cells
	var mcHailP=document.getElementById("tblGRpot").rows[1].cells
		
	mcEnergy[3].innerHTML = Math.round(Etilde[0])
	fmtCell(mcEnergy[3],Etilde[0],'cape')
	mcHailE[1].innerHTML = addTTT(Math.round(eParDat[2]), "w<sub>max</sub><br>"+Math.round(ewmax*10)/10)
	fmtCell(mcHailE[1],eParDat[2],'embwcape')
	mcHailP[1].innerHTML = addTTT(Math.round(Etilde[0]), "w<sub>max</sub><br>"+Math.round(wmax*10)/10)
	fmtCell(mcHailP[1],Etilde[0],'svrcape')
	mcHailP[2].innerHTML = addTTT(hailDepthZ.toFixed(0),'MPL: ' + Math.round(OSTm) + 'm<br>FzPL: ' + Math.round(fplm)+'m')
	fmtCell(mcHailP[2],hailDepthZ,'grothk')
	dispKnots(mcSRFlo[3],UVwndDisp(wndExhaust)[1],'null') 
	fmtCell(mcSRFlo[3],UVwndDisp(wndExhaust)[1],'srexh')

	
	///////////////////////////////////////////////////////////////
	//SFC Parcel 
	lvl = 0
	Etilde = calcETILDE(lvl)
	wmax = Math.sqrt(2*Etilde[0])
	eParDat = calcECAPEparcel(0)
	ewmax = Math.sqrt(2*eParDat[2])
	
	eParTP = eParDat[0]
	if (eParTP.length>0){OSTp = eParTP[eParTP.length-1][1]}else{OSTp = atmEnDAT[0][9]}
	OSTm = interpLvl("AGL",OSTp,"P")
	fplm = interpLvl("AGL",eParDat[3],"P")
	hailDepthZ = OSTm - fplm
		
	var mcEnergy=document.getElementById("tblEnergy").rows[3].cells
	var mcTorn=document.getElementById("tblFCup").rows[1].cells
	var mcHailE=document.getElementById("tblGRemb").rows[2].cells
	var mcHailP=document.getElementById("tblGRpot").rows[2].cells
	
	mcEnergy[3].innerHTML = Math.round(Etilde[0])
	fmtCell(mcEnergy[3],Etilde[0],'cape')
	mcTorn[3].innerHTML = Math.round(Etilde[0])
	fmtCell(mcTorn[3],Etilde[0],'svrcape')
	mcTorn[4].innerHTML = Math.round(wmax*10)/10
	fmtCell(mcTorn[4],Etilde[0],'svrcape')
	mcHailE[1].innerHTML = addTTT(Math.round(eParDat[2]), "w<sub>max</sub><br>"+Math.round(ewmax*10)/10)
	fmtCell(mcHailE[1],eParDat[2],'embwcape')
	mcHailP[1].innerHTML = addTTT(Math.round(Etilde[0]), "w<sub>max</sub><br>"+Math.round(wmax*10)/10)
	fmtCell(mcHailP[1],Etilde[0],'svrcape')
	mcHailP[2].innerHTML = addTTT(hailDepthZ.toFixed(0),'MPL: ' + Math.round(OSTm) + 'm<br>FzPL: ' + Math.round(fplm)+'m')
	fmtCell(mcHailP[2],hailDepthZ,'grothk')
	
	///////////////////////////////////////////////////////////////
	// Current Drawn Parcel
	Etilde = calcETILDE(iPARCEL)
	wmax = Math.sqrt(2*Etilde[0])
	varepsilon = Etilde[1]*10000
	Ru = Etilde[2]
	eParDat = calcECAPEparcel(iPARCEL)
	eParTP = eParDat[0]
	var x=document.getElementById("tblparStat").rows[3].cells
	
	if (Etilde[0]==0){
		//for(n=1;n<7,n++)
		x[1].innerHTML = 0 
		fmtCell(x[1],0,'cape')
		x[2].innerHTML = 0 
		x[3].innerHTML = 0 
		x[4].innerHTML = 0 
		x[5].innerHTML = '' 
		x[6].innerHTML = '' 
	}else{
		x[1].innerHTML = Math.round(Etilde[0])
		fmtCell(x[1],Etilde[0],'cape')
		x[2].innerHTML = Math.round(wmax*10)/10
		x[3].innerHTML = varepsilon.toFixed(2)
		x[4].innerHTML = Math.round(Ru)
		LNBp = eParDat[1]
		LNBm = interpLvl("AGL",LNBp,"P")
		LNBft = conM2FT(LNBm)
		x[5].innerHTML = addTTT(Math.round(LNBp),Math.round(LNBm) + ' m<br>' + Math.round(LNBft)+ ' ft')
		if (eParTP.length>0){OSTp = eParTP[eParTP.length-1][1]}else{OSTp = atmEnDAT[iPARCEL][9]}
		OSTm = interpLvl("AGL",OSTp,"P")
		OSTft = conM2FT(OSTm)
		x[6].innerHTML = addTTT(Math.round(OSTp),Math.round(OSTm) + ' m<br>' + Math.round(OSTft)+ ' ft') 
	}
		
	///////////////////////////////////////////////////////////////
	// Other Composite Parameters
	scp = calcSCP()
	stp = calcSTP()
	var mcTorn=document.getElementById("tblFCsc").rows[1].cells
	var mcEnergy=document.getElementById("tblEnergy").rows[5].cells
	
	mcTorn[0].innerHTML = scp.toFixed(1)
	fmtCell(mcTorn[0],Math.abs(scp),'scp')
	mcTorn[1].innerHTML = stp.toFixed(2)
	fmtCell(mcTorn[1],stp,'stp')
	mcEnergy[0].innerHTML = scp.toFixed(2)
	fmtCell(mcEnergy[0],scp,'scp')
	///////////////////////////////////////////////////////////////
	// Hail Graphs
	if (document.getElementById("mcHailGraph").style.visibility == "visible"){
		bgHailGraph()
	}
	
}

// Display standard CAPE values in Energy Specs Table
function dispEspec(pclType){
	convVals = getTcCCL()
	CtTxt = 'Tc: '+ Math.round(convVals[0]*10)/10 + '&deg;C | ' + Math.round(conC2F(convVals[0])*10)/10+ '&deg;F<br>'
	CtTxt += 'T : '+ Math.round(atmT[0]*10)/10 + '&deg;C | ' + Math.round(conC2F(atmT[0])*10)/10+ '&deg;F'
	document.getElementById("tblEnergy").rows[5].cells[4].innerHTML = addTTT(Math.round(convVals[0]*10)/10, CtTxt)
	fmtCell(document.getElementById("tblEnergy").rows[5].cells[4],atmT[0]-convVals[0],'convtemp')
	//parLvls = ['MU','ML','SFC']
	if (pclType == 'MU'){
		r=1
		lvl = iMU
		/*
		if (atmEnDAT[lvl][4]>0){
			document.getElementById("tblEnergy").rows[5].cells[4].innerHTML = addTTT(Math.round(atmEnDAT[lvl][12]*100/atmEnDAT[lvl][4])/100, 'BDPE<br>'+Math.round(atmEnDAT[lvl][12]))
		}else{
			document.getElementById("tblEnergy").rows[5].cells[4].innerHTML = addTTT('0', 'BDPE<br>'+Math.round(atmEnDAT[lvl][12]))
		}
		*/
	}else if (pclType == 'ML') {
		r=2
		lvl = atmEnDAT.length-1
	}else if (pclType == 'SFC') {
		r=3
		lvl = 0
	}
	dispTxt = "<button style='font-size: 10px' onClick='dispParcel("+lvl+")'>"+pclType+"</button>"
	//dispTxt = "<span onClick='dispParcel("+lvl+")'>"+pclType+"</span>"
	var x=document.getElementById("tblEnergy").rows[r].cells
	parLvlInfo = atmEnDAT[lvl]
	 
	eNCAPE = calcNCAPE(lvl)
	//Parcel
	x[0].innerHTML = addTTT(dispTxt,Math.round(parLvlInfo[3])+"mb")
	//CIN
	x[1].innerHTML = parLvlInfo[5]
	fmtCell(x[1],parLvlInfo[5],'cin')
	//CAPE
	x[2].innerHTML = addTTT(parLvlInfo[4],"NCAPE<br>" + eNCAPE)
	fmtCell(x[2],parLvlInfo[4],'cape')
	//NCAPE
	x[3].innerHTML = eNCAPE
	fmtCell(x[3],eNCAPE,'ncape')
	//LCL
	pLVL = parLvlInfo[2]
	zLVLm = interpLvl("AGL",pLVL,"P")
	zLVLft = conM2FT(zLVLm)
	x[4].innerHTML = addTTT(pLVL,Math.round(zLVLm) + ' m<br>' + Math.round(zLVLft)+ ' ft')
	
	if (isNaN(parLvlInfo[1]) || parLvlInfo[1]==null){
		x[5].innerHTML = ''
		//x[6].innerHTML = ''
		//x[7].innerHTML = ''
	}else{
		//LFC
		pLFC = parLvlInfo[1]
		zLFCm = interpLvl("AGL",pLFC,"P")
		zLFCft = conM2FT(zLFCm)
		//x[5].innerHTML = addTTT(pLVL,Math.round(zLVLm) + ' m<br>' + Math.round(zLVLft)+ ' ft')
		//EL
		pEL = parLvlInfo[0]
		zELm = interpLvl("AGL",pEL,"P")
		zELft = conM2FT(zELm)
		x[5].innerHTML = addTTT(pLVL,Math.round(zELm) + ' m<br>' + Math.round(zELft)+ ' ft')
		//MPL
		pMPL = parLvlInfo[9]
		zMPLm = interpLvl("AGL",pMPL,"P")
		zMPLft = conM2FT(zMPLm)
		//x[7].innerHTML = addTTT(pLVL,Math.round(zLVLm) + ' m<br>' + Math.round(zLVLft)+ ' ft')
	}
}

//calculates for the Nondimensional ECAPE via E_tilde - Requires Energy and Storm Relative Inputs - Returns [ECAPE,Fractional Entrainment Rate,Updraft Radius]
function calcETILDE(lvl){
	cape = atmEnDAT[lvl][4]
	if (cape>0){
		h = interpLvl("AGL",atmEnDAT[lvl][0],"P") // EL height
		bdpe = atmEnDAT[lvl][12]
		lmix = 120
		l=lmix/h
		sigma = 1.1
		alpha = 0.8
		pr = 1/3 		// Prandtl Number 
		ksq = 0.18 		// Von Karman Constant
		pitchfork = ksq*(alpha**2)*(Math.PI**2)*lmix/(4*pr*(sigma**2)*h)
		//Pulls Inflow From GUI
		inflowTXT = document.getElementById("tblSRFlo").rows[0].cells[1].innerHTML.split('<span class="tooltiptext"><br>')
		vsr = Math.max(conKT2MS(parseInt(inflowTXT[0].slice(21))),1)
		VSRtilde = vsr/Math.sqrt(2*cape)
		Ntilde = bdpe/cape
		
		//Peters 2023 Eqn (42) 
		Etilde = VSRtilde**2 + ( -1 - pitchfork - (pitchfork/(VSRtilde**2 ))*Ntilde + Math.sqrt((1 + pitchfork + (pitchfork/(VSRtilde**2 ))*Ntilde)**2 + (4*(pitchfork/(VSRtilde**2 ))*(1 - pitchfork*Ntilde) ) ) )/( 2*pitchfork/(VSRtilde**2) )
		bigEtil = Etilde - VSRtilde**2
		varepsilon = 2*((1 - bigEtil)/(bigEtil + Ntilde))/(h)
		radius = Math.sqrt(2*ksq*l/(pr*varepsilon))
		ecape = Etilde*cape
	}else{
		ecape=0
		varepsilon=0
		radius=0
	}
	return [ecape,varepsilon,radius]
}

// Calculate Moist Static Energy of Atmosphere
function calcMSE(){
	atmMSE0 = [] 
	atmMSEstar = []
	for (var i=0;i<atmP.length;i++){
		//Moist Static Energy of Environment
		rSat = Ws(atmDP[i],atmP[i])/1000
		q0 = (1 - rSat)*rSat
		h0 = CP*(atmT[i]+ZEROCNK) + XLV*q0 + G*atmZ[i]
		atmMSE0.push(h0)
		//Saturated Moist Static Energy of Environment
		rSat = Ws(atmT[i],atmP[i])/1000
		q0star = (1 - rSat)*rSat
		h0star = CP*(atmT[i]+ZEROCNK) + XLV*q0star + G*atmZ[i]
		atmMSEstar.push(h0star)
	}
	//Calculate the Average MSE0 below level at each level
	atmMSEbar = [atmMSE0[0]]
	totMSE0 = atmMSE0[0]
	for (var i=1;i<atmP.length;i++){
		totMSE0 = totMSE0 + atmMSE0[i]
		atmMSEbar.push(totMSE0/(i+1))
	}
}

// Thermodynamic Energy Overview of the sounding builds profile ascending energy global variable (atmEnDAT)
function proEnergy(){
	//Calculate each level's parcel energy up to 400 hPa both ascending & descending
	atmEnDAT = []
	atmDCAPE = []
	//Calculate each level's Moist Static Energy MSE for ECAPE calculation
	calcMSE()
	
	for (var z=0;atmP[z]>325;z++){
		atmEnDAT.push(parcelArea(parcel(z)))
		DparsDat = Dparcel(z)
		atmDCAPE.push(DparcelArea(DparsDat[0],DparsDat[1],DparsDat[2],z))
	}
	
	//SB CAPE 
	dispEspec('SFC')
	
	//ML CAPE
	atmEnDAT.push(parcelArea(MLparcel()))
	mlDat = parcelArea(MLparcel())
	dispEspec('ML')
	
	//MUCAPE 
	mxCape = 0 
	mxZ = 0
	for (var z=0;z<atmEnDAT.length;z++){
		if (atmEnDAT[z][4]>mxCape){
			mxCape=atmEnDAT[z][4]
			iMU = z
		}
	}
	dispEspec('MU')
	
	//Mid Level Lapse rate
	hgtz05 = interpLvl("AGL",-5,"T")
	hgtz30 = interpLvl("AGL",-30,"T")
	p05 = interpLvl("P",-5,"T")
	p30 = interpLvl("P",-30,"T")
	dz = hgtz30 - hgtz05
	gammaMid = Math.round(25*10000/dz)/10
	document.getElementById("tblEnergy").rows[5].cells[3].innerHTML = gammaMid.toFixed(1)
	fmtCell(document.getElementById("tblEnergy").rows[5].cells[3],gammaMid,'lrhgz')
	//ThetaE difference aka ThetaE Index
	TeD = calcTeD()
	wmsi = (TeD*atmEnDAT[iMU][4])/1000
	document.getElementById("tblEnergy").rows[5].cells[5].innerHTML = addTTT(Math.round(TeD*10)/10, "WMSI<br>"+Math.round(wmsi*10)/10)
}

// Calculates Parcel Energy/Sig levels and Draws Upward Parcel Path with CAPE & CIN shadings
function parcelArea(parsDat){
	parT = parsDat[0]
	parP = parsDat[1]
	parDTv = parsDat[2]
	envTv = parsDat[3]
	lvl = parsDat[4]
	parLvlInfo = [null,null,null,parP[0],null,null,null,null,null,null,[],[]] //0-EL,1-LFC,2-LCL,3-Origin,4-CAPE,5-CIN,6-iLCL,7-wCAPE,8-FPL,9-MPL,10-parsDat,11-shadecoords
	
	// Make "lvl" the first standard increment (25mb) above the origin
	//for (var i=0;atmP[i]>=parP[0];i++){lvl=i}
	
	// Build Environmental Arrary by removing levels below parcel giving a common index for each pressure level
	envT = atmT.slice(lvl)
	envP = atmP.slice(lvl)
	envZ = atmZ.slice(lvl)
	envMSEbar = atmMSEbar.slice(lvl)
	envMSEstar = atmMSEstar.slice(lvl)
	// Insert origin level back in at the start of array
	/*
	envP.unshift(parP[0])
	envZ.unshift(interpLvl("AGL",parP[0],"P"))
	envT.unshift(interpLvl("T",parP[0],"P"))
	*/
	iLCL = 0
	
	// Parcel has extra level at LCL.  Interpolated temp inserted into Environment Array.  Array Shapes are matched
	for (var i=0;i<envP.length;i++){
		if(envP[i] < parP[i]){
			lclEnvTemps = interpolateEnvTemp(parP[i])
			envP.splice(i,0,parP[i])
			envT.splice(i,0,lclEnvTemps[0])
			envZ.splice(i,0,lclEnvTemps[2])
			envMSEbar.splice(i,0,interpLvl("MSEb",parP[i],"P"))
			envMSEstar.splice(i,0,interpLvl("MSEs",parP[i],"P"))
			iLCL = i
		}
	}
	
	parsDat.push(envT)
	parLvlInfo[10] = parsDat
	
	parLvlInfo[6] = iLCL
	parLvlInfo[2] = Math.round(envP[iLCL])
	if (parDTv[iLCL] > 0){parLvlInfo[1] = Math.round(envP[iLCL])}
		
	//Find Parcel's Freezing Level
	for (var i=0;i<parT.length-1;i++){
		if(parT[i]<=0){
			parLvlInfo[8] = envP[i]
			break;
		}else if(parT[i] > 0 && parT[i+1] < 0){
			wt = getIntpWt(parT[i],parT[i+1],0)
			fpl = (envP[i]*wt[0]) + (envP[i+1]*wt[1])
			parLvlInfo[8] = fpl
		}
	}
	
	storeEnAreas = []
	// Arrays to capture Parcel Coords for CIN/CAPE shade areas
	enX = []
	enY = []
	// Arrays to capture Environment Coords for CIN/CAPE shade areas
	Xen = []
	Yen = []

	enCIN = 0
	enCAPE = 0
	enWarmCAPE = 0 
	enNEA = 0
	enBDPE = 0
	
	//signE	determines +/- energy and whether its added as CAPE or CIN
	signE = parDTv[iLCL]/Math.abs(parDTv[iLCL])
	//Set the LFC Level of Free Convection if energy is positive at LCL
	if (signE>0){parLvlInfo[1] = Math.round(envP[iLCL])}
		
	for (var i=iLCL;i<envP.length;i++){
		//Calculate Components for energy of profile segment for CIN & CAPE
		dT_avg = (parDTv[i] + parDTv[i+1])/2
		T_avg = (envTv[i] + envTv[i+1])/2
		dZ = envZ[i+1] - envZ[i]
		enLvl = (9.8 * dT_avg * dZ / (T_avg + ZEROCNK))
		
		//Calculate Negative CAPE or Buoyancy Dilution Potential for Entrainment CAPE
		if (signE>0 && parLvlInfo[0]==null){
			dMSEavg = ((envMSEbar[i]-envMSEstar[i]) + (envMSEbar[i+1]-envMSEstar[i+1]))/2
			intARGavg = ((G/(CP*(envT[i]+ZEROCNK)))+(G/(CP*(envT[i+1]+ZEROCNK))))/2
			enBDPE = enBDPE - (intARGavg * dMSEavg * dZ)
		}
		
		// Partition CAPE below the Parcel's Freezing Level *** actually HGZ
		if(parT[i] > -10 && signE > 0){
			if (parT[i+1] >= -8){
				// Level segment completely below freezing level
				enWarmCAPE = enWarmCAPE + enLvl
			}else{
				// Level Segment is split by the freezing parcel level
				wt = getIntpWt(parT[i],parT[i+1],-8)
				enWarmCAPE = enWarmCAPE + (wt[0]*enLvl)
			}
		}

		if (signE > 0){
			//Positive Energy is added to CAPE, with a minimum value of 1 set anytime parcel is warmer than environment
			enCAPE = Math.max(1,enCAPE + enLvl)
						
		}else if (signE < 0){
			//CIN - Compute and Integrate Negative Energy Area (limiting CIN to first 10,000FT above origin)
			if (envZ[i]-envZ[iLCL]<3000){
				//If CIN area occurs over a shallow "LFC" look for better area (+ parcel Difference PEA) if it does reset LFC to null
				if (parLvlInfo[1] != null && enCIN < -5){
					for(x=i;x<envP.length-1;x++){
						if (parDTv[x]>0.5){
							parLvlInfo[1] = null
							break
						}
					}
				}
			}
			if ((parLvlInfo[1] == null || enCAPE < 5) && envZ[i]-envZ[iLCL]<3000){
				//CIN is Negative energy below LFC or no significant CAPE and level is within 10,000ft of parcel origin
				enCIN = enCIN + enLvl
			}else{
				//NEA - Any negative energy above LFC add to compute MPL Max Parcel Level
				if (enCAPE > 0){					
					enNEA = enNEA + enLvl
					//Passed the MPL 
					document.getElementById("divtest").innerHTML = ''
					if ((enCAPE + enNEA)<=0 && parLvlInfo[1] != null ){
						/*
						enY.push(coordY(parP[i]))
						enX.push(coordX(parT[i],parP[i]))
						Yen.push(coordY(envP[i]))
						Xen.push(coordX(envT[i],envP[i]))
						*/
						enDiff = enCAPE + enNEA
						wt1 = enDiff/enLvl
						wt2 = 1 - wt1
						mpl = (envP[i]*wt1) + (envP[i+1]*wt2)
						//document.getElementById("divtest").innerHTML = "enDiff: " + enDiff + " = " + enCAPE + " + " + enNEA + "<BR>"						
						//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "wt1: " + wt1 + " | P1: " + envP[i] + " | P2: " + envP[i+1] + "<BR>"
						parLvlInfo[9] = Math.round(mpl)
						mplT = interpLvl('T',mpl,'P')
						mplWt = getIntpWt(envP[i],envP[i+1],mpl)
						mplparT = (parT[i]*wt1) + (parT[i+1]*wt2)
						enY.push(coordY(mpl))
						enX.push(coordX(mplparT,mpl))
						Yen.push(coordY(mpl))
						Xen.push(coordX(mplT,mpl))
						enY = enY.concat(Yen.reverse())
						enX = enX.concat(Xen.reverse())
						storeEnAreas.push([enX,enY,signE])
						break
					}
				}
			}
		}
		//Just eliminate Virtual Temp Difference (math gets weird at low temps/low press)
		if(parT[i]<=-40){parcelT = parT[i]}else{parcelT = envT[i]+parDTv[i]}
		//Store XY Coords
		enY.push(coordY(parP[i]))
		enX.push(coordX(parcelT,parP[i]))
		Yen.push(coordY(envP[i]))
		Xen.push(coordX(envT[i],envP[i]))
						
		//Determine if next level is top level to close energy area or get area coordinates
		if (i < envP.length-1){
			//determines if energy sign switches at next iteration
			nextSignE = parDTv[i+1]/Math.abs(parDTv[i+1])
			if (signE != nextSignE){
				//Find Cross Over Point
				xOverP = xSectPts(coordX(envT[i+1],envP[i+1]),coordX(envT[i+1]+parDTv[i+1],parP[i+1]),Xen[Xen.length-1],enX[enX.length-1],parP[i+1],parP[i])
				xOverT = interpLvl('T',xOverP,'P')
				interpolateEnvTemp(xOverP)
				enY.push(coordY(xOverP))
				enX.push(coordX(xOverT,xOverP))
				//Set the LFC Level of Free Convection if energy switches to positive
				if (parLvlInfo[1] == null){parLvlInfo[1] = Math.round(xOverP)}
				//Finalize Coordinates and Color Area 
				enY = enY.concat(Yen.reverse())
				enX = enX.concat(Xen.reverse())
				if (enY.length > 2 && (enCAPE > 0 || enCIN > -1000)){storeEnAreas.push([enX,enY,signE])}
				//Reset coordinate arrays
				enX = []
				enY = []
				Xen = []
				Yen = []
				enY.push(coordY(xOverP))
				enX.push(coordX(xOverT,xOverP))
				if(signE>0){parLvlInfo[0] = Math.round(xOverP)}
				signE = nextSignE
			}
		}else{
			//Reached the top of the profile so close out area
			enY = enY.concat(Yen.reverse())
			enX = enX.concat(Xen.reverse())
			if (enY.length > 2 && (enCAPE > 0 || enCIN > -1000)){storeEnAreas.push([enX,enY,signE])}
			//If energy is still positive at top of sounding set EL - Equilibrium Level
			if(signE>0){parLvlInfo[0] = envP[i]}
			//If above Equilibrium Level and haven't reached Max Parcel level set it to top
			if(parLvlInfo[0] != null){parLvlInfo[9] = envP[i]}
			break
		}
	}
	
	if(enCAPE<1){enCAPE=0}
	parLvlInfo[4] = Math.round(enCAPE)
	parLvlInfo[5] = Math.round(enCIN)
	parLvlInfo[7] = Math.round(enWarmCAPE)
	parLvlInfo[11] = storeEnAreas
	if (enBDPE < 0){enBDPE = 0}
	parLvlInfo[12] = enBDPE
	return parLvlInfo
}

//Shade Parcel Energy Areas in Skew-T Background
function BGShadeEnergy(){
	// Draw CIN Area from coordinates - Only show when there is CAPE or marginal CIN
	if (atmEnDAT[iPARCEL][11].length > 0 && atmEnDAT[iPARCEL][4] > 25){
		drawEnAreas(atmEnDAT[iPARCEL][11])
	}else if (atmEnDAT[iPARCEL][11].length > 1 && atmEnDAT[iPARCEL][5] >-75){
		drawEnAreas(atmEnDAT[iPARCEL][11])
	}
}	

//Draw Parcel Temperature Path Based on Potental Energy
function drawParcelTemps(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	parsDat = atmEnDAT[iPARCEL][10]
	iLCL = atmEnDAT[iPARCEL][6]
	parT = parsDat[0]
	parP = parsDat[1]
	parDTv = parsDat[2]
	envTv = parsDat[3]
	lvl = parsDat[4]
	envT = parsDat[5]
	
	//Draw Parcel Temperature
	ctx.lineWidth = 2;
	ctx.strokeStyle = '#FF8000';
	ctx.setLineDash([])
	ctx.beginPath();
	y1 = coordY(parP[0])
	x1 = coordX(parT[0],parP[0]) 
	ctx.moveTo(x1, y1);
	for (var i=1;i<parP.length;i++){
		y2 = coordY(parP[i])
		x2 = coordX(parT[i],parP[i])
		ctx.lineTo(x2,y2)
	}
	ctx.stroke()
		
	//Draw Virtual Temp Difference from Profile Temp
	ctx.lineWidth = 2
	ctx.strokeStyle = '#FF8000'
	ctx.setLineDash([2,2])
	ctx.beginPath();
	y1 = coordY(parP[0])
	x1 = coordX(parT[0]+parDTv[0],parP[0]) 
	ctx.moveTo(x1, y1);
	for (var i=1;parP[i]>200;i++){
		y2 = coordY(parP[i])
		x2 = coordX(envT[i]+parDTv[i],parP[i])
		ctx.lineTo(x2,y2)
	}
	ctx.stroke()
		
	//Draw Dew Point Mixing Ratio to the LCL 
	dpt0 = interpLvl("DP",parP[0],"P")
	//Exception for ML parcel (find
	if (iPARCEL == atmEnDAT.length-1){
		dpt0 = mxratio(Ws(parT[iLCL],parP[iLCL]),parP[0])
	}
	ctx.lineWidth = 1
	ctx.strokeStyle = '#537827'
	ctx.setLineDash([])
	ctx.beginPath();
	y1 = coordY(parP[0])
	x1 = coordX(dpt0,parP[0]) 
	ctx.moveTo(x1, y1);
	y2 = coordY(parP[iLCL])
	x2 = coordX(parT[iLCL],parP[iLCL])
	ctx.lineTo(x2,y2)
	ctx.stroke()

}

//Calculate the Entrainment Parcel Temperature Path Based on Potental Energy With Drawing
function calcECAPEparcel(lvl){
	parsDat = atmEnDAT[lvl][10]
	iLCL = atmEnDAT[lvl][6]
	cape = atmEnDAT[lvl][4]
	pLFC = atmEnDAT[lvl][1]
	fpl = atmEnDAT[lvl][8]
	Etilde = calcETILDE(lvl)
	ecape = Etilde[0]
	
	parT = parsDat[0]
	parP = parsDat[1]
	parDTv = parsDat[2]
	envTv = parsDat[3]
	envT = parsDat[5]

	//Entrainment Parcel Follows Undiluted Parcel thru the LFC ( within 25mb above actually )
	TPdilutePar = []
	wPEA = 0
	xOverP = null
	for (var z=iLCL;parP[z]>=pLFC;z++){}
	if (atmP[lvl]>=800 || lvl == atmEnDAT.length-1){
		if (ecape>=cape){
			//When ECAPE is greater than CAPE - display will follow the undiluted parcel path
			for (var i=z;i<parP.length-1;i++){
				TPdilutePar.push([parT[i],parP[i]])
				xOverP = atmEnDAT[lvl][0]				
			}
		}else if (ecape>50){	
			//When ECAPE is large enough to draw
			eEn = 0
			fracE = 5
			count = 0
			eEnMax = 0
			wPEA = 0
			fpl = parP[z]
			
			while (eEnMax < ecape ){
				if (fracE>50){break} //Prevent the infinite loop
				//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + eEnMax + " < " + ecape + "<br>"
				EparT = parT.slice(0,z+1)
				fracE = fracE + 1
				eEn = 0
				count = 0
				TPdilutePar = [[parT[z],parP[z]]]
				wPEA = 0
				
				for (var i=z;i<parP.length-2;i++){
					dZ = interpLvl("AGL",envP[i+1],"P") - interpLvl("AGL",envP[i],"P")
					//Undiluted CAPE/Parcel Lapse Rate
					gammaUDpar = (parT[i]-parT[i+1])/(dZ/1000)
					//Calculate Entrainment Parcel Lapse Rate as a deviation from Undiluted Parcel upto the Dry Adiabatic Lapse Rate (DALR)
					nextTdalr = DALRtemp(DALRtheta(EparT[i],parP[i]),parP[i+1]) 
					dalr = (EparT[i]-nextTdalr)/(dZ/1000)
					if((fracE-count)>=0.5){
						eParLR = gammaUDpar + ((dalr - gammaUDpar)/(fracE-count))
					}else{
						eParLR = dalr
					}
					//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "UD: " + gammaUDpar + " | DA: " + dalr + " | EPar: " + eParLR + " | fe/ct: " + fracE + "<br>"
					//Calculate next level temperature based on entrainment lapse rate
					dtInt = eParLR*dZ/1000
					nextT = EparT[i]-dtInt
					//Entrainment lapse rate not to excede dry adiabatic lapse rate
					nextT = Math.max(nextT,nextTdalr)
					EparT.push(nextT)
					TPdilutePar.push([nextT,parP[i+1]])
					//Calculate level ECAPE - Positive Energy Area based on Diluted Parcel 
					dTv1 = virtTemp(EparT[i],Ws(EparT[i],parP[i])) - envTv[i] 
					dTv2 = virtTemp(EparT[i+1],Ws(EparT[i+1],parP[i+1])) - envTv[i+1]
					dT_avg = (dTv1 + dTv2)/2
					T_avg = (envTv[i] + envTv[i+1])/2
					enLvl = (9.8 * dT_avg * dZ / (T_avg + ZEROCNK))
					eEn = eEn + enLvl
					
					//Calculate warm ECAPE for hail embryo
					if (enLvl>0 && EparT[i+1]>=-8){wPEA=wPEA+enLvl}
					
					//Calculate Entrainment Parcel's Freezing Level
					if (EparT[i]>0 && EparT[i+1]<0){
						wt = getIntpWt(EparT[i],EparT[i+1],0)
						fpl = (parP[i]*wt[0]) + (parP[i+1]*wt[1])
					}else if (EparT[i]==0){fpl = parP[i]}
					
					//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + " - - " + i + " | P: " + parT[i] + " eEn: " + eEn + " | eParLR: " + eParLR + "<br>"
					
					//Max Positive Energy is the total ECAPE for this entrainment rate
					if (eEn>eEnMax){eEnMax=eEn}
					
					//Find the level of neutral buoyancy - equilibrium level
					if(eEnMax>1 && EparT[i]>envT[i] && EparT[i+1]<=envT[i+1]){
						xOverP = xSectPts(coordX(envT[i+1],envP[i+1]),coordX(EparT[i+1],parP[i+1]),coordX(envT[i],envP[i]),coordX(EparT[i],parP[i]),parP[i+1],parP[i])
					}
					//Stop processing energy calc at Diluted Parcel MPL (Total Integrated Energy = Max Positive Integrated Energy)
					if (i == parP.length-2 || (eEnMax > ecape && eEn + ecape <= 0) || eEn + ecape < 0 ){
						if (i == parP.length-2){
							mplP = parP[parP.length-1]
							mplT = EparT[EparT.length-1]
						}else{
							enDiff = eEn + ecape
							wt1 = enDiff/enLvl
							wt2 = 1 - wt1
							mplP = (parP[i]*wt1) + (parP[i+1]*wt2)
							//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "eEn: " + eEn + " | ECAPE: " + ecape + " | p1: " + parP[i]+ " | p2: " + parP[i+1]+ " | wt1: " + wt1 + "<br>"
							mplT = (EparT[i]*wt1) + (EparT[i+1]*wt2)
							TPdilutePar[TPdilutePar.length-1]=[mplT,mplP]
						}
						break
					}
					// Smoothing function to increase entrainment/lapse rate in the profile
					if (count < fracE-8){count = count + 1}else{
						count = count + ((fracE-count)/3)
					}
				}
				//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "eEnMax: " + eEnMax + " | fin eEn: " + eEn + " | cnt: " + count + " | fracE: " + fracE + "<br>" 
			}
		}
	}
	return [TPdilutePar,xOverP,wPEA,fpl]
}

//Draw the ECAPE parcel from the calculated temperature array 
function drawECAPEparcel(eParDat){
	//document.getElementById("divtest").innerHTML = "start Draw " + eParDat[1] + "<br>" + eParDat[2] + "<br>" + eParDat[3]
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	TPdilutePar = eParDat[0]
	xOverP = eParDat[1] 
	//Draw Parcel Temperature
	ctx.lineWidth = 2;
	ctx.strokeStyle = '#000000';
	ctx.setLineDash([])
	ctx.beginPath();
	y1 = coordY(TPdilutePar[0][1])
	x1 = coordX(TPdilutePar[0][0],TPdilutePar[0][1])
	ctx.moveTo(x1, y1);
	for (var i=1;i<TPdilutePar.length;i++){
		y2 = coordY(TPdilutePar[i][1])
		x2 = coordX(TPdilutePar[i][0],TPdilutePar[i][1])
		ctx.lineTo(x2,y2)
	}
	ctx.stroke();	
	
	//xOverT = interpLvl('T',xOverP,'P')
	//document.getElementById("divtest").innerHTML = "x/p " + xOverP
	
	//Negative Energy Outline of Entrainment Parcel
	ctx.lineWidth = 3;
	ctx.strokeStyle = '#00F0FF';
	ctx.setLineDash([1,2])
	ctx.beginPath();
	i=0
	while (TPdilutePar[i+1][1]>=xOverP){i++}
	y1 = coordY(TPdilutePar[i][1])
	x1 = coordX(TPdilutePar[i][0],TPdilutePar[i][1])
	ctx.moveTo(x1, y1);
	for (var i=i;i<TPdilutePar.length;i++){
		y2 = coordY(TPdilutePar[i][1])
		x2 = coordX(TPdilutePar[i][0],TPdilutePar[i][1])
		ctx.lineTo(x2,y2)
	}
	ctx.stroke();
	
	//Positive Energy Outline of Entrainment Parcel
	ctx.lineWidth = 3;
	ctx.strokeStyle = '#FFCD00';
	ctx.setLineDash([1,2])
	ctx.beginPath();
	y1 = coordY(TPdilutePar[0][1])
	x1 = coordX(TPdilutePar[0][0],TPdilutePar[0][1])
	ctx.moveTo(x1, y1);
	for (var i=1;i<TPdilutePar.length-1;i++){
		y2 = coordY(TPdilutePar[i][1])
		x2 = coordX(TPdilutePar[i][0],TPdilutePar[i][1])
		if (TPdilutePar[i][1]<xOverP){break}
		ctx.lineTo(x2,y2)
	}
	ctx.lineTo(x2,y2)
	ctx.stroke();
	
	//Draw MPL Marker
	ctx.lineWidth = 1
	ctx.fillStyle = '#5E41FF'
	ctx.strokeStyle = '#5E41FF'
	ctx.font = "11px Arial";
	ctx.setLineDash([])
	ctx.beginPath()
	y = coordY(TPdilutePar[TPdilutePar.length-1][1])
	x = coordX(TPdilutePar[TPdilutePar.length-1][0],TPdilutePar[TPdilutePar.length-1][1])
	ctx.moveTo(x-2,y)
	ctx.lineTo(x-17,y)
	ctx.fillText('ECAPE', x-50, y-7);
	ctx.fillText('MPL', x-43, y+7);
	ctx.stroke()

}		
	
// Draws the Energy areas on the skew-t from coordinates defined in Parcel Energy Area Function
function drawEnAreas(storeEnAreas){
	//document.getElementById("divtest").innerHTML = "shade1"
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	//Cycle thru each energy area
	for (var j=0;j<storeEnAreas.length;j++){
		//Settings for both CAPE and CIN
		ctx.lineWidth = 2;
		ctx.setLineDash([])
		if (storeEnAreas[j][2]>0){
			//document.getElementById("divtest").innerHTML = "shadeRed"
			//Settings for CAPE
			ctx.strokeStyle = '#FFC0C0'
			ctx.fillStyle = '#FFC0C0'		
		}else{
			//Settings for CIN
			//document.getElementById("divtest").innerHTML = "shadeBlue"
			ctx.strokeStyle = '#9EB8FF'
			ctx.fillStyle = '#9EB8FF'
		}
		// Start drawing Energy area and iterate thru coordinates
		ctx.beginPath()
		enX = storeEnAreas[j][0]
		enY = storeEnAreas[j][1]
		ctx.moveTo(enX[0],enY[0])
		for(i=1;i<enX.length;i++){ctx.lineTo(enX[i],enY[i])}
		ctx.lineTo(enX[0],enY[0])
		ctx.fill()
		ctx.stroke();
	}
}

// Calculate Updraft Parcel Temperature Profile
function parcel(lvl){
	LCLvals = findLCL(atmT[lvl],atmDP[lvl],atmP[lvl])
	THo = DALRtheta(atmT[lvl],atmP[lvl])
	Wo = Ws(atmDP[lvl],atmP[lvl])
	//document.getElementById("divtest").innerHTML = "T: " + atmT[lvl] + " |P: " + atmP[lvl] + " |TH: " + THo + " |Wo: " + Wo
	
	parT = [atmT[lvl]]
	parP = [atmP[lvl]]
	parDTv = [0]
	envTv = [virtTemp(atmT[lvl],Ws(atmDP[lvl],atmP[lvl]))]
	
	lastT = LCLvals[0]
	dp = 25
	//Get Pressure on 25 hPa increment
	if (lvl==0){Zo=atmP[1]+25}else{Zo=atmP[lvl]}
	
	for (var z=Zo-dp;z>=50;z=z-dp){
		if (z > LCLvals[1]){
			//DALR For Unsaturated Parcel
			tempParcel = DALRtemp(THo,z)
			VtempParcel = virtTemp(tempParcel,Wo)
			//Get Sounding Temp/Dew Point for Virtual Temp
			lvlEnvTemps = interpolateEnvTemp(z)
			VtempEnv = virtTemp(lvlEnvTemps[0],Ws(lvlEnvTemps[1],z))
			parT.push(tempParcel)
			parP.push(z)
			parDTv.push(VtempParcel-VtempEnv)
			envTv.push(VtempEnv)
			//parDTv.push(VtempParcel)
		}else{
			//First level above push LCL values for parcel
			if (parP[parP.length-1]>=LCLvals[1]){
				VtempParcel = virtTemp(LCLvals[0],Ws(LCLvals[0],LCLvals[1]))
				lvlEnvTemps = interpolateEnvTemp(LCLvals[1])
				VtempEnv = virtTemp(lvlEnvTemps[0],Ws(lvlEnvTemps[1],z))
				parT.push(LCLvals[0])
				parP.push(LCLvals[1])
				parDTv.push(VtempParcel-VtempEnv)
				envTv.push(VtempEnv)
				//parDTv.push(VtempParcel)
			}
			//Saturated parcel continues up following MALR
			tempParcel = dtMALR(parP[parP.length-1],parT[parT.length-1],parP[parP.length-1]-z)
			VtempParcel = virtTemp(tempParcel,Ws(tempParcel,z))
			lvlEnvTemps = interpolateEnvTemp(z)
			VtempEnv = virtTemp(lvlEnvTemps[0],Ws(lvlEnvTemps[1],z))
			parT.push(tempParcel)
			parP.push(z)
			parDTv.push(VtempParcel-VtempEnv)
			envTv.push(VtempEnv)
			//parDTv.push(VtempParcel)
		}
	}
	return [parT,parP,parDTv,envTv,lvl]
}

// Calculate Updraft Parcel Temperature Profile
function MLparcel(){
	// Calcuate Low Level Average Parcel Temp & Dew Point.  Set to level index 3 for pressure
	totT = 0
	totDP = 0
	totZ = 0
	for (var i=0;i<6;i++){
		totT = totT + atmT[i]
		totDP = totDP + atmDP[i]	
		totZ = totZ + atmZ[i]
	}
	mlT = totT/6
	mlDP = totDP/6
	mlZ = totZ/6
	mlP = interpLvl("P",mlZ,"AGL")
	lvl = 3
	
	LCLvals = findLCL(mlT,mlDP,mlP)
	THo = DALRtheta(mlT,mlP)
	Wo = Ws(mlDP,mlP)
	//document.getElementById("divtest").innerHTML = "T: " + atmT[lvl] + " |P: " + atmP[lvl] + " |TH: " + THo + " |Wo: " + Wo
	
	parT = [mlT]
	parP = [mlP]
	parDTv = [0]
	envTv = [virtTemp(mlT,Ws(mlDP,mlP))]
		
	lastT = LCLvals[0]
	dp = 25
	//Get Pressure on 25 hPa increment
	for (var i=0;atmP[i]>mlP;i++){Zo=atmP[i]}
	
	for (var z=Zo-dp;z>50;z=z-dp){
		if (z > LCLvals[1]){
			//DALR For Unsaturated Parcel
			tempParcel = DALRtemp(THo,z)
			VtempParcel = virtTemp(tempParcel,Wo)
			//Get Sounding Temp/Dew Point for Virtual Temp
			lvlEnvTemps = interpolateEnvTemp(z)
			VtempEnv = virtTemp(lvlEnvTemps[0],Ws(lvlEnvTemps[1],z))
			parT.push(tempParcel)
			parP.push(z)
			parDTv.push(VtempParcel-VtempEnv)
			envTv.push(VtempEnv)
			//parDTv.push(VtempParcel)
		}else{
			//First level above push LCL values for parcel
			if (parP[parP.length-1]>=LCLvals[1]){
				VtempParcel = virtTemp(LCLvals[0],Ws(LCLvals[0],LCLvals[1]))
				lvlEnvTemps = interpolateEnvTemp(LCLvals[1])
				VtempEnv = virtTemp(lvlEnvTemps[0],Ws(lvlEnvTemps[1],z))
				parT.push(LCLvals[0])
				parP.push(LCLvals[1])
				parDTv.push(VtempParcel-VtempEnv)
				envTv.push(VtempEnv)
				//parDTv.push(VtempParcel)
			}
			//Saturated parcel continues up following MALR
			tempParcel = dtMALR(parP[parP.length-1],parT[parT.length-1],parP[parP.length-1]-z)
			VtempParcel = virtTemp(tempParcel,Ws(tempParcel,z))
			lvlEnvTemps = interpolateEnvTemp(z)
			VtempEnv = virtTemp(lvlEnvTemps[0],Ws(lvlEnvTemps[1],z))
			parT.push(tempParcel)
			parP.push(z)
			parDTv.push(VtempParcel-VtempEnv)
			envTv.push(VtempEnv)
			//parDTv.push(VtempParcel)
		}
	}
	return [parT,parP,parDTv,envTv,3]
}

// Draw Downdraft Parcel Path with DCAPE shadings
function DparcelArea(DparT,DparDTv,envTv,lvl){
	dcapeDat = []
	// Arrays to capture Parcel Coords for DCAPE shade area
	dcapeX = []
	dcapeY = []
	// Arrays to capture Environmental Coords for DCAPE shade area
	Xdcape = []
	Ydcape = []
	
	eDCAPE = 0	
	Ptotal = 0
	Ztotal = 0
	for (var i=0;i<=lvl;i++){
		//DCAPE - Compute and Integrate Downdraft Energy Area surface to level of interest
		if(i<lvl){
			dT_avg = (DparDTv[i] + DparDTv[i+1])/2
			T_avg = (envTv[i] + envTv[i+1])/2
			dZ = atmZ[i+1] - atmZ[i]
			eDCAPE = eDCAPE + (-9.8 * dT_avg * dZ / (T_avg + ZEROCNK))
		}
		//Store XY Coords
		dcapeY.push(coordY(atmP[i]))
		dcapeX.push(coordX(DparT[i],atmP[i]))
		Ydcape.push(coordY(atmP[i]))
		Xdcape.push(coordX(atmT[i],atmP[i]))
		//Total P and Z to weight environmental winds
		Ptotal = Ptotal + atmP[i]
		Ztotal = Ztotal + atmZ[i]
	}
		uAvgP = 0
		vAvgP = 0
		uAvgZ = 0
		vAvgZ = 0
	for (var i=0;i<=lvl;i++){
		uAvgP = uAvgP + ((atmP[i]/Ptotal)* atmWND[i][0])
		vAvgP = vAvgP + ((atmP[i]/Ptotal)* atmWND[i][1])
		uAvgZ = uAvgZ + ((atmZ[i]/Ztotal)* atmWND[i][0])
		vAvgZ = vAvgZ + ((atmZ[i]/Ztotal)* atmWND[i][1])
	}

	dcapeY = dcapeY.concat(Ydcape.reverse())
	dcapeX = dcapeX.concat(Xdcape.reverse())
	
	dcapeDat=[atmZ[lvl],Math.round(eDCAPE),[uAvgP,vAvgP],[uAvgZ,vAvgZ],dcapeY,dcapeX,DparT]
	return dcapeDat
}

// Plots the DCAPE Parcel
function plotDCAPE(lvl){
	iDPAR = lvl
	//Draws downdraft parcel profile with DCAPE areas only when viewing Downdrafts
	iPARCEL = iMU
	plotClear()
	BGHighlights()
	BGShadeEnergy()
				
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	
	dcapeY = atmDCAPE[lvl][4]
	dcapeX = atmDCAPE[lvl][5]
	DparT = atmDCAPE[lvl][6] 
	
	ctx.lineWidth = 1;
	ctx.strokeStyle = '#C6B4E3'
	ctx.fillStyle = '#C6B4E3'
	ctx.setLineDash([])
	ctx.beginPath()
	ctx.moveTo(dcapeX[0],dcapeY[0])
	for(i=1;i<dcapeX.length;i++){ctx.lineTo(dcapeX[i],dcapeY[i])}
	ctx.fill()
	ctx.stroke()
	
	drawBGlines()
	drawProfTemps()
	drawParcelTemps()
	if (atmEnDAT[iMU]>100){
		eParDat = calcECAPEparcel(iMU)
		drawECAPEparcel(eParDat)
	}
				
	//Draw Parcel Temperature
	ctx.lineWidth = 2;
	ctx.strokeStyle = 'purple';
	ctx.setLineDash([2,3])
	ctx.beginPath()
	y1 = coordY(atmP[0])
	x1 = coordX(DparT[0],atmP[0]) 
	ctx.moveTo(x1, y1);
	for (var i=0;i<=lvl;i++){
		y2 = coordY(atmP[i])
		x2 = coordX(DparT[i],atmP[i])
		ctx.lineTo(x2,y2)
	}
	ctx.stroke()
	
	plotHeights()
	plotWindBarbs()
	
}

// Calculate Downdraft Parcel Temperature Profile
function Dparcel(lvl){
	wetBulbTemp = getWetBulbTemp(lvl)
	
	DparT = [wetBulbTemp]
	DparP = [atmP[lvl]]
	VtempParcel = virtTemp(wetBulbTemp,Ws(wetBulbTemp,atmP[lvl]))
	envTv = [virtTemp(atmT[lvl],Ws(atmDP[lvl],atmP[lvl]))]
	DparDTv = [VtempParcel-envTv[0]]	

	for (var i=lvl-1;i>=0;i--){
		tempParcel = dtMALR(DparP[DparP.length-1],DparT[DparT.length-1],DparP[DparP.length-1]-atmP[i])
		VtempParcel = virtTemp(tempParcel,Ws(tempParcel,atmP[i]))
		VtempEnv = virtTemp(atmT[i],Ws(atmDP[i],atmP[i]))
		DparT.push(tempParcel)
		DparP.push(atmP[i])
		envTv.push(VtempEnv)
		DparDTv.push(VtempParcel-VtempEnv)
	}
	DparT = DparT.reverse()
	DparDTv = DparDTv.reverse()
	envTv = envTv.reverse()
	return [DparT,DparDTv,envTv]
}

// Calculate NCAPE Normalized CAPE from parcel level
function calcNCAPE(parlvl){
	enDat = atmEnDAT[parlvl]
	if (enDat[4] < 1 || enDat[1]==null || isNaN(enDat[1])){
		ncape = 0.00
	}else{
		cape = enDat[4]
		Zel = interpLvl("AGL",enDat[0],"P") 
		Zlfc = interpLvl("AGL",enDat[1],"P")
		ncape = Math.round((cape/(Zel - Zlfc))*100)/100
	}
	return ncape
}

// Calculate ThetaE difference: (ThetaE_SFC - ThetaE_min)
function calcTeD(){
	thEsfc = calcThetaE(atmP[0],atmT[0],atmDP[0])
	thEmin = thEsfc
	for(var i=1;atmP[i]>=300;i++){
		val = calcThetaE(atmP[i],atmT[i],atmDP[i])
		if (val < thEmin){thEmin=val}
	}
	TeD = thEsfc - thEmin
	return TeD
}

//Supercell Composite Parameter SCP: https://www.spc.noaa.gov/help/scp.html
function calcSCP(){
	//MU-ECAPE instead of MUCAPE (J/Kg)
	eTilde = calcETILDE(iMU)
	ecape = eTilde[0]
	//3KM ESRH from GUI for Effective Storm realative Helicity (M^2/S^2)
	esrh = parseInt(document.getElementById("tblHel").rows[3].cells[2].innerHTML)
	//Effective Bulk Shear from GUI for EBWD (Min-max 10-30 m/s) TERM max of 1.5
	ebwdTXT = document.getElementById("tblShear").rows[2].cells[1].innerHTML.split('<span class="tooltiptext"><br>')
	ebwd = conKT2MS(parseInt(ebwdTXT[0].slice(21)))
	if (ebwd<10){ebwd=0}else if (ebwd>20){ebwd=20}
	
	scp = (ecape/1000) * (esrh/50) * (ebwd/10)
	return scp
}

//Significant Tornado Parameter STP: https://www.spc.noaa.gov/help/stp.html
function calcSTP(){ 
	//ml-ECAPE instead of mlCAPE (J/Kg)
	eTilde = calcETILDE(atmEnDAT.length-1)
	ecape = eTilde[0]
	//0.5KM ESRH from GUI for Effective Storm realative Helicity (M^2/S^2)
	esrh = parseInt(document.getElementById("tblHel").rows[1].cells[2].innerHTML)
	//Effective Bulk Shear from GUI for EBWD (Min-max 10-30 m/s) TERM max of 1.5
	ebwdTXT = document.getElementById("tblShear").rows[2].cells[1].innerHTML.split('<span class="tooltiptext"><br>')
	ebwd = conKT2MS(parseInt(ebwdTXT[0].slice(21)))
	if (ebwd<12){ebwd=0}else if (ebwd>18){ebwd=18}
	pLCL = atmEnDAT[atmEnDAT.length-1][2]
	zLCL = interpLvl("AGL",pLCL,"P")
	if (zLCL<1000){zLCL=1000}
	//CINH - Term is set to 1 with less CINH or values > -50 J/Kg
	cin = atmEnDAT[atmEnDAT.length-1][5]
	if (cin > -50){cin = -50}
	
	
	stp = (ecape/1500) * (esrh/125) * (ebwd/12) *  ((2000-zLCL)/1000) * ((cin+200)/150)
	return stp
}

//Calculate Precipitable Water
function calcPWI(){
	// ( rt / (g x rho) ) x dP
	// https://geo.libretexts.org/Bookshelves/Meteorology_and_Climate_Science/Practical_Meteorology_(Stull)/04%3A_Water_Vapor/4.02%3A_Total_Water
	PWI = 0
	for (var z=0;atmP[z]>150;z++){
		rt = (Ws(atmDP[z],atmP[z]) + Ws(atmDP[z+1],atmP[z+1]))/2
		dP = atmP[z] - atmP[z+1]
		dw = (rt * dP)/98
		PWI = PWI + dw
	}
	return PWI
}

//Calculate the Galvaz-Davison Index for Tropical Convection
function calcGDI(){
	//Constants 
    alpha = -10
	beta = 303
	gamma =0.065
	tau = 263.15
	mu = -7
	sigma = 1.5
	p1 = 500
	p2 = 9000
	p3 = 18
	//Profile Inputs
	Psfc = atmP[0]
	
	//approx 950mb
	hgt = 600
	p = interpLvl('P',hgt,'AGL')
	t = interpLvl('T',hgt,'AGL')
	dp = interpLvl('DP',hgt,'AGL')
	T950 = t
	Te950 = calcThetaE(p,t,dp)
	
	//approx 850mb
	hgt = 1500
	p = interpLvl('P',hgt,'AGL')
	t = interpLvl('T',hgt,'AGL')
	dp = interpLvl('DP',hgt,'AGL')
	Te850 = calcThetaE(p,t,dp)
	
	//approx 700mb
	hgt = 3100
	p = interpLvl('P',hgt,'AGL')
	t = interpLvl('T',hgt,'AGL')
	dp = interpLvl('DP',hgt,'AGL')
	T700 = t
	Te700 = calcThetaE(p,t,dp)
	
	//approx 500mb
	hgt = 5800
	p = interpLvl('P',hgt,'AGL')
	t = interpLvl('T',hgt,'AGL')
	dp = interpLvl('DP',hgt,'AGL')
	T500 = t
	Te500 = calcThetaE(p,t,dp)
	
	wx_data = [Psfc,T950+ZEROCNK,Te950+ZEROCNK,Te850+ZEROCNK,T700+ZEROCNK,Te700+ZEROCNK,T500+ZEROCNK,Te500+ZEROCNK]
	
	// Equivilant Potential Temperature Levels (3.8,3.9,3.10)
    eptA = wx_data[2]
    eptB = ((wx_data[3] + wx_data[5])/2) + alpha
    eptC = wx_data[7] + alpha
    // Column Buoyancy Index (3.13) 
    ME = eptC - beta
    LE = eptA - beta
    if (LE > 0){
        CBI = gamma * LE * ME 
    }else{
        CBI = 0
	}
    // Mid Trop Warming/Stabilization Index (3.14) 
    if ((wx_data[6] - tau) > 0){
        MWI = mu*(wx_data[6] - tau)
    }else{
        MWI = 0
	}
    // Inversion Index (3.15) 
    S = wx_data[1] - wx_data[4]
    D = eptB - eptA
    if ((S + D) < 0){
        II = sigma * (S + D)
    }else{
        II = 0
	}
    // Terrain Correction (3.18) 
    TC = p3 - (p2/(wx_data[0] - p1))
    // Galvez-Davison Index (3.1) 
    GDI = CBI + MWI + II  //+ TC
    return Math.round(GDI*10)/10
	
}

// Find Convective Condensation Level and Convective Temperature
function getTcCCL(){
	mxR = Ws(atmDP[0],atmP[0])
	tmr = mxratio(mxR,atmP[0])
	//Up Mx Ratio until T becomes warmer than atmT.  
	for(var z=0;tmr<atmT[z];z++){tmr = mxratio(mxR,atmP[z])}
	//Find atmTemp Intersect with MxRatio
	if (z>0){
		tmrb = mxratio(mxR,atmP[z-1],atmP[z-1])
		Pccl = xSectPts(atmT[z],tmr,atmT[z-1],tmrb,atmP[z],atmP[z-1])
	}else{
		Pccl = atmP[0]
	}
	//Find atmT at CCL
	Tccl = interpLvl('T',Pccl,'P')
	//Find ConvT from CCL down Dry Adiabat to SFC
	Tc = DALRtemp(DALRtheta(Tccl,Pccl),atmP[0])
	return [Tc,Pccl]
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Units Converstions and A/N Display Formats
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function getDispDDD(intDir){
	if(intDir<0){intDir=intDir+360}
	if(intDir>360){intDir=intDir-360}
	if (intDir == 0){
		txtDDD="360"
	}else if(intDir < 100){
		txtDDD = "0" + intDir
	}else{
		txtDDD = intDir
	}
	return txtDDD
}
// Get Display Values for Wind (ddd,ss)
function wndDisp(ddd,ss){
	sp = Math.round(ss)
	if (sp<10){sp='0'+sp}
	dir = getDispDDD(Math.round(ddd/10)*10)
	return [dir,sp]
}
// Get Display Values for Wind ([U,V]) -> [dir,sp]
function UVwndDisp(wnd){
	ddd = getDegAng(wnd[0],wnd[1])
	ss = getWndMag(wnd[0],wnd[1])
	sp = Math.round(ss)
	if (sp<10){sp='0'+sp}
	dir = getDispDDD(Math.round(ddd/10)*10)
	return [dir,sp]
}
// Get Display Values for Wind ([U,V]) -> [dir,sp]
function UVwndVals(wnd){
	ddd = getDegAng(wnd[0],wnd[1])
	ss = getWndMag(wnd[0],wnd[1])
	sp = Math.round(10*ss)/10
	dir = getDispDDD(Math.round(ddd))
	return [dir,sp]
}
// Get Direction from UV or Angle from XY 
function getDegAng(x,y) {
	angle = Math.atan2(y, x) * 180 / Math.PI
	if (angle <= 4){angle = angle + 360}
	if (angle > 360){angle = angle - 360}
	return angle
}
// Get Magnitude from UV components
function getWndMag(u,v){
	speed = Math.sqrt((u*u) + (v*v))
	return speed
}
// Get UV from Direction and Speed
function getWndUV(DDD,SS){
	rads = DDD * (Math.PI/180)
	u = SS * Math.cos(rads)
    v = SS * Math.sin(rads)
	return [u,v]
}
// Get Direction and Speed from UV
function getDirSp(wnd){
	ddd = getDegAng(wnd[0],wnd[1])
	ss = getWndMag(wnd[0],wnd[1])
	return [ddd,ss]
}
//Converts meters to feet
function conM2FT(valueM){
	if (isNaN(valueM)){conVal = 'M'}else{conVal = valueM*3.281}
	return conVal 
}
//Converts meters to feet Round Integer
function conM2FTint(valueM){
	if (isNaN(valueM)){conVal = 'M'}else{conVal = valueM*3.281}
	return Math.round(conVal)
}
//Converts feet to meters
function conFT2M(valueFT){
	if (isNaN(valueFT)){conVal = 'M'}else{conVal = valueFT/3.281}
	return conVal 
}
//Converts knots to meters/second
function conKT2MS(valueKT){
	if (isNaN(valueKT)){conVal = 'M'}else{conVal = valueKT/1.944}
	return conVal 
}
//Converts meters/second to knots
function conMS2KT(valueMS){
	if (isNaN(valueMS)){conVal = 'M'}else{conVal = valueMS*1.944}
	return conVal 
}
//Create Flight Level Display Format
function dispFL(valueFT){
	fl = valueFT/100
	if (fl<10){fl='00'+fl}else if(fl<100){fl='0'+fl}
	return fl 
}
//Converts Celsius to fahrenheit
function conC2F(valueC){
	if (isNaN(valueC)){conVal = 'M'}else{conVal = (valueC*(9/5))+32}
	return conVal 
}
//Converts Celsius to fahrenheit
function conMM2IN(valueMM){
	if (isNaN(valueMM)){conVal = 'M'}else{conVal = valueMM/25.4}
	return conVal 
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Text Color Formatting
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function fmtCell(paramBox, value, fmtType){
	paramBox.style.fontFamily = "Times New Roman"
	paramBox.style.fontWeight = "normal"
	switch(fmtType) {
		case 'cape': 
			gradColor(paramBox, value, 1, 75, 150, 300, 600, 800, 1200, 1800, 2500, 3000, 4000)
			break;
		case 'svrcape': 
			gradColor(paramBox, value, 150, 300, 600, 900, 1200, 1600, 2000, 3500, 3000, 3600, 4200)
			break;
		case 'ncape': 
			gradColor(paramBox, value, 0.01, 0.04, 0.07, 0.1, 0.13, 0.16, 0.19, 0.22, 0.25, 0.30, 0.40)
			break;
		case 'gdi': 
			gradColor(paramBox, value, -20, 0, 5, 15, 20, 25, 30, 35, 40, 45, 50)
			break;
		case 'cin': 
			cinhibit(paramBox, value)
			break;
		case 'dcape':	
			gradColor(paramBox, value, 1, 50, 100, 200, 400, 600, 800, 1000, 1200, 1400, 1600)
			break;
		case 'scp':	
			gradColor(paramBox, value, 1, 2, 3, 4, 5, 7, 9, 11, 14, 17, 20)
			break;
		case 'pwi':	
			gradWetDry(paramBox, value, 7, 13, 20, 30, 45, 65)
			break;
		case 'convtemp':
			gyare(paramBox, value, -5, -3, -1, 0, 3) //(+) above Tc
			break;
	// Bulk Wind Difference & Shear Total threshold
		//Effective 
		case 'bwde':
			gyare(paramBox, value, 1, 18, 29, 40, 63)
			break;
		case 'twde':
			gyare(paramBox, value*0.7, 1, 18, 29, 40, 63)
			break;
		//0 - 6 KM 
		case 'bwd06':
			gyare(paramBox, value, 1, 18, 29, 40, 63)
			break;
		case 'twd06':
			gyare(paramBox, value*0.7, 1, 18, 29, 40, 63)
			break;
		//0 - 12 KM 
		case 'bwd012':
			gyare(paramBox, value, 1, 15, 30, 50, 75)
			break;
		case 'twd012':
			gyare(paramBox, value*0.7, 1, 15, 30, 50, 75)
			break;
	//Tornado
		case 'fcbwd03':
			gyare(paramBox, value, 5, 30, 38, 45, 50)
			break;	
		case 'fcbwd01':
			gyare(paramBox, value, 1, 16, 22, 33, 38)
			break;
		case 'fclcl':
			paramBox.innerHTML = addTTT(Math.round(value), Math.round(conM2FT(value))+' ft')
			if (value < 950){gyare(paramBox, value, 200, 300, 400, 550, 700 )}else{gyare(paramBox, 950-value, -550, -425, -300, -250, -150)}
			break;
		case 'srh05':	
			gradColor(paramBox, Math.abs(value), 12, 25, 40, 55, 75, 100, 125, 150, 175, 200, 250)
			break;
		case 'srh1':	
			gradColor(paramBox, Math.abs(value), 25, 50, 75, 100, 125, 150, 175, 200, 250, 300, 400)
			break;
		case 'srh3':	
			gradColor(paramBox, Math.abs(value), 75, 100, 125, 150, 200, 250, 300, 350, 400, 450, 500)
			break;
		case 'fc16ratio':
			gyare(paramBox, value, 50, 75, 100, 115, 150)
			break;
		case 'stp':	
			gradColor(paramBox, value, 0.01, 0.5, 0.75, 0.9, 1, 1.25, 1.75, 3, 5, 9, 13)
			break;
	//Hail
		case 'grbwd01':
			gyare(paramBox, value*-1, -35, -30, -18, -13, 0)
			break;
		case 'grbwd112':
			gyare(paramBox, value, 15, 35, 48, 58, 75)
			break;
		case 'grline':
			gyare(paramBox, value, 45, 55, 65, 75, 90)
			break;
		case 'gr16ratio':
			gyare(paramBox, value*-1, -100, -88, -75, -50, -25)
			break;
		case 'lrhgz':
			gyare(paramBox, value, 5.9, 6.2, 6.5, 7, 8)
			break;
		case 'grrh':
			gyare(paramBox, value*-1, -90, -80, -65, -50, 0)
			break;
		case 'embwthk':
			gradColor(paramBox, value*-1, -4600, -4300, -4000, -3600, -3200, -2800, -2400, -2000, -1500, -1000, -500)
			break;
		case 'embwcape':
			//CAPE ratio'd by RH when used to threshold RH
			gradColor(paramBox, Math.abs(value)*-1, -800, -600, -450, -350, -300, -250, -200, -175, -150, -125, -100)
			break;
		case 'grothk':
			gradColor(paramBox, Math.abs(value), 4000, 5000, 6000, 7000, 8000, 9500, 11000, 12500, 14000, 15500, 17000)
			break;
	//Storm Relative Flows
		case 'srif':
			gyare(paramBox, value, 1, 12, 18, 28, 38)
			break;
		case 'srsfc':
			gyare(paramBox, value*0.75, 1, 12, 18, 28, 38)
			break;
		case 'srexh':
			gradWetDry(paramBox, value*-1, -60, -50, -40, -30, -20, -10)
			break;
	//Winter Precip
		case 'fzdzt':	
			supercooled(paramBox, value)
			break;
		case 'fzrat':	
			tempFz(paramBox, value, 0.2, 0.5, 1, 2)
			break;
		case 'snt':	
			snTempColor(paramBox, value)
			break;
		case 'cldRH':	
			cloudRH(paramBox, value, 90, 80, 70)
			break;
		case 'midrh':	
			gradWetDry(paramBox, value, 20, 35, 50, 65, 80, 90)
			break;
		case 'mxtxlr':	
			gradLapse(paramBox, value)
			break;
		case 'wndsp':	
			barp(paramBox, value, 25, 35, 50, 65)
			break;
	// Fog Visibility
		case 'invhead':
			if (value < 4){
				paramBox.style.color="#E9E9E9"
				paramBox.style.fontWeight="bold"
			}else{
				paramBox.style.color="#898989"
				paramBox.style.fontWeight="normal"
			}
			break;
		case 'tmptheta':
			gradColdHot(paramBox, value, 255, 270, 285, 300, 310, 320, 330, 340, 350, 360, 370, 380, 395)
			break;
		case 'tmpthetae':
			gradColdHot(paramBox, value, 300, 310, 315, 320, 325, 330, 335, 340, 345, 350, 355, 360, 370)
			break;
		case 'tmptmp':
			gradColdHot(paramBox, value, -50, -40, -30, -20, -10, 0, 5, 10, 15, 25, 30, 35, 40)
			break;
		case 'relhum':
			gradHumid(paramBox, value, 10, 20, 30, 40, 50, 60, 70, 80, 85, 90, 95)
			break;
		case 'margin':
			marginDefault(paramBox)
			break;
		case 'null':	
			fmtDefault(paramBox)
			break;
		default:
			fmtDefault(paramBox)
	}
}

//Sets colors (brown, amber, red, purple) for a parameter with defined thresholds
function barp(paramBox, value, th1, th2, th3, th4){
	fmtDefault(paramBox)
	rgbCode = "#9D9D9D"
	if (value >= th1){rgbCode="#B18904"}
	if (value >= th2){rgbCode="#D7DF01"}
	if (value >= th3){rgbCode="#FF0000"}
	if (value >= th4){rgbCode="#FB00FF"}
	paramBox.style.color=rgbCode
	paramBox.style.fontWeight="bold"
}

//Sets colors (green, yellow, amber, red, extreme) for a parameter with defined thresholds
function gyare(paramBox, value, th1, th2, th3, th4, th5){
	fmtDefault(paramBox)
	rgbCode = "#9D9D9D"
	if (value >= th1){rgbCode="#67A342"}//Green
	if (value >= th2){rgbCode="#ECEC1A"}//Yellow
	if (value >= th3){rgbCode="#EF8315"}//Amber
	if (value >= th4){rgbCode="#FF3939"}//Red
	if (value >= th5){rgbCode="#FB00FF"}//Violet
	paramBox.style.color=rgbCode
	paramBox.style.fontWeight="bold"
}

//Reset previously formatted cells to original format
function fmtDefault(paramBox){
	paramBox.style.color="#D8D8D8"
	paramBox.style.fontWeight="normal"
}

//Reset previously formatted cells to original format
function marginDefault(paramBox){
	paramBox.style.color="#F1F1F1"
	paramBox.style.fontWeight="bold"
}

//Sets colors for lapse rate based on stability %DALR
function gradLapse(paramBox, value){
	fmtDefault(paramBox)
	var rgbCode="#464F4E"
	if (value < 0){rgbCode="#7DA8A7"}
	if (value <= -5){rgbCode="#4DD7D4"}
	if (value <= -10){rgbCode="#00FFF9"}
	if (value >= 4){rgbCode="#6A3D3D"}
	if (value >= 6){rgbCode="#B05252"}
	if (value >= 8){rgbCode="#C83737"}
	if (value >= 10){rgbCode="#FF0000"}
	paramBox.style.color=rgbCode
	paramBox.style.fontWeight="bold"
}

/*
	if (value <= -8.5){rgbCode="#04B4AE"} 	//Supercooled Drops Close to too cold 
	if (value <= -9.5){rgbCode="#04B45F"}	//Supercooled Drops Closer to too cold
	if (value <= -10.5){rgbCode="#5FB404"}	//Supercooled Drops slight too cold
	if (value <= -11.5){rgbCode="#AEB404"}	//Supercooled Drops too cold
	if (value <= -12.5){rgbCode="#DF7401"}	//Glaciated -12
*/

//Sets colors for Liquid vs Supercooled Liquid vs Frozen
function supercooled(paramBox, value){
	var rgbCode="#00FFFF" //Supercooled Drops
	if (value >= -1.5){rgbCode="#00FF80"} 	//Supercooled Drops Getting Warm
	if (value >= -0.5){rgbCode="#E8FF00"}	//Supercooled Drops Melty
	if (value >= 1){rgbCode="#FF9700"}		//Supercooled Drops Melting
	if (value > 2){rgbCode="#FF0000"}       //Liquid
	/// Supercooled Liquid 
	if (value <= -8.5){rgbCode="#21D6D6"} 	//Supercooled Drops Close to too cold 
	if (value <= -9.5){rgbCode="#71C8A4"}	//Supercooled Drops Closer to too cold
	if (value <= -10.5){rgbCode="#B5D48A"}	//Supercooled Drops slight too cold
	if (value <= -11.5){rgbCode="#C4A270"}	//Supercooled Drops too cold
	if (value <= -12.5){rgbCode="#FF8F34"}	//Glaciated -12
	paramBox.style.color=rgbCode
	paramBox.style.fontWeight="bold"
}

//Grey to white scale estimating clouds
function cloudRH(paramBox, value, th1, th2, th3){
	fmtDefault(paramBox)
	//rgbCode="#FFFFFF"
	if (value < th1){rgbCode="#F2F2F2"}
	if (value < th2){rgbCode="#A4A4A4"}
	if (value < th3){rgbCode="#585858"}
	paramBox.style.color=rgbCode
	paramBox.style.fontWeight="bold"
}

//Sets colors for freezing and melting
function tempFz(paramBox, value, th1, th2, th3, th4){
	fmtDefault(paramBox)
	var rgbCode="#F333FF" //FREEZING 0C
	if (value <= -1*th1){rgbCode="#E4C8FF"}
	if (value <= -1*th2){rgbCode="#C6C0FF"}
	if (value <= -1*th3){rgbCode="#89B9FF"}
	if (value <= -1*th4){rgbCode="#25F5FF"}
	//if (value == th5){rgbCode="#FF00FF"}//FREEZING 0C
	if (value >= th1){rgbCode="#FF33AF"}
	if (value >= th2){rgbCode="#FF3383"}
	if (value >= th3){rgbCode="#FF3355"}
	if (value >= th4){rgbCode="#FF3B3B"}
	paramBox.style.color=rgbCode
	paramBox.style.fontWeight="bold"
}

//Color for Temps determining SLR (Rime/Dentrites/Needles)
function snTempColor(paramBox, value){
	fmtDefault(paramBox)
	var rgbCode="#FFFF00"
	if (value <= 0){rgbCode="#9AFE2E"}
	if (value <= -2){rgbCode="#62FC5A"}
	if (value <= -4){rgbCode="#81E8AC"}
	if (value <= -6){rgbCode="#78DAE7"}
	if (value <= -8){rgbCode="#4677FF"}
	if (value <= -10){rgbCode="#A882FF"}
	if (value <= -12){rgbCode="#F392F0"}
	if (value <= -14){rgbCode="#F454FE"}
	if (value <= -16){rgbCode="#F392F0"}
	if (value <= -18){rgbCode="#4677FF"}
	if (value <= -20){rgbCode="#78DAE7"}
	paramBox.style.color=rgbCode
	paramBox.style.fontWeight="bold"
}

//Sets colors for Wet vs Dry 
function gradWetDry(paramBox, value, th1, th2, th3, th4, th5, th6){
	fmtDefault(paramBox)
	var rgbCode="#EB4B00"
	if (value >= th1){rgbCode="#FF9327"}
	if (value >= th2){rgbCode="#D8A700"}
	if (value >= th3){rgbCode="#C4CB00"}
	if (value >= th4){rgbCode="#62BF00"}
	if (value >= th5){rgbCode="#00BF00"}
	if (value >= th6){rgbCode="#00FF42"}
	paramBox.style.color=rgbCode
	paramBox.style.fontWeight="bold"
}

//Sets colors for Relative Humidity 
function gradHumid(paramBox, value, th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11){
	fmtDefault(paramBox)
	var rgbCode="#FF6F69"
	if (value >= th1){rgbCode="#FF8D69"}
	if (value >= th2){rgbCode="#FFA469"}
	if (value >= th3){rgbCode="#FFC469"}
	if (value >= th4){rgbCode="#FFDB69"}
	if (value >= th5){rgbCode="#FDFF69"}
	if (value >= th6){rgbCode="#D4FF69"}
	if (value >= th7){rgbCode="#A6FF69"}
	if (value >= th8){rgbCode="#69FF79"}
	if (value >= th9){rgbCode="#69FFAD"}
	if (value >= th10){rgbCode="#69FFEF"}
	if (value >= th11){rgbCode="#69CDFF"}
	paramBox.style.color=rgbCode
	paramBox.style.fontWeight="bold"
}

//12-Color graduation
function gradColor(paramBox, value, th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11){
	fmtDefault(paramBox)
	var rgbCode="#76A670"
	if (value >= th1){rgbCode="#67A342"}
	if (value >= th2){rgbCode="#86C431"}
	if (value >= th3){rgbCode="#D0D448"}
	if (value >= th4){rgbCode="#ECEC1A"}
	if (value >= th5){rgbCode="#E5B73F"}
	if (value >= th6){rgbCode="#EF8315"} 
	if (value >= th7){rgbCode="#FF6902"}
	if (value >= th8){rgbCode="#D64C4C"}
	if (value >= th9){rgbCode="#FF2727"}
	if (value >= th10){rgbCode="D05894"}
	if (value >= th11){rgbCode="FF36FF"}
	paramBox.style.color=rgbCode
	paramBox.style.fontWeight="bold"
}

//12-Color graduation
function gradColdHot(paramBox, value, th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13){
	fmtDefault(paramBox)
	var rgbCode="#C3CEFF"
	if (value >= th1){rgbCode="#8198FF"}
	if (value >= th2){rgbCode="#81CFFF"}
	if (value >= th3){rgbCode="#81F2FF"}
	if (value >= th4){rgbCode="#81FFF0"}
	if (value >= th5){rgbCode="#81FFBA"}
	if (value >= th6){rgbCode="#89FF81"} 
	if (value >= th7){rgbCode="#CAFF81"}
	if (value >= th8){rgbCode="#FFF481"}
	if (value >= th9){rgbCode="#FFB881"}
	if (value >= th10){rgbCode="#FF8181"}
	if (value >= th11){rgbCode="#FF81C2"}
	if (value >= th12){rgbCode="#F781FF"}
	if (value >= th13){rgbCode="#FF3DFA"}
	paramBox.style.color=rgbCode
	paramBox.style.fontWeight="bold"
}

//Sets colors for CINH 
function cinhibit(paramBox, value){
	fmtDefault(paramBox)
	paramBox.style.fontWeight="normal"
	var rgbCode="#909090"
	if (value < -10){rgbCode="#87A5C9"}
	if (value < -25){rgbCode="#5496E8"}
	if (value < -50){rgbCode="#1981FF"}
	if (value < -100){rgbCode="#73D6FD"}
	if (value < -150){
		rgbCode="#7CF2FD"
		paramBox.style.fontWeight="bold"
	}
	if (value < -200){rgbCode="#91FDFA"}
	paramBox.style.color=rgbCode
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Thunderstorm View 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Initiates Thunderstorm View 
function viewTSdisp(){
	document.getElementById("mcParcel").style.visibility = "hidden"
	document.getElementById("mcDCAPE").style.visibility = "hidden"
	document.getElementById("parDCAPE").style.visibility = "hidden"
	document.getElementById("mcHail").style.visibility = "hidden"
	document.getElementById("mcHailGraph").style.visibility = "hidden"
	document.getElementById("mcFZpro").style.visibility = "hidden"
	document.getElementById("mcMxTx").style.visibility = "hidden"
	document.getElementById("mcRain").style.visibility = "hidden"
	document.getElementById("mcTurb").style.visibility = "hidden"
	document.getElementById("mcTorn").style.visibility = "hidden"
	document.getElementById("mcFog").style.visibility = "hidden"
	document.getElementById("mcEnergy").style.visibility = "visible"
	var calTbl = document.getElementById("mcParcel").style
	calTbl.visibility = "visible"
	calTbl.top = 188
	calTbl.left = 565
	iniTSdisp()
}

// Initiates Thunderstorm View 
function iniTSdisp(){		
	dispParcel(iPARCEL)
	energyLevelsTbl(1)
	
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	
	convVals = getTcCCL()
	Tccl = convVals[1]
	Tc = convVals[0]
	
	//CCL - Line
	ctx.lineWidth = 1
	ctx.fillStyle = 'Purple'
	ctx.strokeStyle = 'Purple'
	ctx.font = "11px Arial";
	ctx.setLineDash([])
	ctx.beginPath()
	y = coordY(Pccl)
	x = coordX(Tccl,Pccl)
	ctx.moveTo(x,y)
	ctx.lineTo(x+15,y)
	ctx.fillText('CCL', x+18, y+4);
	ctx.stroke()
	
	//Tc - Marker
	TcTxt = Math.round(Tc*10)/10 + "\u00B0C"
	y = coordY(atmP[0])
	x = coordX(Tc,atmP[0])
	ctx.fillStyle = 'Purple'
	ctx.font = "11px Arial";
	ctx.beginPath();
	ctx.rect(x-3,y-3,6,6)
	ctx.fillText("Tc", x-5, y+13);
	ctx.fillText(TcTxt, x-11, y+24);
	ctx.fill();
	ctx.stroke
	
}

// Label Skew-T With Significant Levels
function markParcel(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	
	parsDat = atmEnDAT[iPARCEL][10]
	iLCL = atmEnDAT[iPARCEL][6]
	originP = atmEnDAT[iPARCEL][3]
	parT = parsDat[0]
	parP = parsDat[1]
		
	//Draw LCL Marker
	ctx.lineWidth = 1
	ctx.fillStyle = '#565656'
	ctx.strokeStyle = '#565656'
	ctx.font = "11px Arial";
	ctx.setLineDash([])
	ctx.beginPath()
	y = coordY(parP[iLCL])
	x = coordX(parT[iLCL],parP[iLCL]) - 2
	ctx.moveTo(x,y)
	ctx.lineTo(x-15,y)
	ctx.fillText('LCL', x-35, y+5);
	ctx.stroke()
	
	if(atmEnDAT[iPARCEL][4]>0){
		//Draw LFC Marker
		Plfc = atmEnDAT[iPARCEL][1]
		Tlfc = interpLvl('T',Plfc,'P')
		
		ctx.lineWidth = 1
		ctx.fillStyle = '#0017FF'
		ctx.strokeStyle = '#0017FF'
		ctx.font = "11px Arial";
		ctx.setLineDash([])
		ctx.beginPath()
		y = coordY(Plfc)
		x = coordX(Tlfc,Plfc) + 12
		ctx.moveTo(x,y)
		ctx.lineTo(x+17,y)
		ctx.fillText('LFC', x+27, y+4);
		ctx.stroke()
		
		//Draw EL Marker
		Pel = atmEnDAT[iPARCEL][0]
		Tel = interpLvl('T',Pel,'P')
		ctx.lineWidth = 1
		ctx.fillStyle = '#0017FF'
		ctx.strokeStyle = '#0017FF'
		ctx.font = "11px Arial";
		ctx.setLineDash([])
		ctx.beginPath()
		y = coordY(Pel)
		x = coordX(Tel,Pel) + 2
		ctx.moveTo(x,y)
		ctx.lineTo(x+15,y)
		ctx.fillText('EL', x+20, y+4);
		ctx.stroke()
	}
	
	if (document.getElementById("mcParcel").style.visibility == "visible" || document.getElementById("mcHail").style.visibility == "visible" || document.getElementById("mcTorn").style.visibility == "visible"){
		//Draw Parcel Origin Marker
		ctx.lineWidth = 1
		ctx.fillStyle = '#565656'
		ctx.strokeStyle = '#565656'
		ctx.font = "11px Arial";
		ctx.setLineDash([])
		ctx.beginPath()
		y = coordY(parP[0])
		x = coordX(parT[0],parP[0])
		if (parP[0]>atmP[1]){
			ctx.moveTo(x+2,y)
			ctx.lineTo(x+20,y-15)
			ctx.fillText('Parcel', x+23, y-22);
			ctx.fillText( Math.round(parP[0])+' mb', x+23, y-11);
		}else{
			ctx.moveTo(x+2,y)
			ctx.lineTo(x+18,y)
			ctx.fillText('Parcel', x+23, y-5);
			ctx.fillText( Math.round(parP[0])+' mb', x+23, y+6);
		}
		ctx.stroke()
	}
}

// Draw Parcel Energy Values in Skew-T Margin
function energyLevelsTbl(tsView){
	//Offset Rows to start at 425hPa
	x = 9
	//Populate Right Margin Table With CAPE CIN Values
	for (var r=0;r<39;r++){
		var rc=document.getElementById("rmarg").rows[r].cells
		if (r >= x && r <= atmEnDAT.length-1 + x){
			if(tsView==1){txtHTML = "<span onClick='dispParcel("+(atmEnDAT.length-1-r+x)+")'>"}else{txtHTML = "<span onClick='viewTSdisp()'>"}
			rc[0].innerHTML = txtHTML + atmEnDAT[atmEnDAT.length-1-r+x][5] + "</span>"
			fmtCell(rc[0],atmEnDAT[atmEnDAT.length-1-r+x][5],'cin')
			rc[0].style.fontWeight="normal"
			rc[0].style.fontSize="9px"
			rc[1].innerHTML = txtHTML+ atmEnDAT[atmEnDAT.length-1-r+x][4] + "</span>"
			fmtCell(rc[1],atmEnDAT[atmEnDAT.length-1-r+x][4],'cape')
			rc[1].style.fontWeight="normal"
			rc[1].style.fontSize="9px"
		}else{
			rc[0].innerHTML = "NULL"
			rc[0].style.color = "#2b3e50"
			rc[1].innerHTML = "NULL"
			rc[1].style.color = "#2b3e50"
		}
	}
	rc = document.getElementById("rmarg").rows[8].cells
	rc[0].innerHTML = "CIN"
	rc[0].style.color = "white"
	rc[1].innerHTML = "CAPE"
	rc[1].style.color = "white"
}

// Display Parcel Specific Info
function updraftInfo(){
	enDat = atmEnDAT[iPARCEL]
	
	//Parcel Table Caption
	parZ = Math.round(interpLvl("AGL",enDat[3],"P"))
	document.getElementById("tblparStat").caption.innerHTML = Math.round(enDat[3]) + "mb | " + parZ  +"m Parcel - Energy Specs"
	
	var x=document.getElementById("tblparStat").rows[1].cells
	eNCAPE = calcNCAPE(iPARCEL)

	//CIN
	x[0].innerHTML = enDat[5]
	fmtCell(x[0],enDat[5],'cin')
	//CAPE
	x[1].innerHTML = enDat[4]
	fmtCell(x[1],enDat[4],'cape')
	//NCAPE
	x[2].innerHTML = eNCAPE
	fmtCell(x[2],eNCAPE,'ncape')
	//LCL
	pLVL = enDat[2]
	zLVLm = interpLvl("AGL",pLVL,"P")
	zLVLft = conM2FT(zLVLm)
	x[3].innerHTML = addTTT(pLVL,Math.round(zLVLm) + ' m<br>' + Math.round(zLVLft)+ ' ft')
	
	if (isNaN(enDat[1]) || enDat[1]==null){
		x[4].innerHTML = ''
		x[5].innerHTML = ''
		x[6].innerHTML = ''
	}else{
		//LFC
		pLVL = enDat[1]
		zLVLm = interpLvl("AGL",pLVL,"P")
		zLVLft = conM2FT(zLVLm)
		x[4].innerHTML = addTTT(pLVL,Math.round(zLVLm) + ' m<br>' + Math.round(zLVLft)+ ' ft')
		//EL
		pLVL = enDat[0]
		zLVLm = interpLvl("AGL",pLVL,"P")
		zLVLft = conM2FT(zLVLm)
		x[5].innerHTML = addTTT(pLVL,Math.round(zLVLm) + ' m<br>' + Math.round(zLVLft)+ ' ft')
		//MPL
		pLVL = enDat[9]
		zLVLm = interpLvl("AGL",pLVL,"P")
		zLVLft = conM2FT(zLVLm)
		x[6].innerHTML = addTTT(pLVL,Math.round(zLVLm) + ' m<br>' + Math.round(zLVLft)+ ' ft')
	}
	
	var x=document.getElementById("tblparStat").rows[3].cells
	//BDPE - Bouyancy Dilution Potential
	x[0].innerHTML = addTTT(Math.round(enDat[12]),"&Ntilde;: " + Math.round(enDat[12]*100/enDat[4])/100)
		
	//ECAPE - Entrainment CAPE
	Etilde = calcETILDE(iPARCEL)
	x[1].innerHTML = Math.round(Etilde[0])
	fmtCell(x[1],Etilde[0],'cape')
	
	//Updraft Maximum
	wmax = Math.sqrt(2*Etilde[0])
	x[2].innerHTML = Math.round(wmax*10)/10
	
	//Fractional Entrainment Rate
	varepsilon = Etilde[1]*10000
	x[3].innerHTML = varepsilon.toFixed(2)
	
	//Updraft Radius 
	Ru = Etilde[2]
	x[4].innerHTML = Math.round(Ru)

}

function clrTSview(){
	document.getElementById("mcParcel").style.visibility = "hidden"
	refreshDisplay()
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Heavy Rain View 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function viewRAdisp(){
	document.getElementById("mcParcel").style.visibility = "hidden"
	document.getElementById("mcDCAPE").style.visibility = "hidden"
	document.getElementById("parDCAPE").style.visibility = "hidden"
	document.getElementById("mcEnergy").style.visibility = "visible"
	document.getElementById("mcHail").style.visibility = "hidden"
	document.getElementById("mcHailGraph").style.visibility = "hidden"
	document.getElementById("mcFZpro").style.visibility = "hidden"
	document.getElementById("mcMxTx").style.visibility = "hidden"
	document.getElementById("mcTorn").style.visibility = "hidden"
	document.getElementById("mcFog").style.visibility = "hidden"
	document.getElementById("mcTurb").style.visibility = "hidden"
	var calTbl = document.getElementById("mcRain").style
	calTbl.visibility = "visible"
	calTbl.top = 188
	calTbl.left = 585
}
	
// Calculate Corfidi Mean Cloud Layer Movement
function calcCloudLayerMove(){
	// Get pressure heights of cloud layer
	if (atmEnDAT[iMU][4]>100){
		// If there is non-trivial MU CAPE its pulled from Profile Energy Specs Table
		cBase = parseInt(document.getElementById("tblEnergy").rows[1].cells[4].innerHTML)
		cTop = parseInt(document.getElementById("tblEnergy").rows[1].cells[5].innerHTML)
	}else{
		// If CAPE is trivial it defaults to 850mb to 300mb
		cBase = 850
		cTop = 300
	}
	
	//Cloud Layer Flow (pressure weighted)
	Ptotal = 0
	//Total pressure within cloud layer
	for (var z=0;atmP[z]>=cTop;z++){
		if(atmP[z]<=cBase){Ptotal=Ptotal+atmP[z]}
	}
	
	uAvg = 0
	vAvg = 0
	// Calculate the average wind using pressure weighting
	for (var z=0;atmP[z]>=cTop;z++){
		if(atmP[z]<=cBase){
			uAvg = uAvg + (atmWND[z][0] * atmP[z]/Ptotal)
			vAvg = vAvg + (atmWND[z][1] * atmP[z]/Ptotal)
		}	
	}
	//Pressure Weighted Cloud Movement
	return [uAvg,vAvg]
}

// Calculate Low Level Jet
function findLLJet(){
	llJet = [0,0]
	maxSS = 0
	// Searches first 1,500m AGL for Maximum Winds
	for (var z=0;atmZ[z]<1500;z++){
		if (UVwndDisp(atmWND[z])[1]>maxSS){
			maxSS = UVwndDisp(atmWND[z])[1]
			llJet = atmWND[z]
		}
	}
	return llJet
}

// Calculate Corfidi Mesoscale Convective Systems' movement
function corfidi(){
	cldMov = calcCloudLayerMove()
	llJet = findLLJet()
	mcsBackward = [cldMov[0]-llJet[0],cldMov[1]-llJet[1]]
	mcsForward = [cldMov[0]+mcsBackward[0],cldMov[1]+mcsBackward[1]]
	return [mcsBackward,mcsForward]
}

function clrRainView(){
	document.getElementById("mcRain").style.visibility = "hidden"
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Hail & Tornado Views
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Initiates Tornado View 
function viewTorn(){
	document.getElementById("mcParcel").style.visibility = "hidden"
	document.getElementById("mcDCAPE").style.visibility = "hidden"
	document.getElementById("parDCAPE").style.visibility = "hidden"
	document.getElementById("mcEnergy").style.visibility = "hidden"
	document.getElementById("mcHail").style.visibility = "hidden"
	document.getElementById("mcHailGraph").style.visibility = "hidden"
	document.getElementById("mcFZpro").style.visibility = "hidden"
	document.getElementById("mcMxTx").style.visibility = "hidden"
	document.getElementById("mcRain").style.visibility = "hidden"
	document.getElementById("mcFog").style.visibility = "hidden"
	document.getElementById("mcTurb").style.visibility = "hidden"
	var calTbl = document.getElementById("mcTorn").style
	calTbl.visibility = "visible"
	calTbl.top = 33
	calTbl.left = 575
	iniTorn()
}

function iniTorn(){		
	dispParcel(0)
	energyLevelsTbl(0)
	dispTornUpdraft('ML')
	dispTornUpdraft('SFC')
	plotHeights()
	updateHodograph()
}

function viewHail(){		
	document.getElementById("mcParcel").style.visibility = "hidden"
	document.getElementById("mcDCAPE").style.visibility = "hidden"
	document.getElementById("parDCAPE").style.visibility = "hidden"
	document.getElementById("mcEnergy").style.visibility = "hidden"
	document.getElementById("mcHailGraph").style.visibility = "hidden"
	document.getElementById("mcFZpro").style.visibility = "hidden"
	document.getElementById("mcMxTx").style.visibility = "hidden"
	document.getElementById("mcRain").style.visibility = "hidden"
	document.getElementById("mcTorn").style.visibility = "hidden"
	document.getElementById("mcFog").style.visibility = "hidden"
	document.getElementById("mcTurb").style.visibility = "hidden"
	var calTbl = document.getElementById("mcHail").style
	calTbl.visibility = "visible"
	calTbl.top = 33
	calTbl.left = 548
	iniHail()
}

// Initiates Hail View 
function iniHail(){		
	dispParcel(0)
	energyLevelsTbl(0)
	plotHeights()
	dispHailSpecs()
	plotMPL()
	plotWBZ()
	plotFZLvl()
	plotHGZlapse()
	bgHailGraph()
	updateHodograph()
}

// Displays the Hail Embryo Residence Table of Hail Specs
function dispTornUpdraft(lvl){
	txtLvl = lvl  
	if (lvl=='SFC'){
		r=1
		lvl = 0
	}else{
		r=2
		lvl = atmEnDAT.length-1
		fcsc = document.getElementById("tblFCsc").rows[1].cells
		zLCL = interpLvl('AGL',atmEnDAT[lvl][2],'P')
		fcsc[4].innerHTML = Math.round(zLCL)
		fmtCell(fcsc[4],zLCL,'fclcl')
	}
	enDat = atmEnDAT[lvl]
	var x=document.getElementById("tblFCup").rows[r].cells
	
	//Parcel
	dispHtml = "<span onclick=dispParcel("+lvl+")>"+txtLvl+"</span>"
	x[0].innerHTML = addTTT(dispHtml,'Level: ' + enDat[3].toFixed(0) + 'mb')
	//CIN
	x[1].innerHTML = enDat[5]
	fmtCell(x[1],enDat[5],'cin')
	//CAPE w/ NCAPE mouseover
	eNCAPE = calcNCAPE(lvl)
	x[2].innerHTML = addTTT(enDat[4],'NCAPE<br>'+eNCAPE)
	fmtCell(x[2],enDat[4],'svrcape')
}

function dispHailSpecs(){
	dispHailEmbSpecs('SFC')
	dispHailEmbSpecs('MU')
	dispHailGrowthSpecs('SFC')
	dispHailGrowthSpecs('MU')
	//Older Format
	//fmtCell(document.getElementById("tblHail").rows[5].cells[3],avgRH,'grrh')
}

// Displays the Hail Embryo Residence Table of Hail Specs
function dispHailEmbSpecs(lvl){
	txtLvl = lvl  
	if (lvl=='SFC'){
		r=2
		lvl = 0
	}else{
		r=1
		lvl = iMU
	}
	enDat = atmEnDAT[lvl]
	dispHtml = "<span onclick=dispParcel("+lvl+")>"+txtLvl+"</span>"
	document.getElementById("tblGRemb").rows[r].cells[0].innerHTML = addTTT(dispHtml,'Level: ' + enDat[3].toFixed(0) + 'mb')
	
	if (enDat[1]==null){
		//No LFC 
		document.getElementById("tblGRemb").rows[r].cells[1].innerHTML = 'n/a'
		document.getElementById("tblGRemb").rows[r].cells[2].innerHTML = 'n/a' 
		document.getElementById("tblGRemb").rows[r].cells[3].innerHTML = 'n/a'
		document.getElementById("tblGRemb").rows[r].cells[4].innerHTML = 'n/a' 
		document.getElementById("tblGRemb").rows[r].cells[5].innerHTML = 'n/a' 
		for(x=1;x<6;x++){
			document.getElementById("tblGRemb").rows[r].cells[x].style.color="#898989"
			document.getElementById("tblGRemb").rows[r].cells[x].style.fontWeight="normal"
		}
	}else{
		//Thickness between LFC and Parcel Freezing Level
		zLFC = interpLvl("AGL",enDat[1],"P")
		zFZPL = interpLvl("AGL",enDat[8],"P") 
		wZ = zFZPL-zLFC
		document.getElementById("tblGRemb").rows[r].cells[3].innerHTML = addTTT(wZ.toFixed(0),'FzPL: ' + Math.round(zFZPL) + "m<br>LFC: " + Math.round(zLFC)+'m')
		fmtCell(document.getElementById("tblGRemb").rows[r].cells[3],wZ,'embwthk')
		
		//Below the freezing level or Warm Portion of the CAPE
		document.getElementById("tblGRemb").rows[r].cells[2].innerHTML = enDat[7].toFixed(0)
		fmtCell(document.getElementById("tblGRemb").rows[r].cells[2],enDat[7],'embwcape')
		
		//Relative Humidity in the Warm Portion of the CAPE *** looking for entrainment threhold via wCAPE vs RH 
		wRH = calcLyrAvgRH(zLFC-150,zFZPL+150)
		document.getElementById("tblGRemb").rows[r].cells[4].innerHTML = addTTT(wRH.toFixed(1),zLFC.toFixed(0)+'m<br>'+zFZPL.toFixed(0)+'m')
		ratioRH = Math.min((100 - (80 - wRH))/100,1)
		fmtCell(document.getElementById("tblGRemb").rows[r].cells[4],enDat[7]*ratioRH,'embwcape')
		
		//Storm relative flow of parcel layer
		stMo = getWndUV(document.getElementById("smF").value,document.getElementById("smM").value)
		lvlSRW = [atmWND[lvl][0]-stMo[0],atmWND[lvl][1]-stMo[1]]
		ratioSRF = enDat[7]*ratioRH * (Math.min(Math.max((UVwndDisp(lvlSRW)[1]/10),10),1))
		dispKnots(document.getElementById("tblGRemb").rows[r].cells[5],UVwndDisp(lvlSRW)[1],'srsfc')
		fmtCell(document.getElementById("tblGRemb").rows[r].cells[5],ratioSRF,'embwcape')
	}
}

// Displays the Hail Growth Table of Hail Specs
function dispHailGrowthSpecs(lvl){
	txtLvl = lvl
	if (lvl=='SFC'){
		r=2
		lvl = 0
	}else{
		r=1
		lvl = iMU
	}
	enDat = atmEnDAT[lvl]
	dispHtml = "<span onclick=dispParcel("+lvl+")>"+txtLvl+"</span>"
	document.getElementById("tblGRpot").rows[r].cells[0].innerHTML = addTTT(dispHtml,'Level: ' + enDat[3].toFixed(0) + 'mb')
	if (enDat[1]==null){
		//No LFC 
		document.getElementById("tblGRpot").rows[r].cells[1].innerHTML = 'n/a'
		document.getElementById("tblGRpot").rows[r].cells[2].innerHTML = 'n/a' 
		document.getElementById("tblGRpot").rows[r].cells[3].innerHTML = 'n/a'
		document.getElementById("tblGRpot").rows[r].cells[4].innerHTML = 'n/a' 
		document.getElementById("tblGRpot").rows[r].cells[5].innerHTML = 'n/a' 
		for(x=1;x<6;x++){
			document.getElementById("tblGRpot").rows[r].cells[x].style.color="#898989"
			document.getElementById("tblGRpot").rows[r].cells[x].style.fontWeight="normal"
		}
	}else{
		//Thickness or depth of the updraft
		zMPL = interpLvl("AGL",enDat[9],"P")
		zLFC = interpLvl("AGL",enDat[1],"P")
		zFZPL = Math.max(interpLvl("AGL",enDat[8],"P"),zLFC = interpLvl("AGL",enDat[1],"P"))
		zM30 = interpLvl("AGL",-30,"T")
		hailDepthZ = zMPL - zFZPL
		document.getElementById("tblGRpot").rows[r].cells[4].innerHTML = addTTT(hailDepthZ.toFixed(0),'MPL: ' + Math.round(zMPL) + 'm<br>FzPL: ' + Math.round(zFZPL)+'m')
		fmtCell(document.getElementById("tblGRpot").rows[r].cells[4],hailDepthZ,'grothk')
		
		//NCAPE Normalized CAPE
		ncape = calcNCAPE(lvl)
		//document.getElementById("tblGRpot").rows[r].cells[3].innerHTML = ncape.toFixed(2)
		//fmtCell(document.getElementById("tblGRpot").rows[r].cells[3],ncape,'ncape')
		
		//CAPE 
		document.getElementById("tblGRpot").rows[r].cells[3].innerHTML = addTTT(enDat[4].toFixed(0), "NCAPE<br>" + ncape.toFixed(2))
		fmtCell(document.getElementById("tblGRpot").rows[r].cells[3],enDat[4],'svrcape')
				
		//Relative Humidity entrainment into the updraft
		hgzRH = calcLyrAvgRH(zFZPL,zM30)
		document.getElementById("tblGRpot").rows[r].cells[5].innerHTML = hgzRH.toFixed(1)
		ratioRH = Math.min((100 - (85 - hgzRH))/100,1)
		fmtCell(document.getElementById("tblGRpot").rows[r].cells[5],enDat[4]*ratioRH,'svrcape')
	}
	
}

function bgHailGraph(){
	if(document.getElementById("grGraphEnv").checked){
		hailGraphEnv()
	}else if(document.getElementById("grGraphWcape").checked){
		hailGraphWcape()
	}else if(document.getElementById("grGraphSize").checked){
		hailGraphSize()
	}
}
function f13mplY(m){return 408-(0.0275*(m-5000))}
function f13fplY(m){return 408-(0.11*(m-1500))}

// Show and plot the Hail Size by Depth NIXON, 2023 Figure 16 
function hailGraphSize(){
	//Get Graph Inputs 
	cfpl = interpLvl("AGL",atmEnDAT[iMU][8],"P") 
	cmpl = interpLvl("AGL",atmEnDAT[iMU][9],"P")
	
	tblTxt = document.getElementById("tblGRpot").rows[1].cells[2].innerHTML.split('<span class="tooltiptext"><br>')[1].split(':')
	efpl = parseInt(tblTxt[2].split('m')[0])
	empl = parseInt(tblTxt[1].split('m')[0])
	
	document.getElementById("divtest").innerHTML = "cfpl: " + cfpl
	document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "<br>cmpl: " + cmpl
	document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "<br>efpl: " + efpl
	document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "<br>empl: " + empl
	
	var c = document.getElementById("grGraphCanvas");
	var ctx = c.getContext("2d");
	
	var bgImage = new Image();
	bgImage.src = "img/NixonHailF16.PNG"
	bgImage.onload = function(){
		ctx.drawImage(bgImage, 0, 0, c.width, c.height);
		
		//******   CAPE - Undiluted Updraft      *******
		//Y-Axis (MPL) Horizontal Line
		ctx.lineWidth = 1;
		ctx.setLineDash([2,2])
		ctx.strokeStyle = '#FF0000';
		ctx.fillStyle = '#FF0000';
		ctx.font = "bold 16px Arial";		
		if (cmpl > 18500){ctrCMPL = 18500}else if (cmpl < 5500){ctrCMPL = 5500}else{ctrCMPL = cmpl}
		CMPL1 = ctrCMPL+500
		CMPL2 = ctrCMPL-500
		ctx.beginPath();
		ctx.moveTo(50, f13mplY(ctrCMPL));
		ctx.lineTo(380, f13mplY(ctrCMPL));
		ctx.stroke();
		ctx.lineWidth = 3;
		ctx.setLineDash([0,0])
		ctx.beginPath();
		ctx.moveTo(55, f13mplY(CMPL1));
		ctx.lineTo(380, f13mplY(CMPL1));
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(55, f13mplY(CMPL2));
		ctx.lineTo(380, f13mplY(CMPL2));
		ctx.stroke();
		ctx.fillText((ctrCMPL/1000).toFixed(1),30, f13mplY(ctrCMPL)+5);
		
		//Y-Axis (FPL) Horizontal Line
		ctx.lineWidth = 1;
		ctx.setLineDash([2,2])
		ctx.strokeStyle = '#FF3535';
		ctx.fillStyle = '#FF3535';
		ctx.font = "bold 16px Arial";		
		if (cfpl > 4900){ctrCFPL = 4900}else if (cfpl < 1600){ctrCFPL = 1600}else{ctrCFPL = cfpl}
		CFPL1 = ctrCFPL+100
		CFPL2 = ctrCFPL-100
		ctx.beginPath();
		ctx.moveTo(390, f13fplY(ctrCFPL));
		ctx.lineTo(410, f13fplY(ctrCFPL));
		ctx.stroke();
		ctx.lineWidth = 3;
		ctx.setLineDash([0,0])
		ctx.beginPath();
		ctx.moveTo(390, f13fplY(CFPL1));
		ctx.lineTo(410, f13fplY(CFPL1));
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(390, f13fplY(CFPL2));
		ctx.lineTo(410, f13fplY(CFPL2));
		ctx.stroke();
		ctx.fillText((ctrCFPL/1000).toFixed(1),420, f13fplY(ctrCFPL)+5)
		ctx.fillText("CAPE",1, 12);
		
			if (cmpl>empl+200 && empl>0){
			
			//******   ECAPE - Entrainment      *******
			//Y-Axis (MPL) Horizontal Line
			ctx.lineWidth = 1;
			ctx.setLineDash([2,2])
			ctx.strokeStyle = '#FFA635';
			ctx.fillStyle = '#FFA635';
			ctx.font = "bold 16px Arial";		
			if (empl > 18500){ctrEMPL = 18500}else if (empl < 5500){ctrEMPL = 5500}else{ctrEMPL = empl}
			EMPL1 = ctrEMPL+500
			EMPL2 = ctrEMPL-500
			ctx.beginPath();
			ctx.moveTo(45, f13mplY(ctrEMPL));
			ctx.lineTo(380, f13mplY(ctrEMPL));
			ctx.stroke();
			ctx.lineWidth = 3;
			ctx.setLineDash([0,0])
			ctx.beginPath();
			ctx.moveTo(55, f13mplY(EMPL1));
			ctx.lineTo(380, f13mplY(EMPL1));
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(55, f13mplY(EMPL2));
			ctx.lineTo(380, f13mplY(EMPL2));
			ctx.stroke();
			ctx.fillStyle = '#C96619';
			ctx.fillText((ctrEMPL/1000).toFixed(1),20, f13mplY(ctrEMPL)+5);
			
			//Y-Axis (FPL) Horizontal Line
			ctx.lineWidth = 1;
			ctx.setLineDash([2,2])
			ctx.strokeStyle = '#FFA635';
			ctx.fillStyle = '#FFA635';
			ctx.font = "bold 16px Arial";		
			if (efpl > 4900){ctrEFPL = 4900}else if (efpl < 1600){ctrEFPL = 1600}else{ctrEFPL = efpl}
			EFPL1 = ctrEFPL+100
			EFPL2 = ctrEFPL-100
			ctx.beginPath();
			ctx.moveTo(405, f13fplY(ctrEFPL));
			ctx.lineTo(420, f13fplY(ctrEFPL));
			ctx.stroke();
			ctx.lineWidth = 3;
			ctx.setLineDash([0,0])
			ctx.beginPath();
			ctx.moveTo(405, f13fplY(EFPL1));
			ctx.lineTo(420, f13fplY(EFPL1));
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(405, f13fplY(EFPL2));
			ctx.lineTo(420, f13fplY(EFPL2));
			ctx.stroke();
			ctx.fillStyle = '#C96619';
			ctx.fillText((ctrEFPL/1000).toFixed(1),450, f13fplY(ctrEFPL)+5);
			ctx.fillText("ECAPE",1, 32);
		
			/*
			ctx.setLineDash([0,0]);
			ctx.beginPath();
			ctx.moveTo(55,23);
			ctx.lineTo(399,408);
			ctx.stroke();
		*/
		}
	}
}

function f13getX(srw){return (13.4*srw)+63}
function f13getY(bwd){return 395-(14.08*bwd)}
function f13capeY(cape){return 395-(0.64*(cape-150))}

// Show and plot the subHGZ CAPE vs 1km Kinematics NIXON, 2023 Figure 13 
function hailGraphWcape(){
	//Get Graph Inputs (w-MUCAPE; Shear 0-1km; Storm Relative Wind 0-1km)
	//BWD 0-1
	wnd1KM = interpLvl("WND",1000,"AGL")
	bwd = conKT2MS(calcLyrShear(atmWND[0],wnd1KM))
	//document.getElementById("divtest").innerHTML = "shr: " + bwd

	//SRW 0-1
	uAvg = 0
	vAvg = 0
	for (var z=0;atmZ[z]<1000;z++){
		uAvg = uAvg + atmWND[z][0]
		vAvg = vAvg + atmWND[z][1]
	}
	avgWnd = [(uAvg + wnd1KM[0])/(z+1),(vAvg + wnd1KM[1])/(z+1)]
	srWnd = [avgWnd[0]-STORMMOTION[0],avgWnd[1]-STORMMOTION[1]]
	srw = conKT2MS(UVwndDisp(srWnd)[1])
	//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "<br>srw: " + srw
	
	//subHGZ-CAPE
	wcape = atmEnDAT[iMU][7]
	//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "<br>wcape: " + wcape
	
	//Bound inputs to visible graph area
	if (srw > 23.5){ctrSRW = 23.5}else if (srw < 1.5){ctrSRW = 1.5}else{ctrSRW = srw}
	if (bwd > 23.5){ctrBWD = 23.5}else if (bwd < 1.5){ctrBWD = 1.5}else{ctrBWD = bwd}
		
	srw1 = ctrSRW-1.5
	srw2 = ctrSRW+1.5
	bwd1 = ctrBWD-1.5
	bwd2 = ctrBWD+1.5
	
	var c = document.getElementById("grGraphCanvas");
	var ctx = c.getContext("2d");
	
	var bgImage = new Image();
	bgImage.src = "img/NixonHailF13.PNG"
	bgImage.onload = function(){
		ctx.drawImage(bgImage, 0, 0, c.width, c.height);
		ctx.lineWidth = 4;
		ctx.strokeStyle = '#00DCFF';
		ctx.fillStyle = '#0061FF';
		ctx.font = "bold 16px Arial";	
		ctx.setLineDash([0,0]);
		//Bounding Box - With Buffer
		ctx.beginPath();
		ctx.moveTo(f13getX(srw1), f13getY(bwd1));
		ctx.lineTo(f13getX(srw1), f13getY(bwd2));
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(f13getX(srw2), f13getY(bwd1));
		ctx.lineTo(f13getX(srw2), f13getY(bwd2));
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(f13getX(srw1), f13getY(bwd1));
		ctx.lineTo(f13getX(srw2), f13getY(bwd1));
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(f13getX(srw1), f13getY(bwd2));
		ctx.lineTo(f13getX(srw2), f13getY(bwd2));
		ctx.stroke();
		ctx.beginPath();
		ctx.stroke();
		//X-Axis (SRW) Vertical Line
		ctx.setLineDash([2,2])
		ctx.beginPath();
		ctx.moveTo(f13getX(ctrSRW), f13getY(bwd1));
		ctx.lineTo(f13getX(ctrSRW), 395);
		ctx.stroke();
		//Y-Axis (BWD) Horizontal Line
		ctx.beginPath();
		ctx.moveTo(63, f13getY(ctrBWD));
		ctx.lineTo(f13getX(srw1), f13getY(ctrBWD));
		ctx.stroke();
		//Labels
		ctx.fillText(srw.toFixed(1), f13getX(srw)-11, 410);
		ctx.fillText(bwd.toFixed(1), 30, f13getY(bwd)+5);
		//ColorBar(CAPE) Horizontal Line
		ctx.fillStyle = '#9DB4DA';
		if (wcape > 725){ctrWCAPE = 725}else if (wcape < 125){ctrWCAPE = 125}else{
			ctx.fillStyle = '#0061FF';
			ctrWCAPE = wcape
		}
		ctx.beginPath();
		ctx.moveTo(385, f13capeY(ctrWCAPE));
		ctx.lineTo(425, f13capeY(ctrWCAPE));
		ctx.stroke();
		ctx.fillText(wcape, 428, f13capeY(ctrWCAPE)+5);
		/*
		ctx.beginPath();
		ctx.moveTo(63,43);
		ctx.lineTo(398,395);
		ctx.stroke();
		*/
	}

}

function f9getX(rh){return (3.92*rh)-49}
function f9getY(bwd){return 405-(7.54*bwd)}
function f9capeY(cape){return 405-(0.25*(cape-800))}

// Show and plot the Hail Parameter Environment Space NIXON, 2023 Figure 9 
function hailGraphEnv(){
	//Get Graph Inputs (BWD 0-6km; Avg RH 0-6km; MUCAPE)
	rh = calcLyrAvgRH(1000,6000)
	ebwdTXT = document.getElementById("tblShear").rows[1].cells[1].innerHTML.split('<span class="tooltiptext"><br>')
	cape = atmEnDAT[iMU][4]
	bwd = conKT2MS(parseInt(ebwdTXT[0].slice(21)))
	
	//Bound inputs to visible graph area
	if (rh > 97){ctrRH = 97}else if (rh < 28){ctrRH = 28}else{ctrRH = rh}
	if (bwd > 47){ctrBWD = 47}else if (bwd < 3){ctrBWD = 3}else{ctrBWD = bwd}
		
	rh1 = ctrRH-4
	rh2 = ctrRH+4
	bwd1 = ctrBWD-2
	bwd2 = ctrBWD+2
	
	var c = document.getElementById("grGraphCanvas");
	var ctx = c.getContext("2d");
	
	var bgImage = new Image();
	bgImage.src = "img/NixonHailF9.PNG"
	bgImage.onload = function(){
		ctx.drawImage(bgImage, 0, 0, c.width, c.height);
		ctx.lineWidth = 4;
		ctx.strokeStyle = '#00DCFF';
		ctx.fillStyle = '#0061FF';
		ctx.font = "bold 16px Arial";
		ctx.setLineDash([0,0])
		//Bounding Box - With Buffer
		ctx.beginPath();
		ctx.moveTo(f9getX(rh1), f9getY(bwd1));
		ctx.lineTo(f9getX(rh1), f9getY(bwd2));
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(f9getX(rh2), f9getY(bwd1));
		ctx.lineTo(f9getX(rh2), f9getY(bwd2));
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(f9getX(rh1), f9getY(bwd1));
		ctx.lineTo(f9getX(rh2), f9getY(bwd1));
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(f9getX(rh1), f9getY(bwd2));
		ctx.lineTo(f9getX(rh2), f9getY(bwd2));
		ctx.stroke();
		ctx.beginPath();
		ctx.stroke();
		//X-Axis (RH) Vertical Line
		ctx.setLineDash([2,2])
		ctx.beginPath();
		ctx.moveTo(f9getX(ctrRH), f9getY(bwd1));
		ctx.lineTo(f9getX(ctrRH), 405);
		ctx.stroke();
		//Y-Axis (BWD) Horizontal Line
		ctx.beginPath();
		ctx.moveTo(49, f9getY(ctrBWD));
		ctx.lineTo(f9getX(rh1), f9getY(ctrBWD));
		ctx.stroke();
		//Labels
		ctx.fillText(rh.toFixed(1), f9getX(rh)-11, 419);
		ctx.fillText(bwd.toFixed(1), 17, f9getY(bwd)+5);
		//ColorBar(CAPE) Horizontal Line
		ctx.fillStyle = '#9DB4DA';
		if (cape > 2300){ctrCAPE = 2300}else if (cape < 700){ctrCAPE = 700}else{
			ctx.fillStyle = '#0061FF';
			ctrCAPE = cape
		}
		ctx.beginPath();
		ctx.moveTo(385, f9capeY(ctrCAPE));
		ctx.lineTo(435, f9capeY(ctrCAPE));
		ctx.stroke();
		ctx.fillText(cape, 347, f9capeY(ctrCAPE)+5);
	}
}

function plotMPL(){
	if (atmEnDAT[0][9]!= null) {
		mplP = atmEnDAT[0][9]
		var c = document.getElementById("skewtCanvas");
		var ctx = c.getContext("2d");
		
		//Draw MPL Marker
		ctx.lineWidth = 1
		ctx.fillStyle = '#565656'
		ctx.strokeStyle = '#565656'
		ctx.font = "11px Arial";
		ctx.setLineDash([])
		ctx.beginPath()
		
		mplT = interpLvl("T",mplP,"P")
		y = coordY(mplP)
		x = coordX(mplT,mplP)
		ctx.moveTo(x,y)
		ctx.lineTo(x+15,y)
		ctx.fillText('MPL', x+25, y+5);
		ctx.stroke()
	}
}

// Calculate the average RH between layers of profile
function calcLyrAvgRH(Z1,Z2){	
	totRH = [0,0]
	i = 1
	if (Z1>Z2){
		botZ = Z2
		topZ = Z1
	}else{
		botZ = Z1
		topZ = Z2
	}
	if(botZ < 0){botZ=1}
	while (atmZ[i+1]<botZ){i++}
	for (var z=i;atmZ[z-1]<topZ;z++){
		totRH[0] = totRH[0] + atmRH[z]
		totRH[1] = totRH[1] + 1
	}
	return Math.round(10*totRH[0]/totRH[1])/10
}

// Mark Wet Bulb Zero on Skew-T
function plotHGZlapse(){
	if (atmT[0]>-10){
		var c = document.getElementById("skewtCanvas");
		var ctx = c.getContext("2d");
		
		//document.getElementById("divtest").innerHTML = "LR"
		
		x = 600
				
		hgtz10 = interpLvl("AGL",-10,"T")
		hgtz30 = interpLvl("AGL",-30,"T")
		p10 = interpLvl("P",-10,"T")
		p30 = interpLvl("P",-30,"T")
		
		yTop = coordY(p30)
		yBot = coordY(p10)
		yMid = (yTop+yBot)/2
		
		dz = hgtz30 - hgtz10
		gamma = Math.round(20*10000/dz)/10
		
		//document.getElementById("divtest").innerHTML = "CALC LR"
				
		document.getElementById("tblGRenv").rows[3].cells[3].innerHTML = gamma.toFixed(1)
		fmtCell(document.getElementById("tblGRenv").rows[3].cells[3],gamma,'lrhgz')
						
		ctx.lineWidth = 1
		ctx.fillStyle = '#470D0D'
		ctx.strokeStyle = '#470D0D'
		ctx.font = "12px Arial";
		ctx.setLineDash([])
		ctx.beginPath()
		ctx.moveTo(x-10,yTop)
		ctx.lineTo(x+10,yTop)
		ctx.stroke()
		
		ctx.beginPath()
		ctx.moveTo(x,yTop)
		ctx.lineTo(x,yMid - 15)
		ctx.stroke()
		
		ctx.fillText(gamma.toFixed(1) + ' C/Km', x-20, yMid+5);
		ctx.stroke()
		
		ctx.beginPath()
		ctx.moveTo(x,yMid + 15)
		ctx.lineTo(x,yBot)
		ctx.stroke()
		
		ctx.beginPath()
		ctx.moveTo(x-10,yBot)
		ctx.lineTo(x+10,yBot)
		ctx.stroke()
	}
}

// Mark Wet Bulb Zero on Skew-T
function plotWBZ(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	
	if (atmWB[0]>0) {
		hgtWBZm = interpLvl("AGL",0,"WB")
		hgtWBZft = Math.round(conM2FT(hgtWBZm))
		hgtWBZm = Math.round(hgtWBZm)
		pWBZ = interpLvl("P",0,"WB")
			
		ctx.lineWidth = 1
		ctx.fillStyle = '#5827FF'
		ctx.strokeStyle = '#5827FF'
		ctx.font = "12px Arial";
		ctx.setLineDash([])
		ctx.beginPath()
		y = coordY(pWBZ)
		x = coordX(0,pWBZ) + 1
		ctx.moveTo(x,y)
		ctx.lineTo(x-20,y)
		ctx.fillText('WBZ', x-49, y+4);
		//ctx.fillText(hgtWBZft+' ft', x-52, y+18);
		ctx.stroke()
	}else{
		hgtWBZ = 'bgl'
	}
	document.getElementById("tblGRenv").rows[3].cells[0].innerHTML = addTTT(hgtWBZm, hgtWBZft+' ft')

}

// Mark Freezing Level On Skew-T
function plotFZLvl(){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	
	if (atmT[0]>0) {
		hgtFZLm = interpLvl("AGL",0,"T")
		hgtFZLft = Math.round(conM2FT(hgtFZLm))
		hgtFZLm = Math.round(hgtFZLm)
		pFZL = interpLvl("P",0,"T")
			
		ctx.lineWidth = 1
		ctx.fillStyle = '#FF00DC'
		ctx.strokeStyle = '#FF00DC'
		ctx.font = "12px Arial";
		ctx.setLineDash([])
		ctx.beginPath()
		y = coordY(pFZL)
		x = coordX(0,pFZL) - 1
		ctx.moveTo(x,y)
		ctx.lineTo(x-20,y)
		ctx.fillText('FZ', x-38, y+4);
		//ctx.fillText(hgtFZLft+' ft', x+12, y+18);
		ctx.stroke()

	}else{
		hgtFZL = 'bgl'
	}
	document.getElementById("tblGRenv").rows[3].cells[1].innerHTML = addTTT(hgtFZLm, hgtFZLft+' ft')
	
}

function clrHailview(){
	document.getElementById("mcHail").style.visibility = "hidden"
	document.getElementById("mcHailGraph").style.visibility = "hidden"
	document.getElementById("mcEnergy").style.visibility = "visible"
	refreshDisplay()
}

function viewHailGraph(){
	graphNix = document.getElementById("mcHailGraph").style
	if (graphNix.visibility == "hidden"){
		graphNix.visibility = "visible"
		graphNix.top = 33
		graphNix.left = 67
		bgHailGraph()
	}else{
		graphNix.visibility = "hidden"
	}
}

function clrTornview(){
	document.getElementById("mcTorn").style.visibility = "hidden"
	document.getElementById("mcEnergy").style.visibility = "visible"
	refreshDisplay()
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Fog Forecating Tool
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Initiates Fog View 
function viewFog(){
	document.getElementById("mcParcel").style.visibility = "hidden"
	document.getElementById("mcDCAPE").style.visibility = "hidden"
	document.getElementById("parDCAPE").style.visibility = "hidden"
	document.getElementById("mcEnergy").style.visibility = "visible"
	document.getElementById("mcHail").style.visibility = "hidden"
	document.getElementById("mcHailGraph").style.visibility = "hidden"
	document.getElementById("mcFZpro").style.visibility = "hidden"
	document.getElementById("mcMxTx").style.visibility = "hidden"
	document.getElementById("mcRain").style.visibility = "hidden"
	document.getElementById("mcTorn").style.visibility = "hidden"
	document.getElementById("mcTurb").style.visibility = "hidden"
	var calTbl = document.getElementById("mcFog").style
	calTbl.visibility = "visible"
	calTbl.top = 200
	calTbl.left = 660
	iniFog()
}

//Initialize Table With Profile Data
function iniFog(){
	// Find the Lapse Rate Max and Min for the low levels.
	Tsfc = atmT[0]
	gammaMin = [99,0,0] //LapseRate,height,index
	gammaMax = [-99,0,0]
	for (var i=1;atmZ[i]<3000;i++){
		if (atmZ[i]>150){
			//SFC to Level Lapse Rate
			gammaLvl = (Tsfc - atmT[i])/(atmZ[i]/1000)
			//Previous level to current level Lapse Rate
			gammaSeg = (atmT[i-1] - atmT[i])/((atmZ[i]-atmZ[i-1])/1000)
			//If individual segment is still isothermal keep as stable layer
			if (gammaLvl<=gammaMin[0] || (gammaMin[2] == i-1 && gammaSeg < 1) ){gammaMin=[gammaLvl,atmZ[i],i]}
			//If individual segment is still unstable or Total Lapse Rate increases
			if (gammaLvl>=gammaMax[0] || (gammaMax[2] == i-1 && gammaSeg > 5) ){gammaMax=[gammaLvl,atmZ[i],i]}
		}
	}
	
	// Find the Average Relative Humidity for the Stable Layer.
	totRH = 0
	for (var i=0;atmZ[i]<=gammaMin[1];i++){
		totRH = totRH + atmRH[i]
	}
	rhINVavg = totRH/i
	
	// Find the Average Relative Humidity for the Advection Layer.
	totRH = 0
	for (var i=0;atmZ[i]<=gammaMax[1];i++){
		totRH = totRH + atmRH[i]
	}
	rhADVavg = totRH/i
	
	// Find Maximum Relative Humidity for the Mid Etage Cloud Layer.
	maxRHmid = [0,0,0,0] //RH,height,temp,dewpoint
	//document.getElementById("divtest").innerHTML = gammaMin[2]
	for (var i=gammaMin[2]+1;atmZ[i]<5500;i++){
		//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + '<br>' + i + ':' + maxRHmid
		if (atmRH[i]>maxRHmid[0]){maxRHmid=[atmRH[i],atmZ[i],atmT[i],atmDP[i]]} 
	}
	
	// Find Maximum Relative Humidity for the High Etage Cloud Layer.
	maxRHhi = [0,0,0,0] //RH,height,temp,dewpoint
	for (var i=i+1;i<atmZ.length;i++){
		if (atmRH[i]>maxRHhi[0]){maxRHhi=[atmRH[i],atmZ[i],atmT[i],atmDP[i]]} 
	}
	
	var x = document.getElementById("tblFGsfc")
	x.rows[1].cells[0].innerHTML = atmT[0]
	x.rows[1].cells[1].innerHTML = atmDP[0]
	x.rows[1].cells[2].innerHTML = atmRH[0]
	fmtCell(x.rows[1].cells[2],atmRH[0],'midrh')	
	
	sfcWND = UVwndDisp(atmWND[0])
	x.rows[1].cells[3].innerHTML = sfcWND[0] + '|' + sfcWND[1]
		
	var x = document.getElementById("tblFGcld")
	x.rows[1].cells[1].innerHTML = maxRHhi[1]
	txtft = Math.round(conM2FT(maxRHhi[1])) + ' Ft'
	x.rows[1].cells[1].innerHTML = addTTT(maxRHhi[1],txtft)
	x.rows[1].cells[2].innerHTML = maxRHhi[0]
	
	x.rows[2].cells[1].innerHTML = maxRHmid[1]
	txtft = Math.round(conM2FT(maxRHmid[1])) + ' Ft'
	x.rows[2].cells[1].innerHTML = addTTT(maxRHmid[1],txtft)
	x.rows[2].cells[2].innerHTML = maxRHmid[0]
	
	var x = document.getElementById("tblFGlyr")
	txtft = Math.round(conM2FT(gammaMin[1])) + ' Ft'
	x.rows[1].cells[1].innerHTML = addTTT(gammaMin[1],txtft)
	x.rows[1].cells[2].innerHTML = Math.round(gammaMin[0]*10)/10
	x.rows[1].cells[3].innerHTML = (Math.round(rhINVavg*10)/10).toFixed(1)
	
	txtft = Math.round(conM2FT(gammaMax[1])) + ' Ft'
	x.rows[2].cells[1].innerHTML = addTTT(gammaMax[1],txtft)
	x.rows[2].cells[2].innerHTML = Math.round(gammaMax[0]*10)/10
	x.rows[2].cells[3].innerHTML = (Math.round(rhADVavg*10)/10).toFixed(1)
	
	// Lapse Rate is stable enough to mark "Inversion"
	fmtCell(x.rows[1].cells[0],gammaMin[0],'invhead')
	fmtCell(x.rows[1].cells[1],gammaMin[0],'invhead')
	fmtCell(x.rows[1].cells[3],gammaMin[0],'invhead')
	if (gammaMin[0] < 4 ){
		fmtCell(x.rows[1].cells[2],gammaMin[0],'mxtxlr')
		fmtCell(x.rows[1].cells[3],rhINVavg,'midrh')
		markInvLevel(gammaMin,rhINVavg)
		// Mixing advection fog layer exists below stable layer
		if (gammaMin[1] > gammaMax[1]){
			fmtCell(x.rows[2].cells[0],gammaMin[0],'invhead')
			fmtCell(x.rows[2].cells[1],gammaMin[0],'invhead')
			fmtCell(x.rows[2].cells[2],gammaMax[0],'mxtxlr')
			fmtCell(x.rows[2].cells[3],rhADVavg,'midrh')
		}else{
			fmtCell(x.rows[2].cells[0],9,'invhead')
			fmtCell(x.rows[2].cells[1],9,'invhead')
			fmtCell(x.rows[2].cells[2],9,'invhead')
			fmtCell(x.rows[2].cells[3],9,'invhead')
		}
	}else{
		fmtCell(x.rows[1].cells[2],gammaMin[0],'invhead')
		fmtCell(x.rows[2].cells[2],gammaMin[0],'invhead')
	}
}

//Draw Temperature Markers and labels on Skew-T
function markInvLevel(gammaMin,rhINVavg){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	
	// Inversion Pointer 
	txt = "\u0393 min: " + Math.round(gammaMin[0]*10)/10
	ctx.lineWidth = 1;
	ctx.setLineDash([])	
	ctx.strokeStyle = '#0019D0';
	ctx.fillStyle = '#0019D0';
	ctx.font = "16px Arial";
	
	i = gammaMin[2]
	x1 = coordX(atmT[i],atmP[i])
	y1 = coordY(atmP[i])
	x2 = coordX(atmT[i],atmP[i]-70)
	y2 = coordY(atmP[i]-70)
	ctx.beginPath();
	ctx.moveTo(x1, y1);
	ctx.lineTo(x2, y2);
	ctx.fillText(txt, x2+2, y2);
	ctx.stroke();
	
	// Fog Layer RH Marker 
	ctx.lineWidth = 4;
	ctx.setLineDash([])	
	ctx.strokeStyle = '#00BC0B';
	ctx.fillStyle = '#00BC0B';
	ctx.font = "16px Arial";
	ctx.beginPath();
	ctx.moveTo(x2 - 10, y1-3);
	ctx.lineTo(x2 + 10, y1-3);
	ctx.stroke();
	y3 = coordY(atmP[0])
		
	ctx.beginPath();
	ctx.moveTo(x2 - 10, y3+3);
	ctx.lineTo(x2 + 10, y3+3);
	ctx.stroke();
	
	ctx.lineWidth = 2;
	ctx.beginPath();
	ctx.moveTo(x2, y1-3);
	ctx.lineTo(x2, y3+3);
	ctx.stroke();
	
	ctx.lineWidth = 1;
	ctx.beginPath();
	ctx.moveTo(x2, (y1+y3)/2);
	ctx.lineTo(x2+15, (y1+y3)/2);
	ctx.stroke();
	
	txt = Math.round(rhINVavg*10)/10
	ctx.fillStyle = '#007207';
	ctx.fillText('RH: ' + txt +'%', x2+20, ((y1+y3)/2)+6);
	
}

//Close Fog Table
function clrFogView(){
	document.getElementById("mcFog").style.visibility = "hidden"
	refreshDisplay()
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Freezing and Frozen Profile Precipitation Monitor
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Visualize Pop-up window - label for weather type
function viewFZpro(wxType){
	document.getElementById("mcParcel").style.visibility = "hidden"
	document.getElementById("mcDCAPE").style.visibility = "hidden"
	document.getElementById("parDCAPE").style.visibility = "hidden"
	document.getElementById("mcEnergy").style.visibility = "visible"
	document.getElementById("mcHail").style.visibility = "hidden"
	document.getElementById("mcHailGraph").style.visibility = "hidden"
	document.getElementById("mcMxTx").style.visibility = "hidden"
	document.getElementById("mcRain").style.visibility = "hidden"
	document.getElementById("mcTorn").style.visibility = "hidden"
	document.getElementById("mcFog").style.visibility = "hidden"
	document.getElementById("mcTurb").style.visibility = "hidden"
	var calTbl = document.getElementById("mcFZpro").style
	calTbl.visibility = "visible"
	calTbl.top = 300
	calTbl.left = 705
	document.getElementById("tblFZpro").caption.innerHTML = wxType	
	refreshDisplay()
}

//Initialize Table With Profile Data
function iniFZpro(){
	hts = [20000,17000,14000,11000,9000,7000,5000,4000,3000,2500,2000,1500,1000,500,0]
	temps = []
	dews = []
	rhs = []
	ps = []
	for (var i=0;i<hts.length-1;i++){
		temps.push(interpLvl('T',conFT2M(hts[i]),'AGL'))
		dews.push(interpLvl('DP',conFT2M(hts[i]),'AGL'))
		rhs.push(interpLvl('RH',conFT2M(hts[i]),'AGL'))
		ps.push(interpLvl('P',conFT2M(hts[i]),'AGL'))
	}
	temps.push(atmT[0])
	dews.push(atmDP[0])
	rhs.push(atmRH[0])
	ps.push(atmP[0])
	fzProDat = [temps,dews,rhs,ps,hts]
	
	if (document.getElementById("tblFZpro").caption.innerHTML=="Freezing Drizzle"){
		writeFZDZtbl(fzProDat)
	}else if(document.getElementById("tblFZpro").caption.innerHTML=="Freezing Rain"){
		writeFZRAtbl(fzProDat)
	}else if(document.getElementById("tblFZpro").caption.innerHTML=="Snow"){
		writeSNtbl(fzProDat)
	}
	writeAccum()
	drawMarkers(fzProDat)	
}

//Populate table with freezing drizzle color formatting
function writeAccum(){
	document.getElementById("slrV").innerHTML = getMySLR().toFixed(1)
	document.getElementById("slrA").innerHTML = getAFMANslr().toFixed(1)
	document.getElementById("slrK").innerHTML = getEKMslr().toFixed(1)
	updateSNtot()
	calcGASP(calcPWI())
}

//Populate table with freezing drizzle color formatting
function writeFZDZtbl(fzProDat){
	for (var r=0;r<15;r++){
		for (var c=0;c<3;c++){
			var x=document.getElementById("tblFZpro").rows[r+1].cells
			x[c+1].innerHTML = fzProDat[c][r].toFixed(1)
			if(c==2){fmtCell(x[c+1],fzProDat[c][r], 'midrh')}
			if(c==0){
				if (fzProDat[2][r]>=87){
					fmtCell(x[c+1],fzProDat[0][r], 'fzdzt')
				}else{
					fmtCell(x[c+1],fzProDat[2][r], 'cldRH')
				}
			}
		}
	}
}

//Populate table with SLR snow to liquid ratio formatting
function writeSNtbl(fzProDat){
	for (var r=0;r<15;r++){
		for (var c=0;c<3;c++){
			var x=document.getElementById("tblFZpro").rows[r+1].cells
			x[c+1].innerHTML = fzProDat[c][r].toFixed(1)
			if(c==2){fmtCell(x[c+1],fzProDat[c][r], 'midrh')}
			if(c==0){
				if (fzProDat[2][r]>=87){
					fmtCell(x[c+1],fzProDat[0][r], 'snt')
				}else{
					fmtCell(x[c+1],fzProDat[2][r], 'cldRH')
				}
			}
		}
	}
}

//Populate table with Freezing Rain color formatting
function writeFZRAtbl(fzProDat){
	for (var r=0;r<15;r++){
		for (var c=0;c<3;c++){
			var x=document.getElementById("tblFZpro").rows[r+1].cells
			x[c+1].innerHTML = fzProDat[c][r].toFixed(1)
			if(c==0){fmtCell(x[c+1],fzProDat[0][r],'fzrat')}	
			if(c==2){fmtCell(x[c+1],fzProDat[c][r], 'midrh')}
		}
	}
}

//Draw Temperature Markers and labels on Skew-T
function drawMarkers(fzProDat){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	ctx.lineWidth = 1;
	ctx.strokeStyle = 'black';
	ctx.fillStyle = 'black';
	ctx.font = "10px Arial";
	ctx.setLineDash([])	
	for (var i=0;i<fzProDat[4].length;i++){
		if (i==9 || i==11 || i==13){continue}
		x = coordX(fzProDat[0][i],fzProDat[3][i])
		y = coordY(fzProDat[3][i])
		ctx.beginPath();
		ctx.rect(x,y,2,2)
		ctx.fillText(dispFL(fzProDat[4][i]), x+4, y+4);
		ctx.stroke();
	}
}

//Close profile table
function clrFZDZ(){
	document.getElementById("mcFZpro").style.visibility = "hidden"
	refreshDisplay()
}

//Get GASP - Guerrero Apocalyptic Snowfall Procedure 
function calcGASP(pwiMM){
	pwi = conMM2IN(pwiMM)
	slr = parseFloat(document.getElementById("slrA").innerHTML)
	snowfall = Math.round(slr*pwi*10)/10
	document.getElementById("tblAccum").rows[0].cells[2].innerHTML = addTTT("Tot", "GASP<br>" + snowfall.toFixed(1)+'"')
}

//The AFMAN 15-111 Table Ref SLR to Surface Temp Ratio
function getAFMANslr(){
	Tsfc = atmT[0]
	slr = 0
	if (Tsfc!='M'){
		if(Tsfc <= 1 && Tsfc >=-2){slr=10}
		if(Tsfc < -2 && Tsfc >=-7){slr=15}
		if(Tsfc < -7 && Tsfc >=-9){slr=20}
		if(Tsfc < -9 && Tsfc >=-12){slr=30}
		if(Tsfc < -12 && Tsfc >=-18){slr=40}
		if(Tsfc < -18 && Tsfc >=-29){slr=50}
		if(Tsfc < -29 && Tsfc >=-40){slr=100}
	}
	return Math.round(slr*10)/10
}

//The Kuchera Method using the max temp (C) in profile below 500mb
function getEKMslr(){
	Tmax = atmT[0]
	for (var z=1;atmP[z]>500;z++){if (atmT[z]>Tmax){Tmax=atmT[z]}}
	slr = 0
	Tmax = Tmax + 273.15
	if (Tmax > 271.16){
		slr = 12 + 2 * (271.16-Tmax)
		if (slr<0){slr=0}
	}else{
		slr = 12 + 271.16 - Tmax
	}
	return Math.round(slr*10)/10
}

//My top down profile ratio method
function getMySLR(){
	lyrs = [20000,17000,14000,11000,9000,7000,5000,4000,3000,2500,2000,1500,1000,500,0]
	slr = 0
	for (var i=0;i<lyrs.length;i++){
		temp = interpLvl("T",conFT2M(lyrs[i]),"AGL")
		dewpt = interpLvl("DP",conFT2M(lyrs[i]),"AGL")
		rh = 100 * ES(dewpt)/ES(temp)
		//Saturated/clouds layers apply a ratio and weight based on temps
		if ( (rh>89 && temp> -5) || (rh>87 && temp> -10) || (rh>85 && temp> -15) || (rh>82 && temp> -20) || (rh>80 && temp> -25)){
			if (temp < -22){mxLyr = [10,1]
			}else if(temp < -20 && temp >= -22){mxLyr = [15,0.6]
			}else if(temp < -18 && temp >= -20){mxLyr = [22,0.6]
			}else if(temp < -16 && temp >= -18){mxLyr = [34,0.6]
			}else if(temp < -14 && temp >= -16){mxLyr = [48,0.6]
			}else if(temp < -12 && temp >= -14){mxLyr = [35,0.8]
			}else if(temp < -10 && temp >= -12){mxLyr = [31,1]
			}else if(temp < -8 && temp >= -10){mxLyr = [21,1]
			}else if(temp < -6 && temp >= -8){mxLyr = [16,1.3]
			}else if(temp < -4 && temp >= -6){mxLyr = [11,1.3]
			}else if(temp < -2 && temp >= -4){mxLyr = [9,1.6]
			}else if(temp < -1 && temp >= -2){mxLyr = [7.5,1.6]
			}else if(temp < 0 && temp >= -1){mxLyr = [5.5,2]
			}else if(temp < 1 && temp >= 0){mxLyr = [3,3]
			}else if(temp >= 1){mxLyr = [1,4]}
			
			//Set Initial SLR
			if (slr==0){
				slr = mxLyr[0]
			//Wt SLR Lower once low Ratio is established	
			}else if (slr < mxLyr[0]){
				wt = scoreParam(slr, -5, -15, -25, -35, -45, -1)*0.9
                slr = ((slr*wt) + (mxLyr[0]*mxLyr[1]))/(mxLyr[1]+wt) 
			//Re-calculates ratio of falling precip dropping into lower layer
			}else{
				slr = (slr + (mxLyr[0]*mxLyr[1]))/(mxLyr[1]+1)
			}
			
		//Accounts for melting w/o saturation based on temps only
		}else{
			if (slr > 1 && temp > 0){
				slr = slr * (0.90-(scoreParam(temp, 5, 4, 3, 2, 1, 1)*0.15))
			}	
		}
	}
	return Math.round(slr*10)/10
}

// Calculate Snowfall total from SLR and Liquid Equivilant Input
function updateSNtot(){
	precip = parseFloat(document.getElementById("manLiqPrecip").value)
	if (isNaN(precip)){precip = 0}
	
	slr = parseFloat(document.getElementById("slrV").innerHTML)
	snowfall = Math.round(slr*precip*10)/10
	document.getElementById("snV").innerHTML = snowfall.toFixed(1)+'"'
	
	slr = parseFloat(document.getElementById("slrA").innerHTML)
	snowfall = Math.round(slr*precip*10)/10
	document.getElementById("snA").innerHTML = snowfall.toFixed(1)+'"'
	
	slr = parseFloat(document.getElementById("slrK").innerHTML)
	snowfall = Math.round(slr*precip*10)/10
	document.getElementById("snK").innerHTML = snowfall.toFixed(1)+'"'
}

function scoreParam(param, hi, midhi, mid, midlo, lo, neg){ 
    param = param * neg
    if (param >= hi){
        val=5.0
    }else if (param < hi && param >= midhi){
        val=4.0
    }else if (param < midhi && param >= mid){
    	val=3.0
    }else if (param < mid && param >= midlo){
    	val=2.0
    }else if (param < midlo && param >= lo){
        val=1.0
    }else{
        val=0.0
	}
    return val
}	

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Momentum Transfer Mini Calculator for Non-Convective Winds
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Initialize Table With Profile Data
function iniMxTx(){
	temp = [interpLvl('T',2743,'AGL'),interpLvl('T',2134,'AGL'),interpLvl('T',1524,'AGL'),interpLvl('T',1219.2,'AGL'),interpLvl('T',914.4,'AGL'),interpLvl('T',609.6,'AGL'),interpLvl('T',304.8,'AGL'),interpLvl('T',152.4,'AGL'),atmT[0]]
	gamma = calcLapseRate(temp)
	wndUV = [interpLvl('WND',2743,'AGL'),interpLvl('WND',2134,'AGL'),interpLvl('WND',1524,'AGL'),interpLvl('WND',1219.2,'AGL'),interpLvl('WND',914.4,'AGL'),interpLvl('WND',609.6,'AGL'),interpLvl('WND',304.8,'AGL'),interpLvl('WND',152.4,'AGL'),atmWND[0]]	//Speed 5kft to 5hft
	mixwnd =[1,1,1,1,1,0.33]//0-MxTx,1-mixBMW,2-MaxBMW,3-mixFTW,4-maxFTW,5-%Force
	ps = [interpLvl('P',2743,'AGL'),interpLvl('P',2134,'AGL'),interpLvl('P',1524,'AGL'),interpLvl('P',1219.2,'AGL'),interpLvl('P',914.4,'AGL'),interpLvl('P',609.6,'AGL'),interpLvl('P',304.8,'AGL'),interpLvl('P',152.4,'AGL'),atmP[0]]
	btw = [[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]]
	mxtxDat = [temp,gamma,wndUV,mixwnd,ps,btw]
	calcMxTx(mxtxDat)
}

//Visualize Pop-up window
function viewMxTx(){
	document.getElementById("mcParcel").style.visibility = "hidden"
	document.getElementById("mcDCAPE").style.visibility = "hidden"
	document.getElementById("parDCAPE").style.visibility = "hidden"
	document.getElementById("mcEnergy").style.visibility = "visible"
	document.getElementById("mcHail").style.visibility = "hidden"
	document.getElementById("mcHailGraph").style.visibility = "hidden"
	document.getElementById("mcFZpro").style.visibility = "hidden"
	document.getElementById("mcRain").style.visibility = "hidden"
	document.getElementById("mcTorn").style.visibility = "hidden"
	document.getElementById("mcFog").style.visibility = "hidden"
	document.getElementById("mcTurb").style.visibility = "hidden"
	var calTbl = document.getElementById("mcMxTx").style
	calTbl.visibility = "visible"
	calTbl.top = 33
	calTbl.left = 67 
	iniMxTx()
}

//Calculates Lapse Rates from MxTx Levels to the surface
function calcLapseRate(temps){
	hts = [2.743,2.134,1.524,1.219,0.914,0.6096,0.3048,0.1524]
	gamma = [0,0,0,0,0,0,0,0,0,'-00.0']
	for (var r=7;r>-1;r--){gamma[r] = (temps[8]-temps[r])/hts[r]}
	return gamma
}

//Calculates average using weight factor (function of height) to return each level's mixBTW/mixFTW
function calcMixAVG(vals,mixWT,wtTot){
	avgVal = 0
	for(var i=0;i<vals.length;i++){
		avgVal = avgVal + vals[vals.length-1-i]*(mixWT[7-i]/wtTot)
	}
	return avgVal
} 

//Writes the table from data array
function writeMxTxTbl(mxtxDat){
	for (var r=0;r<9;r++){
		var x=document.getElementById("tblMxTx").rows[r+1].cells
		for (var c=0;c<4;c++){
			if (c==0){
				document.getElementById("manT"+(r+1)).value = parseFloat(mxtxDat[c][r]).toFixed(1)
			}else if (c==1){
				x[c+1].innerHTML = mxtxDat[c][r].toFixed(1)
				if (r==8){x[c+1].innerHTML ='-00.0'}
				fmtCell(x[c+1], mxtxDat[c][r], 'mxtxlr')
			}else if (c==2){
				wind = UVwndDisp(mxtxDat[c][r])
				document.getElementById("manD"+(r+1)).value = wind[0]
				document.getElementById("manS"+(r+1)).value = wind[1]
			}else if (c==3){
				if (r!=8){x[5].innerHTML = Math.round(getWndMag(mxtxDat[5][r][0],mxtxDat[5][r][1]))}
			}
		}	
	}
	//0-MxTx,1-mixBMW,2-MaxBMW,3-mixFTW,4-maxFTW,5-%Force
	document.getElementById("dispMxTx").rows[0].cells[1].innerHTML = mxtxDat[3][2]
	document.getElementById("dispMxTx").rows[0].cells[3].innerHTML = mxtxDat[3][4]
	document.getElementById("dispMxTx").rows[1].cells[1].innerHTML = mxtxDat[3][1]
	document.getElementById("dispMxTx").rows[1].cells[3].innerHTML = mxtxDat[3][3]
	document.getElementById("dispMxTx").rows[3].cells[0].innerHTML = mxtxDat[3][0]
	document.getElementById("manDF").value = Math.round(mxtxDat[3][5]*100)
	drawMxTx(mxtxDat)
 }

//Draws Temperature Markers and lables of editable lapse rate
function drawMxTx(mxtxDat){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	
	dispLvl=['090','070','050','040','030','020','010','005','SFC']
	ctx.lineWidth = 1;
	//ctx.strokeStyle = '#BC37FF';
	ctx.strokeStyle = 'black';
	ctx.fillStyle = 'black';
	ctx.font = "10px Arial";
	ctx.setLineDash([1,1])
	x1 = coordX(mxtxDat[0][0],mxtxDat[4][0])
	y1 = coordY(mxtxDat[4][0])
	ctx.beginPath();
	ctx.moveTo(x1,y1);	
	ctx.rect(x1,y1,2,2)
	ctx.fillText(dispLvl[0], x1+4, y1+4)
	
	for (var i=1;i<dispLvl.length;i++){
		x2 = coordX(mxtxDat[0][i],mxtxDat[4][i])
		y2 = coordY(mxtxDat[4][i])
		ctx.lineTo(x2,y2);
		ctx.rect(x2,y2,2,2)
		ctx.fillText(dispLvl[i], x2+4, y2+4)
	}
	ctx.stroke();
}

//Calculates Momentum Transfer Values & sends to display
function calcMxTx(mxtxDat){
	//Calculate the Best Transferred Winds (BTW) and Full Transfer Winds (FTW)
	//mixWT=[92,95,98,102,105,108] //Weight % of each level's mixing potential
	mixWT=[22,33,40,43,45,45,47,52] //Empirical weighting based on height AGL
	wtTot = 0
	BTallU = []
	BTallV = []
	ssMaxBTW = 0
	ssMixBTW = 0
	FTallU = []
	FTallV = []
	ssMaxFTW = 0
	ssMixFTW = 0
	
	for (var r=7;r>-1;r--){
		//Edit layer weight: mitigate weight with superadiabatic conditions
		if (mxtxDat[1][r] > 6.5){
			mixWT[r] = Math.max(mixWT[r] - (mxtxDat[1][r] - 9.8),1)
		}
		wtTot = wtTot + mixWT[r]

		//Calculate layer Best Transferred Wind: windspeed x (ratio of lapse rate vs DALR)
		if (mxtxDat[1][r]>=9.8){
			lyrUV = mxtxDat[2][r]
		}else if (mxtxDat[1][r]<=0){
			lyrUV = [0,0]
		}else{
			stabRatio = mxtxDat[1][r]/9.8
			lyrUV = [mxtxDat[2][r][0]*stabRatio,mxtxDat[2][r][1]*stabRatio]
		}
		mxtxDat[5][r] = lyrUV
		
		//Track BTW Maximum wind in column
		lyrSS = getWndMag(lyrUV[0],lyrUV[1])
		if (lyrSS > ssMaxBTW){ssMaxBTW = lyrSS}
		//Store each level's BTW for average 
		BTallU.push(lyrUV[0])
		BTallV.push(lyrUV[1])
		//The weighted avgerage gets recomputed as new layers are incorporated - Mixing occurs from the surface going up
		avgU = calcMixAVG(BTallU,mixWT,wtTot)
		avgV = calcMixAVG(BTallV,mixWT,wtTot)
		avgSS = getWndMag(avgU,avgV)
		//The maximum of weighted averages is tracked and stored
		if (avgSS > ssMixBTW){ssMixBTW = avgSS}
		
		//Calculate Full Transfer Wind: speed not ratio'd by stability
		FTWlyrUV = mxtxDat[2][r]
		//Track FTW Maximum wind in column  
		lvlWndSp = getWndMag(FTWlyrUV[0],FTWlyrUV[1])
		if (lvlWndSp > ssMaxFTW){ssMaxFTW = lvlWndSp}
		//Store each level's FTW for average
		FTallU.push(FTWlyrUV[0])
		FTallV.push(FTWlyrUV[1])
		//The weighted avgerage gets recomputed as new layers are incorporated - Mixing occurs from the surface going up
		FTWavgU = calcMixAVG(FTallU,mixWT,wtTot)
		FTWavgV = calcMixAVG(FTallV,mixWT,wtTot)
		FTWavgSS = getWndMag(FTWavgU,FTWavgV)
		//The maximum of weighted averages is tracked and stored
		if (FTWavgSS > ssMixFTW){ssMixFTW = FTWavgSS}
	}
	
	//0-MxTx,1-mixBMW,2-MaxBMW,3-mixFTW,4-maxFTW,5-%Force
	mxtxDat[3][1] = Math.round(ssMixBTW)
	mxtxDat[3][2] = Math.round(ssMaxBTW)
	mxtxDat[3][3] = Math.round(ssMixFTW)
	mxtxDat[3][4] = Math.round(ssMaxFTW)
	estGust = Math.round(ssMixBTW + (mxtxDat[3][5] * (ssMaxBTW-ssMixBTW)))
	//Stable with high speed winds at 500ft
	ss500 = getWndMag(mxtxDat[2][7][0],mxtxDat[2][7][1])
	estLLWS = Math.round((ss500*0.6) + (mxtxDat[3][5]*((ss500*0.8)-(ss500*0.6))))
	if (estGust>estLLWS){mxtxDat[3][0] = estGust}else{mxtxDat[3][0] = estLLWS}
	writeMxTxTbl(mxtxDat)
}

function readMxTxTbl(){
	mxtxDat[[0,0,0,0,0,0,0],[0,0,0,0,0,0,'-00.0'],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]]
	for (var r=0;r<9;r++){
		for (var c=0;c<3;c++){
			var x=document.getElementById("tblMxTx").rows[r+1].cells
			if (c==0){
				mxtxDat[c][r] = parseFloat(document.getElementById("manT"+(r+1)).value)
			}else if (c==2){
				ddd = parseInt(document.getElementById("manD"+(r+1)).value)
				ss = parseInt(document.getElementById("manS"+(r+1)).value)
				mxtxDat[c][r] = getWndUV(ddd,ss)
			}
		}	
	}
	mxtxDat[3][5] = parseInt(document.getElementById("manDF").value)/100
	mxtxDat[1] = calcLapseRate(mxtxDat[0])
	return mxtxDat
}

//Pulling Editied data, recalculate parameters mixing BTW into lower layer
function mixDown(){
	mxtxDat = readMxTxTbl()
	//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + '<br>' + mxtxDat[0] + '<br>' + mxtxDat[1] + '<br>' + mxtxDat[2] + '<br>' + mxtxDat[3] + '<br>' + mxtxDat[4] + '<br>' + mxtxDat[5]
	//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + mxtxDat[2] + '<br>'
	for (var r=0;r<7;r++){
		//Calculate layer Best Transferred Wind: windspeed x (ratio of lapse rate vs DALR)
		if (mxtxDat[1][r]>=9.8){
			btwUV = mxtxDat[2][r]
		}else if (mxtxDat[1][r]<=0){
			btwUV = [0,0]
		}else{
			stabRatio = mxtxDat[1][r]/9.8
			btwUV = [mxtxDat[2][r][0]*stabRatio,mxtxDat[2][r][1]*stabRatio]
		}
		btwSS = getWndMag(btwUV[0],btwUV[1])
		lyrSS = getWndMag(mxtxDat[2][r+1][0],mxtxDat[2][r+1][1])
		//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + btwSS + ' > ' + lyrSS + '<br>'
		if (btwSS > lyrSS){
			mxtxDat[2][r+1] = [(btwUV[0] + mxtxDat[2][r+1][0])/2,(btwUV[1] + mxtxDat[2][r+1][1])/2]
		}
	}
	basicPlot()
	//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + mxtxDat[2] + '<br>'
	calcMxTx(mxtxDat)
	
 }

//Pulling Editied data, recalculate parameters, and display new table
function updateMxTxTbl(){
	mxtxDat = readMxTxTbl()
	basicPlot()
	calcMxTx(mxtxDat)
 }
 
//Close wind table calculator
function clrMxTx(){
	document.getElementById("mcMxTx").style.visibility = "hidden"
	dispParcel(0)
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DCAPE Mini Calculator for Convective Winds
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Initialize the DCAPE Calculator
function iniDCAPE(){
	iniPrR = 6
	mxZ = getLvlMUDCAPE()
	dispDParcel(mxZ)
	dcapeLevelsTbl()
}

//MUDCAPE - Find Level of "Most Unstable" DCAPE or DCAPE Maximum in profile
function getLvlMUDCAPE(){
	mxCape = 0 
	mxZ = 0
	for (var z=0;z<atmDCAPE.length;z++){
		if (atmDCAPE[z][1]>mxCape){
			mxCape = atmDCAPE[z][1]
			mxZ = z
		}
	}
	return mxZ
}

//Close DCAPE Parcel Auxilary
function closeDPAR(){
	document.getElementById("parDCAPE").style.visibility = "hidden"
	dbzDCAPE(6)
} 

// Visualize DCAPE pop-up
function viewDCAPE(){
	document.getElementById("mcParcel").style.visibility = "hidden"
	document.getElementById("mcEnergy").style.visibility = "hidden"
	document.getElementById("mcHail").style.visibility = "hidden"
	document.getElementById("mcHailGraph").style.visibility = "hidden"
	document.getElementById("mcFZpro").style.visibility = "hidden"
	document.getElementById("mcMxTx").style.visibility = "hidden"
	document.getElementById("mcRain").style.visibility = "hidden"
	document.getElementById("mcTorn").style.visibility = "hidden"
	document.getElementById("mcFog").style.visibility = "hidden"
	document.getElementById("mcTurb").style.visibility = "hidden"
	var calTbl = document.getElementById("mcDCAPE").style
	calTbl.visibility = "visible"
	calTbl.top = 34
	calTbl.left = 535
	var calTbl = document.getElementById("parDCAPE").style
	calTbl.visibility = "visible"
	calTbl.top = 34
	calTbl.left = 128
	iniDCAPE()
}

//Display the Downdraft Energy Area and activate Calculator
function dispDParcel(lvl){
	iDPAR = lvl
	dcapeDat = atmDCAPE[iDPAR]
	setDCAPEcalc(dcapeDat,iDPAR)
	dbzDCAPE(iniPrR)
}

//Calculate Storm Relative Winds of LFS - Level of Free Sink
function calcLfsSrw(){
	lvl = parseInt(document.getElementById("tblDCAPElvl").innerHTML)
	stMo = getWndUV(document.getElementById("smF").value,document.getElementById("smM").value)
	lfsSRW = [atmWND[lvl][0]-stMo[0],atmWND[lvl][1]-stMo[1]]
	dispSRW = UVwndDisp(lfsSRW)
	document.getElementById("tblLFS").rows[1].cells[2].innerHTML = dispSRW[0] + '|' + dispSRW[1]
	
	//Pull inflow from table & remove HTML markings
	inflowTXT = document.getElementById("tblSRFlo").rows[0].cells[1].innerHTML.split('<span class="tooltiptext"><br>')
	inflow = parseInt(inflowTXT[0].slice(21))
	congestion = Math.round(100*inflow/parseInt(dispSRW[1]))/100
	document.getElementById("tblLFS").rows[1].cells[3].innerHTML = congestion
}

//Estimate the Convective Environment and Highlight Table with mouseovers
function calcMicroburstEnv(){
	lvl = parseInt(document.getElementById("tblDCAPElvl").innerHTML)

	WBdep1 = atmT[lvl]-atmWB[lvl]
	WBdep2 = atmT[lvl+1]-atmWB[lvl+1]
	WBdep3 = atmT[lvl-1]-atmWB[lvl-1]
	LFSwbDep = (WBdep1+WBdep2+WBdep3)/3
	LFSrh = atmRH[lvl]
	
	WBdep1 = atmT[0]-atmWB[0]
	WBdep2 = atmT[1]-atmWB[1]
	WBdep3 = atmT[2]-atmWB[2]
	SFCwbDep = (WBdep1+WBdep2+WBdep3)/3
	SFCrh = atmRH[0]
	tblCalcHead = document.getElementById("tblCutDRWind").rows[0]
	ovlyText = "LFS RH: " + LFSrh.toFixed(1) +"%<br>SFC RH: " + SFCrh.toFixed(1) +"%"

	for (var c=2;c<5;c++){
		tblCalcHead.cells[c].style.background = "#505050"
		tblHead = tblCalcHead.cells[c].innerHTML
		tblCalcHead.cells[c].innerHTML = addTTT(tblHead,'')
	}
		//.cells[1].innerHTML
	if (LFSwbDep > 7 && SFCwbDep < 5){
		//Wet Microburst
		tblCell = tblCalcHead.cells[3]
	}else if (LFSwbDep < 5 && SFCwbDep > 8){
		//Dry Microburst
		tblCell = tblCalcHead.cells[2]
	}else{
		//Hybrid Microburst
		tblCell = tblCalcHead.cells[4]
	}
	tblCell.style.background = "#9A9B6B"
	tblHead = tblCell.innerHTML
	tblCell.innerHTML = addTTT(tblHead,ovlyText)
}

//Calculate Storm Relative Winds of LFS - Level of Free Sink
function calcStormCon(){
	cape = atmEnDAT[iMU][4]
	ncape = calcNCAPE[iMU]
	document.getElementById("tblUpDown").rows[1].cells[0].innerHTML = addTTT(cape,ncape)
	fmtCell(document.getElementById("tblUpDown").rows[1].cells[0],cape,'cape')
	
	//Pull inflow from table & remove HTML markings
	inflowTXT = document.getElementById("tblSRFlo").rows[0].cells[1].innerHTML.split('<span class="tooltiptext"><br>')
	inflow = parseInt(inflowTXT[0].slice(21))
	exhTXT = document.getElementById("tblSRFlo").rows[0].cells[3].innerHTML.split('<span class="tooltiptext"><br>')
	exh = parseInt(exhTXT[0].slice(21))
	congestion = Math.round(100*inflow/exh)/100
	document.getElementById("tblUpDown").rows[1].cells[1].innerHTML = inflow
	document.getElementById("tblUpDown").rows[1].cells[2].innerHTML = exh
	document.getElementById("tblUpDown").rows[1].cells[3].innerHTML = congestion
}

//Populate DCAPE calculator Table
function setDCAPEcalc(dcapeDat,lvl){
	wndGust = wMaxKT(dcapeDat[1])
	document.getElementById("MXgust").value = Math.round(wndGust*1.10)
	document.getElementById("DSgust").value = Math.round(wndGust*0.75)
	document.getElementById("WSgust").value = Math.round(wndGust*0.95)
	document.getElementById("HSgust").value = Math.round(wndGust*0.90)
	document.getElementById("DLgust").value = Math.round(wndGust*0.65)
	document.getElementById("WLgust").value = Math.round(wndGust*0.80)
	document.getElementById("HLgust").value = Math.round(wndGust*0.75)
	document.getElementById("DVgust").value = Math.round(wndGust*0.50)
	document.getElementById("HVgust").value = Math.round(wndGust*0.60)
	document.getElementById("tblDCAPElvl").innerHTML = lvl
	document.getElementById("tblLFS").rows[1].cells[0].innerHTML = dcapeDat[1] + ' J/Kg'
	fmtCell(document.getElementById("tblLFS").rows[1].cells[0],dcapeDat[1],'dcape')
	document.getElementById("tblLFS").rows[1].cells[1].innerHTML = addTTT(Math.round(conM2FT(dcapeDat[0]))+ " ft ", dcapeDat[0] + ' m')
	calcLfsSrw()
	calcStormCon()
	calcMicroburstEnv()
	dispSectorWnd(wndGust)
	updateHodograph()
			
	//document.getElementById("tblCutDRWind").rows[1].cells[0].style.color = "white"
}

//Wind max Equation for downrush winds [DCAPE to wind speed (Kts)]
function wMaxKT(dCape){
	if(dCape>0){downrush=Math.round(Math.sqrt(2*dCape))}else{downrush=0}
	return downrush
}

//Display Sector Winds of the downdraft from each direction vectoring environmental flow
function dispSectorWnd(drws) {
	lvl = parseInt(document.getElementById("tblDCAPElvl").innerHTML)
	envWnd = calcEnvFlow(lvl)
	document.getElementById("tblDRWS").innerHTML = drws
	var cardDDD = [[315, 360, 45], [270, 0, 90], [225, 180, 135]];
	for (var r=0;r<3;r++){
		for (var c=0;c<3;c++){ 
			var x=document.getElementById("tblDRdir").rows[r].cells;
			x[c].style.color = "#D8D8D8";
			x[c].style.fontWeight = "normal"
			sectWS = Math.round(AddedEnvFlow(envWnd, cardDDD[r][c])) + drws
			x[c].innerHTML = sectWS
			fmtCell(x[c],sectWS,'wndsp')
		}
	}
	var x=document.getElementById("tblDRdir").rows[1].cells;
	x[1].style.color="black"
}

//Vector addition of environmental wind effects at each cardinal direction
function AddedEnvFlow(envWnd, sDDD) {
	envDirSp = getDirSp(envWnd)
	EnvComponent = (Math.cos((Math.PI*(sDDD-envDirSp[0])) / 180))*envDirSp[1]
	return EnvComponent;
}

//User activated function in microburst environment cut matrix
function addEnv(r,c) {
	if(r==1){sh='S'}else if(r==2){sh='L'}else if(r==3){sh='V'}
	if(c==1){env='D'}else if(c==2){env='W'}else if(c==3){env='H'}
	if(c==0){
		env='M'
		sh ='X'
	}
	boxName = env + sh + 'gust'
	drws = parseInt(document.getElementById(boxName).value);
	document.getElementById("tblDRWS").innerHTML = drws
	estDcape = Math.pow(drws, 2)/2
	dispSectorWnd(drws)
	document.getElementById("WindCut").rows[r].cells[c].style.color = "white";
}

// weighted avg of env flow based on density of downdraft parcel
function calcEnvFlow(lvl){
	dCape = atmDCAPE[lvl][1]
    if (dCape > 1300){
        t_wt = 1
    }else if (dCape < 300){
        t_wt = 0
    }else{
        t_wt = (dCape-300)/1000	
	}
	
    // break upper/lower weighted average flow
    env_t = atmDCAPE[lvl][3]
    env_b = atmDCAPE[lvl][2]
	
    // calc the environmental flow based on weights
    u_env = (env_t[0]*t_wt) + (env_b[0]*(1-t_wt))
    v_env = (env_t[1]*t_wt) + (env_b[1]*(1-t_wt))
		
	env_flow = [u_env,v_env]
	disWnd = UVwndDisp(env_flow)
	
	// display the environmental flow on the table
	document.getElementById("tblDDD").innerHTML = disWnd[0]
	document.getElementById("tblSS").innerHTML = disWnd[1]

	return env_flow
}

// Clear DCAPE Calculator return to Default operation
function clrDRtbl(){
	document.getElementById("mcDCAPE").style.visibility = "hidden"
	document.getElementById("parDCAPE").style.visibility = "hidden"
	document.getElementById("mcEnergy").style.visibility = "visible"
	iPARCEL = 0
	refreshDisplay()
}

// Draw Environmental Wind Profile
function dcapeLevelsTbl(){
	//Offset Rows to start at 425hPa
	x = 10
	//Populate Right Margin Table With CAPE CIN Values
	for (var r=0;r<39;r++){
		var rc=document.getElementById("rmarg").rows[r].cells
		if (r >= x && r <= atmDCAPE.length-1 + x){
			txtHTML = "<span onClick='dispDParcel("+(atmDCAPE.length-1-r+x)+")'>"
			rc[0].innerHTML = txtHTML + atmDCAPE[atmDCAPE.length-1-r+x][1] + "</span>"
			fmtCell(rc[0],atmDCAPE[atmDCAPE.length-1-r+x][1],'dcape')
			rc[0].style.fontWeight="normal"
			rc[0].style.fontSize="9px"
			rc[1].innerHTML = txtHTML + Math.round(conM2FT(atmDCAPE[atmDCAPE.length-1-r+x][0])) + "</span>"
			rc[1].style.color = "white"
			rc[1].style.fontWeight="normal"
			rc[1].style.fontSize="9px"
		}else{
			rc[0].innerHTML = "NULL"
			rc[0].style.color = "#2b3e50"
			rc[1].innerHTML = "NULL"
			rc[1].style.color = "#2b3e50"
		}
	}
	rc = document.getElementById("rmarg").rows[9].cells
	rc[0].innerHTML = "DCAPE"
	rc[0].style.color = "white"
	rc[1].innerHTML = "AGL"
	rc[1].style.color = "white"
}

//Test the calculation at each level to see the output
function tableDECAPE(){
	// Build Table Rows
	dispHtml = '<table id="tbltestDECAPE" border="1" style="font-size: 9pt">'
	dispHtml += '<tr><th>Press</th><th>DCAPE</th><th>DECAPE</th><th>Con%</th><th>DwnDft</th></tr>'
	for (var i=iDPAR;i>0;i--){
		dispHtml += '<tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>'
	}
	dispHtml += '</table>'
	document.getElementById("DElapse").innerHTML = dispHtml
	
	// Populate table data
	r = 0
	for (var i=iDPAR;i>0;i--){
		dat = calcDECAPE(i,iniPrR)
		r++
		x = document.getElementById("tbltestDECAPE").rows[r].cells
		
		x[0].innerHTML = addTTT(atmP[i], Math.round(conM2FT(atmZ[i])) + " ft")
		
		x[1].innerHTML = atmDCAPE[i][1]
		fmtCell(x[1],atmDCAPE[i][1],'dcape')
		
		ratioEnt = Math.round(dat[1]*1000/atmDCAPE[i][1])/10
		wndSp = Math.round(dat[2]*10)/10
		x[2].innerHTML = addTTT(Math.round(dat[1]), "Ratio<br>" + ratioEnt.toFixed(1)+"%")
		fmtCell(x[2],wndSp,'wndsp')
		
		if (dat[3]==null){
			x[3].innerHTML = ''
		}else{
			x[3].innerHTML = dat[3].toFixed(2)
		}
		dispWndSp = Math.round(wndSp)
		if (dispWndSp<10){dispWndSp = '0'+dispWndSp}
		buttonHTML = "<button class='btn btn-primary' style='font-size: 8pt' onClick='dispSectorWnd(" + Math.round(wndSp) + ")'>" + dispWndSp + "</button>"
		
		buttonHTML = "<button class='btn btn-primary' style='font-size: 8pt' onClick='dispDParLvl(" + i + ")'>" + dispWndSp + "</button>"
		x[4].innerHTML = buttonHTML
	}

}

// Draw Downdraft Parcel Path with DCAPE shadings
function calcDECAPE(lvl,iniPrR){
	//iniPrR = 7
	
	if (atmEnDAT[iMU][1]!=null){
		shLvlP = atmEnDAT[iMU][1]
	}else{
		shLvlP = atmEnDAT[0][2]
	}	
	wetBulbTemp = getWetBulbTemp(lvl)
	dpd = atmT[lvl] - wetBulbTemp
	
	// Adjust initial temp of parcel from wetbulb (amount of evaporative cooling) at LFS by dBz or precip quantity
	if (iniPrR < 3){
		parTini = wetBulbTemp  
	}else{
		parTini = wetBulbTemp + (((iniPrR - 2) * 0.05)*dpd)
	}
	//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + ' | Tini: ' + parTini
	
	//From initial evaporative cooling level but shift toward EnvT if starting below LFC due to precip falling through layer - (Time to evap limited)  
	if (atmP[lvl]>shLvlP){
		parTini = Math.min(parTini + ((atmP[lvl]-shLvlP)/(25-iniPrR)),atmT[lvl])
	}
	//document.getElementById("divtest").innerHTML =  document.getElementById("divtest").innerHTML + '| P: ' + atmP[lvl] + '| lcl: ' + lclP
	//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + ' | Tini2: ' + parTini + '<br>'
	
	UDparT = [wetBulbTemp]
	EparT = [parTini]
	parP = [atmP[lvl]]
	envTv = [virtTemp(atmT[lvl],Ws(atmDP[lvl],atmP[lvl]))]
		
	eDCAPE = 0	
	xDCAPE = 0
	
	for (var i=lvl-1;i>=0;i--){
		//Parcel at moist adiabatic lapse rate
		Tmalr = dtMALR(parP[parP.length-1],EparT[EparT.length-1],parP[parP.length-1]-atmP[i])	
		
		//Parcel at dry adiabatic lapse rate
		Tdalr = DALRtemp(DALRtheta(EparT[EparT.length-1],parP[parP.length-1]),atmP[i])
		
		//drE dry entrainment mixing dry air into downdraft preventing evaporative cooling
		drE = 1 - ((atmMSE0[i]+atmMSE0[i+1])/2)/((atmMSEstar[i]+atmMSEstar[i+1])/2)
		
		//prR precipitation density/availability for evaporation - 1: 60dbz  9: 10dbz
		prR = iniPrR + (Math.max(atmP[i]-shLvlP,0)/65)
		
		//Entrainment Parcel Lapse Rate Proportion (n ~ 0.69 is Max/collapsing cell)
		n = 0.69 - (drE*prR)
		
		//Set Parcel Temperature
		Tpar = Math.min((n*Tmalr) + ((1-n)*Tdalr),Tdalr)
		EparT.push(Tpar)
		parP.push(atmP[i])
		
		//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "n: " + n + " | Tmalr: " + Tmalr + " | Tdalr: " + Tdalr + "<br>"
		
		envTv.push( virtTemp(atmT[i],Ws(atmDP[i],atmP[i])) )
	
		//DCAPE - Compute and Integrate Downdraft Energy Area surface to level of interest
		tv1 = virtTemp(EparT[EparT.length-1],Ws(EparT[EparT.length-1],parP[parP.length-1]))
		tv2 = virtTemp(EparT[EparT.length-2],Ws(EparT[EparT.length-2],parP[parP.length-2]))
		parT_avg = (tv1 + tv2)/2
		T_avg = (envTv[envTv.length-1] + envTv[envTv.length-2])/2
		dZ = atmZ[i+1] - atmZ[i]
		eDCAPE = eDCAPE + (-9.8 * (parT_avg - T_avg) * dZ / (T_avg + ZEROCNK))
		if (eDCAPE>xDCAPE){xDCAPE=eDCAPE}
		//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "DCAPE: " + Math.round(eDCAPE) + "<br>"
	}
	if (eDCAPE>0){
		ws = conMS2KT(Math.sqrt(2*eDCAPE))
	}else{
		ws = 0
		//ws = conMS2KT(Math.sqrt(2*xDCAPE)) - conMS2KT(Math.sqrt(2*Math.abs(eDCAPE)))
	}
	//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "Final DCAPE: " + eDCAPE + " | wind: " + ws + "<br>"
	//document.getElementById("edCAPEout").innerHTML = "DCAPE: " + Math.round(eDCAPE) + " | %: " + Math.round(100*eDCAPE/atmDCAPE[lvl][1]) + " | wind: " + Math.round(ws) + "<br>" 
	
	if (atmP[lvl]>shLvlP){
		conRatio = null
	}else{
		stMo = getWndUV(document.getElementById("smF").value,document.getElementById("smM").value)
		srWnd = [atmWND[lvl][0]-stMo[0],atmWND[lvl][1]-stMo[1]]
		srFlo = UVwndDisp(srWnd)
		//Pull inflow from table & remove HTML markings
		inflowTXT = document.getElementById("tblSRFlo").rows[0].cells[1].innerHTML.split('<span class="tooltiptext"><br>')
		inflow = parseInt(inflowTXT[0].slice(21))
		conRatio = Math.round(100*inflow/srFlo[1])/100	
	}
	return[[parP,EparT],eDCAPE,ws,conRatio]
}

// Applys an entrainment factor to Downdraft Parcel - Main SkewT display
function dbzDCAPE(dbzLvl){
	iniPrR = dbzLvl
	deCAPEdat = calcDECAPE(iDPAR,iniPrR)
	plotDECAPE(deCAPEdat[0])
	tableDECAPE()
}

function dispDParLvl(inew){
	deCAPEdat = calcDECAPE(inew,iniPrR)
	plotDECAPE(deCAPEdat[0])
	wndSp = Math.round(deCAPEdat[2])
	dispSectorWnd(wndSp)
}

// Plots the Entrainment Downdraft Parcel
function plotDECAPE(parcelDat){	
	
	plotDCAPE(iDPAR)
	
	if (document.getElementById("parDCAPE").style.visibility == "visible"){
		var c = document.getElementById("skewtCanvas");
		var ctx = c.getContext("2d");
		
		
		
		parP = parcelDat[0]
		EparT = parcelDat[1]
		
		//Negative Energy Outline of Entrainment Parcel
		ctx.lineWidth = 2;
		ctx.strokeStyle = '#000000';
		ctx.setLineDash([])
		ctx.beginPath();
		i = 0
		y1 = coordY(parP[i])
		x1 = coordX(EparT[i],parP[i])
		ctx.moveTo(x1, y1);
		for (var i=1;i<parP.length;i++){
			y2 = coordY(parP[i])
			x2 = coordX(EparT[i],parP[i])
			ctx.lineTo(x2,y2)
		}
		ctx.stroke();
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Flight Hazards:  Tubulence 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Visualize Turbulence pop-up
function viewTurb(){
	document.getElementById("mcParcel").style.visibility = "hidden"
	document.getElementById("mcHail").style.visibility = "hidden"
	document.getElementById("mcHailGraph").style.visibility = "hidden"
	document.getElementById("mcFZpro").style.visibility = "hidden"
	document.getElementById("mcMxTx").style.visibility = "hidden"
	document.getElementById("mcRain").style.visibility = "hidden"
	document.getElementById("mcTurb").style.visibility = "hidden"
	document.getElementById("mcTorn").style.visibility = "hidden"
	document.getElementById("mcFog").style.visibility = "hidden"
	document.getElementById("mcDCAPE").style.visibility = "hidden"
	document.getElementById("parDCAPE").style.visibility = "hidden"
	calTbl = document.getElementById("mcTurb").style 
	calTbl.visibility = "visible"
	calTbl.top = 34
	calTbl.left = 100
	//document.getElementById("divtest").innerHTML = "Disp Turb"
	iniTurb()
}

function rgbTurbWS(ws){
	color="#9E9E9E"
	if (ws>=40 && ws<60){
		color="#DDDD6F"
	}else if (ws>=60 && ws<120){
		color="#FF6775"
	}else if (ws>=120){
		color="#FB79FF"
	}
	return color
}

function rgbTurbVWS(vws){
	color="#9E9E9E"
	if (vws>=8 && vws<11){
		color="#DDDD6F"
	}else if (vws>=11 && vws<21){
		color="#DEA46F"
	}else if (vws>=21 && vws<31){
		color="#FF7979"
	}else if (vws>=31 && vws<50){
		color="#FF79C6"
	}else if (vws>=50){
		color="#FB79FF"
	}
	return color
}

function turbCatText(x){
	switch(x) {
		case 1: 
			text = 'LGT'
			break;
		case 2: 
			text = 'LGT-MDT'
			break;
		case 3: 
			text = 'MDT'
			break;
		case 4: 
			text = 'MDT-SVR'
			break;
		case 5: 
			text = 'SVR'
			break;
		case 6: 
			text = 'SVR-EXT'
			break;
		case 7: 
			text = 'EXT'
			break;
		default:
			text = 'None'
	}
	return text
}

function iniTurb(){
// Build Table Rows
	dispHtml = '<table id="tblTurb" border="1" style="font-size: 10pt">'
	dispHtml += '<tr><th>AGL</th><th>MSL</th><th>WND</th><th>VWS</th><th>Turb</th></tr>'
	// Vertical Wind Shear for Turbulence above 4,000 AGL
	if(document.getElementById("llTurb").checked){
		zStartFt = 25000
		zEndFt = 4000
		panOpt = true
	}else{
		zStartFt = 45000
		zEndFt = 19000
		panOpt = false
	}
	
	for(var z=zStartFt;z>zEndFt;z=z-1000){
		vwsDat = getVWS(z)
		p = interpLvl('P',conFT2M(z),'AGL')
		dispHtml += '<tr><td>'+ addTTT(z,Math.round(p)+'mb') +'</td><td>'+Math.round(z+conM2FT(atmM[0]))+'</td>'
		wsColor = rgbTurbWS(vwsDat[1])
		dispHtml += '<td style="color: '+ wsColor +'" align="center">'+Math.round(vwsDat[1])+'</td>'
		vwsColor = rgbTurbVWS(vwsDat[2])
		dispHtml += '<td style="color: '+ vwsColor +'" align="center">'+Math.round(vwsDat[2]*10)/10+'</td>'
		txtTurb = turbCatText(vwsDat[3])		
		dispHtml += '<td align="center">'+ addTTT('<img height="20" src="img/turb'+vwsDat[3]+'.png">',txtTurb ) +'</td></tr>'
	}
	if (panOpt){
		// Panofsky for Turbulence below 4,000 AGL
		datPI = panofskyIndex()
		txtPI = 'Panofsky Index<br>PI: ' + datPI[0] + '<br><br>Richardson No<br>Ri: ' + datPI[1]
		dispHtml += '<tr><td colspan="2" align="center">'+ addTTT('SFC - 4000',txtPI) + '</td>'
		wsColor = rgbTurbWS(datPI[3])
		dispHtml += '<td style="color: '+ wsColor +'" align="center">' + datPI[3] + '</td>'
		vwsColor = rgbTurbVWS(datPI[4])
		dispHtml += '<td style="color: '+ vwsColor +'" align="center">'+ datPI[4] + '</td>'
		txtTurb = turbCatText(datPI[2])		
		dispHtml += '<td align="center">'+ addTTT('<img height="20" src="img/turb'+datPI[2]+'.png">',txtTurb ) +'</td></tr>'
	}
	dispHtml += "</table>"
	document.getElementById("vwsTurb").innerHTML = dispHtml
}

//VERIFICATION RESULTS OF A TURBULENCE INDEX APPLIED TO LOW-LEVELS OF THE ATMOPHERE Gordon R. Brooks*, Ingrid Gotchel, and Christopher M. StockAir Force Weather Agency, Offutt AFB, NE Jeffrey E. PassnerU.S. Army Research Laboratory, White Sands Missile Range, NM David I. KnappNOAA/NCEP/NWS Aviation Weather Center, Kansas City, MO
function panofskyIndex(){
	wnd = interpLvl('WND',800,'AGL')
	ws = conKT2MS(UVwndDisp(wnd)[1])
	t = interpLvl('T',800,'AGL')
	p = interpLvl('P',800,'AGL')
	th = DALRtheta(t,p) + 273.15
	grth = (9.8/th)
	
	t = interpLvl('T',1300,'AGL')
	p = interpLvl('P',1300,'AGL')
	thTop = DALRtheta(t,p) + 273.15
	t = interpLvl('T',300,'AGL')
	p = interpLvl('P',300,'AGL')
	thBot = DALRtheta(t,p) + 273.15
	dth = (thTop-thBot)/1000
	
	wndTop = interpLvl('WND',1300,'AGL')
	wndBot = interpLvl('WND',300,'AGL')
	vws = calcLyrShear(wndBot,wndTop)
	shr =  (conKT2MS(vws)/1000)
	
	// Richardson Number
	ri = (grth * dth)/(shr * shr)
	riCrit = 10
	
	pi = (ws*ws) * (1 - (ri/riCrit))
	turb = findPITurb(pi)
	document.getElementById("divtest").innerHTML = "PI " + Math.round(pi)
	
	//0-PI;  1-Ri;  2-TurbIndex;  3-AvgWnd(kt);  4-shear/1000ft
	return [Math.round(pi), Math.round(10*ri)/10,turb,Math.round(UVwndDisp(wnd)[1]),Math.round(vws/3.28)*10/10]
}

// Find the vertical wind shear per 1000 feet at a given level
function getVWS(ft){
	z =  conFT2M(ft)
	zT = conFT2M(ft + 500)
	zB = conFT2M(ft - 500)
	wnd = interpLvl('WND',z,'AGL')
	wndT = interpLvl('WND',zT,'AGL')
	wndB = interpLvl('WND',zB,'AGL')
	vws = calcLyrShear(wndB,wndT)
	ws = UVwndDisp(wnd)
	turb = findTurb(ws[1],vws)
	return [z,ws[1],vws,turb]
}

// Define the level of tubulence from windspeed and vertical wind shear return 1 - 7
function findTurb(ws,vws){
	//TN98-002 & 70-7 & 79-001 Table
	//0-Neg; 1-Lgt; 2-Lgt/Mod; 3-Mdt; 4-Mdt/Svr; 5-Svr; 6-Svr/Ext; 7-Ext
	turb = 0
	if (ws>=40){
		if (ws>60 && ws<120){
			turb = 1
		}else if (ws>=120){
			turb = 2
		}
		
		if (vws < 4){
			if (turb>0){turb = turb - 1}
		}else if (vws>=8 && vws<11){
			turb = turb + 1
		}else if (vws>=11 && vws<21){
			turb = turb + 2
		}else if (vws>=21 && vws<31){
			turb = turb + 3
		}else if (vws>=31 && vws<50){
			turb = turb + 4
		}else if (vws>=50){
			turb = turb + 5
		}
	}
	return turb
}

function findPITurb(pani){
	//0-Neg; 1-Lgt; 2-Lgt/Mod; 3-Mdt; 4-Mdt/Svr; 5-Svr; 6-Svr/Ext; 7-Ext
	turb = 0
	if (pani>=40){turb = 1}
	if (pani>=95){turb = 2}
	if (pani>=120){turb = 3}
	if (pani>=245){turb = 4}
	if (pani>=270){turb = 5}
	return turb
}

function closeTurb(){
	document.getElementById("mcTurb").style.visibility = "hidden"
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Hodograph
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function iniHodograph(){
	//Sizing Window
	HoMPx = HODOSZ/2
	HoMPy = HODOSZ/2
	
	//Size HODO by max wind ranging from 25 to 80 kts
	mxWnd = 25
	for (var z=0;z<atmWND.length-1;z++){
		dddss = UVwndDisp(atmWND[z])
		if (dddss[1] > mxWnd){mxWnd=dddss[1]}
		if (mxWnd>=80){
			mxWnd=80
			break
		}
	}
	mxWnd = mxWnd + 5
	HOPXEXPAN = HoMPx/mxWnd;
	
	// Find MUEL and 65% MUEL for critical storm heights
	stmHgt = defStormHeights()
	
	// Calculate Effective Layers
	if(document.getElementById("enEIFL").checked){
		effInLyr = findEffectiveInflow()
	}else{
		inT = parseInt(document.getElementById("manEFFT").value)
		inB = parseInt(document.getElementById("manEFFB").value)
		document.getElementById("EFFT").innerHTML = inT
		document.getElementById("EFFB").innerHTML = inB
		effInLyr = [inB,inT]
	}
	
	// Determine Storm Flow Based on Inflow and Critical Storm Heights
	stMo = findStormMotion(effInLyr,stmHgt[1])
	stMo = calcSplitMove(stMo)
	STORMMOTION = stMo
	
	// Display Storm Motion
	document.getElementById("smF").value = UVwndDisp(stMo)[0]
	document.getElementById("smT").value = UVwndDisp([stMo[0]*-1,stMo[1]*-1])[0]
	document.getElementById("smM").value = UVwndDisp(stMo)[1]
	
	// Calculate and display the Shears across several critical storm heights
	calcProfShear(stmHgt[0],stmHgt[1])

	// Calculate and Display Heavy Rain/Precipitation Parameters With Kinematics
	pw = calcPWI()
	//document.getElementById("tblRain").rows[0].cells[1].innerHTML = addTTT(Math.round(conMM2IN(pw)*100)/100 + "''",Math.round(pw) + ' mm')
	//fmtCell(document.getElementById("tblRain").rows[0].cells[1],pw,'pwi')
	document.getElementById("tblEnergy").rows[5].cells[2].innerHTML = addTTT(Math.round(conMM2IN(pw)*100)/100 + "''",Math.round(pw) + ' mm')
	fmtCell(document.getElementById("tblEnergy").rows[5].cells[2],pw,'pwi')
	document.getElementById("tblGRenv").rows[3].cells[2].innerHTML = addTTT(Math.round(conMM2IN(pw)*100)/100 + "''",Math.round(pw) + ' mm')
	fmtCell(document.getElementById("tblGRenv").rows[3].cells[2],pw,'pwi')
		
	gdi = calcGDI()
	//document.getElementById("tblRain").rows[0].cells[3].innerHTML = gdi
	//fmtCell(document.getElementById("tblRain").rows[0].cells[3],gdi,'gdi')
	document.getElementById("tblEnergy").rows[5].cells[1].innerHTML = gdi
	fmtCell(document.getElementById("tblEnergy").rows[5].cells[1],gdi,'gdi')
	
	corfidiMove = corfidi()
	mccMov = UVwndDisp(corfidiMove[0])
	document.getElementById("tblRain").rows[0].cells[1].innerHTML = addTTT(mccMov[0]+'|'+mccMov[1],'From ' + mccMov[0] + ' to ' + getDispDDD(mccMov[0]+180))
	dcMov = UVwndDisp(corfidiMove[1])
	document.getElementById("tblRain").rows[1].cells[1].innerHTML = addTTT(dcMov[0]+'|'+dcMov[1],'From ' + dcMov[0] + ' to ' + getDispDDD(dcMov[0]+180))
	stMov = UVwndDisp(stMo)
	document.getElementById("tblRain").rows[2].cells[3].innerHTML = addTTT(stMov[0]+'|'+stMov[1],'From ' + stMov[0] + ' to ' + getDispDDD(stMov[0]+180))
	
	calcHodoVals()
}

//Changes the mid point of the hodograph
function HoMove(dir){
	if (dir=='L'){
		HoMPx = HoMPx + 20
	}else if (dir=='R'){
		HoMPx = HoMPx - 20
	}else if (dir=='U'){
		HoMPy = HoMPy + 20
	}else if (dir=='D'){
		HoMPy = HoMPy - 20
	}
	updateHodograph()
}

//Changes the zoom of the hodograph
function HoZoom(dir){
	if (dir=='I'){
		HOPXEXPAN = HOPXEXPAN + 0.35
	}else if (dir=='O'){
		HOPXEXPAN = HOPXEXPAN - 0.35
	}
	updateHodograph()
}

//Trolling The BIFROST Hodograph for absurdly small size
function BifrostViewHodo(){
	HoMPx = HODOSZ/2
	HoMPy = HODOSZ/2
	HOPXEXPAN = 0.7307692307692301
	updateHodograph()
}

//Recalculate Storm Relative Values 
function calcHodoVals(){
	stMo = getWndUV(document.getElementById("smF").value,document.getElementById("smM").value)
	STORMMOTION = stMo
	
	if (document.getElementById("srHodo").checked){
		srX = -1 * HOPXEXPAN * stMo[1]
		srY = 1 * HOPXEXPAN * stMo[0]
	}else{
		srX = 0
		srY = 0	
	}
	
	hodoHelicity(stMo)
	stormRelFlows(stMo)
	calcPEKEvals()
	dispParcel(iPARCEL)
	dispHailSpecs()
	updateHodograph()
}

//Redraw Hodograph features
function updateHodograph(){	
	stMo = getWndUV(document.getElementById("smF").value,document.getElementById("smM").value)
	
	if (document.getElementById("srHodo").checked){
		srX = -1 * HOPXEXPAN * stMo[1]
		srY = 1 * HOPXEXPAN * stMo[0]
	}else{
		srX = 0
		srY = 0	
	}
	
	plotEIFL(srX,srY,stMo)
	plotHodoBG()
	markStormMotion(srX,srY)
	plotHodograph(srX,srY)
	markHodograph(srX,srY)
}

//Define Layers based on Storm Heights [0-MUEL,1-65%MUEL]
function defStormHeights(){
	enDat = atmEnDAT[iMU]
	//If there is  MU CAPE then set heights
	if (enDat[4] > 0){
		muelHgt = interpLvl("AGL",enDat[0],"P")
		muel65Hgt = 0.65 * muelHgt
	}else{
		muelHgt = 9500
		muel65Hgt = 6000
	}
	return [muelHgt,muel65Hgt]
}

//Bunkers 2014 Pressure Weighted Average Wind from effective inflow base to 65% MU EL
function findStormMotion(effInLyr,muel65Hgt){
	Ptotal = 0
	//Total pressure above Inflow Base Until 65% MUEL
	for (var z=0;atmZ[z]<muel65Hgt;z++){
		if(atmZ[z]>=effInLyr[0]){Ptotal=Ptotal+atmP[z]}	
	}
	uAvg = 0
	vAvg = 0
	for (var z=0;atmZ[z]<muel65Hgt;z++){
		if(atmZ[z]>=effInLyr[0]){
			uAvg = uAvg + (atmWND[z][0] * atmP[z]/Ptotal)
			vAvg = vAvg + (atmWND[z][1] * atmP[z]/Ptotal)
		}	
	}

	// Weak CAPE cases not meeting effective thresholds set default to avoid zero storm flow
	if (Ptotal == 0){
		defaultWnd = interpLvl("WND",muel65Hgt,"AGL")
		uAvg = defaultWnd[0]
		vAvg = defaultWnd[1]
	}
	
	return [uAvg,vAvg]
}

//Gets effective inflow (meters AGL) 
function findEffectiveInflow(){
	// Pull CAPE and CIN thresholds from GUI 
	THcape = parseInt(document.getElementById("manEFCAPE").value)
	THcin = parseInt(document.getElementById("manEFCIN").value)
	inB = -1
	
	for (var z=0;atmZ[z]<5000;z++){
		cape = atmEnDAT[z][4]
		cin = atmEnDAT[z][5]
		if (z==0 && cape > THcape && cin > THcin){
			//Base of effective inflow is the surface first layer
			inB = atmP[0]
		}else if(inB < 0 && cape > THcape && cin > THcin){
			//Above the surface we cross the energy thresholds interpolate heights where we cross to establish base
			wts = getIntpWt(atmEnDAT[z-1][4],cape,THcape)
			capeB = (atmEnDAT[z-1][3]*wts[0])+(atmEnDAT[z][3]*wts[1])
			wts = getIntpWt(atmEnDAT[z-1][5],cin,THcin)
			cinB = (atmEnDAT[z-1][3]*wts[0])+(atmEnDAT[z][3]*wts[1])
			if (cape > THcape && atmEnDAT[z-1][4] > THcape){
				inB = cinB
			}else if (cin > THcin && atmEnDAT[z-1][5] > THcin){
				inB = capeB
			}else{
				inB = Math.max(cinB,capeB)
			}
		}else if(inB >= 0 && (cape < THcape || cin < THcin)){
			//Once base is established establish a top when one energy breaks threshold
			wts = getIntpWt(atmEnDAT[z-1][4],cape,THcape)
			capeT = (atmEnDAT[z-1][3]*wts[0])+(atmEnDAT[z][3]*wts[1])
			wts = getIntpWt(atmEnDAT[z-1][5],cin,THcin)
			cinT = (atmEnDAT[z-1][3]*wts[0])+(atmEnDAT[z][3]*wts[1])
			inT = Math.min(cinT,capeT)
			break	
		}
	}
	//Estabilsh default if CAPE CIN thresholds aren't met
	if (inB < 0){
		//Start with MUCAPE or use Non-Convective Default
		if (atmEnDAT[iMU][4]>0){
			inB = interpLvl("AGL",atmEnDAT[iMU][3],"P")
			inT = inB + 1000
		}else{
			inB = 2000
			inT = 4000
		}
	}else{
		inB = interpLvl("AGL",inB,"P")
		inT = interpLvl("AGL",inT,"P")
	}
	
	document.getElementById("EFFT").innerHTML = Math.round(inT)
	document.getElementById("EFFB").innerHTML = Math.round(inB)
	document.getElementById("manEFFT").value = Math.round(inT)
	document.getElementById("manEFFB").value = Math.round(inB)
	return [inB,inT]
}

//Shade Effective Inflow Layer Area represemtimg SRH 
function plotEIFL(srX,srY,stMo){
	var hodo = document.getElementById("hodoCanvas");
	var ctx = hodo.getContext("2d");
	
	//Sizing Window
	L = HODOSZ
	ctx.clearRect(0,0,L,L)
	
	//Pull Effective Inflow Layer from GUI
	infloT = parseInt(document.getElementById("EFFT").innerHTML)
	infloB = parseInt(document.getElementById("EFFB").innerHTML)
	
	for(var z=0;atmZ[z]<=infloT;z++){
		
		if (infloB < 2000 && atmZ[z]>=infloB){
			//Background Color Brightness based on CIN intensity
			cinRGB = "#F7F9FB"
			if(atmEnDAT[z][5]>-200){cinRGB = "#F0F0F0"}
			if(atmEnDAT[z][5]>-150){cinRGB = "#D5D5D5"}
			if(atmEnDAT[z][5]>-100){cinRGB = "#B6B6B6"}
			if(atmEnDAT[z][5]>-70){cinRGB = "#979797"}
			if(atmEnDAT[z][5]>-40){cinRGB = "#818181"}
			if(atmEnDAT[z][5]>-15){cinRGB = "#757676"}
			capeRGB = "#555555"
			//Inflow web cables show CAPE intensity
			if(atmEnDAT[z][4]>0){capeRGB = "#1EF015"}
			if(atmEnDAT[z][4]>500){capeRGB = "#F0E501"}
			if(atmEnDAT[z][4]>1000){capeRGB = "#FF1212"}
			if(atmEnDAT[z][4]>1500){capeRGB = "#EE49F3"}
			if(atmEnDAT[z][4]>2000){capeRGB = "#ED6BFF"}
			
			//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + "<br>" + z + ':' + atmEnDAT[z][5] + ':' + cinRGB
		
			//Hodograph X,Y coordinate System x = -v; y = u
			SMy = (1 * HOPXEXPAN * stMo[0]) - srY
			SMx = (-1 * HOPXEXPAN * stMo[1]) - srX
			y1 = (1 * HOPXEXPAN * atmWND[z][0]) - srY
			x1 = (-1 * HOPXEXPAN * atmWND[z][1]) - srX
			y2 = (1 * HOPXEXPAN * atmWND[z+1][0]) - srY
			x2 = (-1 * HOPXEXPAN * atmWND[z+1][1]) - srX
		
			//Draw Triangle two vector points plus storm motion point - CAPE: Line Color/CIN: Fill Color
			ctx.strokeStyle = capeRGB
			ctx.beginPath();
			ctx.lineWidth=2;
			ctx.moveTo(HoMPx+SMx,HoMPy+SMy);
			ctx.lineTo(HoMPx+x1,HoMPy+y1);
			ctx.lineTo(HoMPx+x2,HoMPy+y2);
			ctx.fillStyle = cinRGB;
			ctx.stroke()
			ctx.fill();
		}
	}
}

//Draw background polar graph rings marking windspeed
function plotHodoBG(){
	var hodo = document.getElementById("hodoCanvas");
	var ctx = hodo.getContext("2d");
	
	// Draw Center Line Top to Bottom (Split L vs R) in True Center
	ctx.strokeStyle = "#252525"
	ctx.beginPath();
	ctx.moveTo(HoMPx,0);
	ctx.lineTo(HoMPx,L);
	ctx.lineWidth=1;
	ctx.stroke();
	// Draw Center Line Left to Right (Split Top vs Bottom)
	ctx.beginPath();
	ctx.moveTo(0,HoMPy);
	ctx.lineTo(L,HoMPy);
	ctx.stroke();
			
	// Draw Magnitude Rings at 10 kts increments
	ctx.font = "10px Arial";
	ctx.fillStyle = "#252525"
	for(i=1;i<11;i++){
		gradVal = i*10
		radiusPxVal = i * 10 * HOPXEXPAN
		ctx.beginPath();
		// Windspeed Labels up Y-axis
		ctx.fillText(gradVal + " kts",HoMPx,HoMPy - radiusPxVal-1); 
		// Windspeed Labels across X-axis
		ctx.fillText(gradVal,HoMPx + radiusPxVal - 14,HoMPy);
		//ctx.fillText(gradVal,MP - radiusPxVal - 12,MP);
		// Windspeed Rings
		ctx.arc(HoMPx,HoMPy,radiusPxVal,0,6.3);
		ctx.stroke();
	}
}

//Draws the hodograph line from wind profile
function plotHodograph(srX,srY){
	var hodo = document.getElementById("hodoCanvas");
	var ctx = hodo.getContext("2d");
	enDat = atmEnDAT[iMU]
	mucape = enDat[4]
	Pmuel = enDat[0]

	//Plot entire hodograph from model profile
	for(z=0;z<atmWND.length-1;z++){
		//Hodograph X,Y coordinate System x = -v; y = u
		y1 = 1 * HOPXEXPAN * atmWND[z][0] - srY
		x1 = -1 * HOPXEXPAN * atmWND[z][1] - srX
		y2 = 1 * HOPXEXPAN * atmWND[z+1][0] - srY
		x2 = -1 * HOPXEXPAN * atmWND[z+1][1] - srX
		//Hodograph Shear Vector Line
		ctx.beginPath();
		if(atmZ[z]<1000){
			rbgCode = "#F929FF"
		}else if (atmZ[z]>=1000 && atmZ[z]<3000){
			rbgCode = "#FF000C"
		}else if (atmZ[z]>=3000 && atmZ[z]<6000){
			rbgCode = "#15CB00"
		}else if (atmZ[z]>=6000 && atmZ[z]<9000){
			rbgCode = "#FFB900"
		}else{
			rbgCode = "#00D8FF"
		}
		ctx.strokeStyle = rbgCode
		if (mucape > 0 && atmP[z] > Pmuel){
			ctx.lineWidth=4;
		}else{
			ctx.lineWidth=2;
		}
		
		ctx.moveTo(HoMPx+x1,HoMPy+y1);
		ctx.lineTo(HoMPx+x2,HoMPy+y2);
		ctx.stroke();
	}
}

//Draws the height markers on the hodograph line
function markHodograph(srX,srY){
	var hodo = document.getElementById("hodoCanvas");
	var ctx = hodo.getContext("2d");
	agls = [0,500,1000,2000,3000,5000,7000,9000,11000,13000,15000]
	
	ctx.lineWidth = 1;
	ctx.strokeStyle = 'black';
	ctx.fillStyle = 'black';
	ctx.font = "11px Arial";
	ctx.setLineDash([])	

	MP = HODOSZ/2
	wind = atmWND[0]
	//Hodograph X,Y coordinate System x = -v; y = -u
	y = 1 * HOPXEXPAN * wind[0] - srY
	x = -1 * HOPXEXPAN * wind[1] - srX
	ctx.beginPath();
	ctx.rect(HoMPx+x-2,HoMPy+y-2,4,4)
	ctx.fillText('0', HoMPx+x+5, HoMPy+y+4);
	ctx.fill();
	ctx.stroke();
	
	//Plot entire hodograph from model profile
	for(var z=0;agls[z]<atmZ[atmZ.length-1];z++){
		wind = interpLvl('WND',agls[z],'AGL')
		//Hodograph X,Y coordinate System x = -v; y = -u
		y = 1 * HOPXEXPAN * wind[0] - srY
		x = -1 * HOPXEXPAN * wind[1] - srX
		ctx.beginPath();
		ctx.rect(HoMPx+x-2,HoMPy+y-2,4,4)
		ctx.fillText(agls[z]/1000, HoMPx+x+5, HoMPy+y+4);
		ctx.fill();
		ctx.stroke();
	}
	
	//Plot significant temperatures for hail view
	if (document.getElementById("mcHail").style.visibility=="visible"){
		temps = [0, -10, -30]
		dispTemp = ["FZ", "M10", "M30"]
		ctx.strokeStyle = '#DA00CC';
		ctx.fillStyle = '#DA00CC';
		ctx.font = "12px Arial";
		for(var z=0;z<3;z++){
			if (atmT[0]>temps[z]){
				wind = interpLvl('WND',temps[z],'T')
				//Hodograph X,Y coordinate System x = -v; y = -u
				y = 1 * HOPXEXPAN * wind[0] - srY
				x = -1 * HOPXEXPAN * wind[1] - srX
				ctx.beginPath();
				ctx.fillText('X', HoMPx+x-3, HoMPy+y+2);
				ctx.fillText(dispTemp[z], HoMPx+x-9, HoMPy+y-9);
				ctx.fill();
				ctx.stroke();
			}
		}
	}
	
	//Plot Deviant Tornado Motion
	if (document.getElementById("mcTorn").style.visibility == "visible"){
		//Mean Wind 0-500m
		wnd05KM = interpLvl("WND",500,"AGL")
		uAvg = 0
		vAvg = 0
		for (var z=0;atmZ[z]<500;z++){
			uAvg = uAvg + atmWND[z][0]
			vAvg = vAvg + atmWND[z][1]
		}
		avgWnd = [(uAvg + wnd05KM[0])/(z+1),(vAvg + wnd05KM[1])/(z+1)]
		dtm = [(avgWnd[0] + STORMMOTION[0])/2,(avgWnd[1] + STORMMOTION[1])/2] 
		y = 1 * HOPXEXPAN * dtm[0] - srY
		x = -1 * HOPXEXPAN * dtm[1] - srX
		ctx.strokeStyle = 'Black';
		ctx.fillStyle = 'Black';
		ctx.font = "14px Arial";
		ctx.beginPath();
		ctx.fillText('', HoMPx+x-3, HoMPy+y+2);
		ctx.font = "9px Arial";
		ctx.fillText('DTM', HoMPx+x-7, HoMPy+y-10);
		ctx.fill();
		ctx.stroke();
	}
	
	//Plot significant temperatures for hail view
	if (document.getElementById("mcDCAPE").style.visibility=="visible"){
		iLFS = parseInt(document.getElementById("tblDCAPElvl").innerHTML)
		ctx.strokeStyle = '#DA00CC';
		ctx.fillStyle = '#DA00CC';
		ctx.font = "12px Arial";
		wind = atmWND[iLFS]
		//Hodograph X,Y coordinate System x = -v; y = -u
		y = 1 * HOPXEXPAN * wind[0] - srY
		x = -1 * HOPXEXPAN * wind[1] - srX
		ctx.beginPath();
		ctx.fillText('X', HoMPx+x-3, HoMPy+y+2);
		ctx.fillText('LFS', HoMPx+x-9, HoMPy+y-9);
		ctx.fill();
		ctx.stroke();

	}
}

//Draws the storm motion vector
function markStormMotion(srX,srY){
	var hodo = document.getElementById("hodoCanvas");
	var ctx = hodo.getContext("2d");
	
	ctx.lineWidth = 3;
	ctx.strokeStyle = 'brown';
	ctx.fillStyle = 'brown';
	ctx.font = "11px Arial";
	ctx.setLineDash([])	

	y = (1 * HOPXEXPAN * stMo[0]) - srY
	x = (-1 * HOPXEXPAN * stMo[1]) - srX
	//Plot Storm Motion from center to heading
	ctx.beginPath()
	ctx.moveTo(HoMPx-srX,HoMPy-srY);
	ctx.lineTo(HoMPx+x,HoMPy+y);
	ctx.arc(HoMPx+x,HoMPy+y,3,0,2*Math.PI)
	//Hodograph X,Y coordinate System x = -v; y = -u
	//ctx.fillText(agls[z]/1000, MP+x+5, MP+y+4);
	ctx.stroke();
}

//Calculates Shear Vectors 
function calcLyrShear(wnd1,wnd2) {return getWndMag(wnd2[0]-wnd1[0],wnd2[1]-wnd1[1])}

//Standardizes tabular wind displays (shears/SRWs) to add tooltiptext and threshold formatting 
function dispKnots(tblCell,valKT,colorMap){
	dispText = addTTT(Math.round(valKT*10)/10,Math.round(conKT2MS(valKT)*10)/10 + ' m/s')
	tblCell.innerHTML = dispText
	fmtCell(tblCell,valKT,colorMap)
}

//Calculates Shear vector for each level
function calcProfShear(muelHgt,muel65Hgt){
	infloT = parseInt(document.getElementById("EFFT").innerHTML)
	infloB = parseInt(document.getElementById("EFFB").innerHTML)
	hgtM10 = interpLvl("AGL",-10,"T")
	wndM10 = interpLvl("WND",-10,"T")
	wndEL = interpLvl("WND",muelHgt,"AGL")
	wndMID = interpLvl("WND",muel65Hgt,"AGL")
	wndEFFB = interpLvl("WND",infloB,"AGL")
	wnd1KM = interpLvl("WND",1000,"AGL")
	wnd3KM = interpLvl("WND",3000,"AGL")
	wnd6KM = interpLvl("WND",6000,"AGL")
	wnd12KM = interpLvl("WND",12000,"AGL")
	if(infloB>1000){grBaseHgt = 1000}else{grBaseHgt = infloB}
	wndGRB = interpLvl("WND",grBaseHgt,"AGL")
	if(infloB<2000){sfcBase = infloB}else{sfcBase = 0}
	wndSFC = interpLvl("WND",sfcBase,"AGL")
	
	//Bulk Shear Calculations
	shrB1KM = calcLyrShear(atmWND[0],wnd1KM)
	//dispKnots(document.getElementById("tblGRenv").rows[1].cells[1],shrB1KM,'grbwd01')
	dispKnots(document.getElementById("tblFCll").rows[1].cells[1],shrB1KM,'fcbwd01')
	
	shrB3KM = calcLyrShear(atmWND[0],wnd3KM)
	dispKnots(document.getElementById("tblFCll").rows[1].cells[2],shrB3KM,'fcbwd03')
	
	shrB6KM = calcLyrShear(atmWND[0],wnd6KM)
	dispKnots(document.getElementById("tblShear").rows[1].cells[1],shrB6KM,'bwd06')
	
	shrB1t6KM = calcLyrShear(wnd1KM,wnd6KM)
	dispKnots(document.getElementById("tblGRenv").rows[1].cells[3],shrB1t6KM,'bwd06')
	shrB1t12KM = calcLyrShear(wnd1KM,wnd12KM)
	dispKnots(document.getElementById("tblGRenv").rows[1].cells[4],shrB1t12KM,'grbwd112')
		
	shrBeff = calcLyrShear(wndEFFB,wndMID)
	dispKnots(document.getElementById("tblShear").rows[2].cells[1],shrBeff,'bwde')
	dispKnots(document.getElementById("tblGRenv").rows[1].cells[0],shrBeff,'bwde')
	dispKnots(document.getElementById("tblFCsc").rows[1].cells[2],shrBeff,'bwde')
	dispKnots(document.getElementById("tblRain").rows[0].cells[3],shrBeff,'twde')
	
	shrBgr = calcLyrShear(wndGRB,wndM10)
	//document.getElementById("tblShear").rows[3].cells[1].innerHTML = Math.round(shrBgr*10)/10
	
	shrBstorm = calcLyrShear(wndSFC,wndEL)
	dispKnots(document.getElementById("tblShear").rows[3].cells[1],shrBstorm,'bwd012')
	
	//Bulk Wind Difference Ratio: Funnel (0-1km) Vs Mesocyclone (1-6km)
	bwdr116 = Math.round(1000 * shrB1KM / shrB1t6KM)/10
	document.getElementById("tblGRenv").rows[1].cells[2].innerHTML = addTTT(bwdr116,"0-1 BWD: " + shrB1KM.toFixed(0) + "<br>1-6 BWD: " + + shrB1t6KM.toFixed(0))
	fmtCell(document.getElementById("tblGRenv").rows[1].cells[2],bwdr116,'gr16ratio')
	
	document.getElementById("tblFCll").rows[1].cells[0].innerHTML = bwdr116.toFixed(1)
	fmtCell(document.getElementById("tblFCll").rows[1].cells[0],bwdr116,'fc16ratio')
	
	//Total Shear Calculations Entire Profile
	envSHR = []
	for (var z=0;z<atmWND.length-2;z++){envSHR.push(calcLyrShear(atmWND[z],atmWND[z+1]))}
	
	//0-6KM Shear
	shrT6KM = 0 
	z = 0
	while (atmZ[z+1] < 6000){
		shrT6KM = shrT6KM + envSHR[z]
		z++
	}
	shrT6KM = shrT6KM + calcLyrShear(atmWND[z],wnd6KM)
	dispKnots(document.getElementById("tblShear").rows[1].cells[2],shrT6KM,'twd06')
	
	//Effective Shear
	for (var z=0;atmZ[z]<infloB;z++){}
	shrTeff = calcLyrShear(wndEFFB,atmWND[z])
	while (atmZ[z+1] < muel65Hgt){
		shrTeff = shrTeff + envSHR[z]
		z++
	}
	shrTeff = shrTeff + calcLyrShear(atmWND[z],wndMID)
	dispKnots(document.getElementById("tblShear").rows[2].cells[2],shrTeff,'twde')
	
	//Hail
	for (var z=0;atmZ[z]<grBaseHgt;z++){}
	shrTgr = calcLyrShear(wndGRB,atmWND[z])
	while (atmZ[z+1] < hgtM10){
		shrTgr = shrTgr + envSHR[z]
		z++
	}
	shrTgr = shrTgr + calcLyrShear(atmWND[z],wndM10)
	//document.getElementById("tblShear").rows[3].cells[2].innerHTML = Math.round(shrTgr*10)/10
	GRline = Math.round(1000 * shrBgr / shrTgr)/10
	document.getElementById("tblGRenv").rows[1].cells[1].innerHTML = addTTT(GRline.toFixed(1),"GR BWD: " + shrBgr.toFixed(0) + "<br>GR TWD: " + + shrTgr.toFixed(0))
	fmtCell(document.getElementById("tblGRenv").rows[1].cells[1],GRline,'grline')
		
	//Whole Storm
	for (var z=0;atmZ[z]<sfcBase;z++){}
	shrTstorm = calcLyrShear(wndSFC,atmWND[z])
	while (atmZ[z+1] < muelHgt){
		shrTstorm = shrTstorm + envSHR[z]
		z++
	}
	shrTstorm = shrTstorm + calcLyrShear(atmWND[z],wndEL)
	dispKnots(document.getElementById("tblShear").rows[3].cells[2],shrTstorm,'twd012')
	
	//Cold Pool Propapgation
	cPtotal = 0
	mxZ = getLvlMUDCAPE()
	for (var z=0;z<=mxZ;z++){cPtotal = cPtotal + atmP[z] + atmDCAPE[z][1]}
	uAvg = 0
	vAvg = 0
	for (var z=0;z<=mxZ;z++){
		lvlWt = atmP[z] + atmDCAPE[z][1]
		uAvg = uAvg + (atmWND[z][0] * lvlWt/cPtotal)
		vAvg = vAvg + (atmWND[z][1] * lvlWt/cPtotal)
	}
	cPmov = UVwndDisp([uAvg,vAvg])
	document.getElementById("tblRain").rows[2].cells[1].innerHTML = addTTT(cPmov[0]+'|'+cPmov[1],'From ' + cPmov[0] + ' to ' + getDispDDD(cPmov[0]+180)) 
	
}

//Trig style function to calculate angle between Shear Vector and Storm Motion vector determining Streamwise vs Crosswise ratio
function findAngle(p0,p1,p2) {
  var a = Math.pow(p1[0]-p0[0],2) + Math.pow(p1[1]-p0[1],2),
      b = Math.pow(p1[0]-p2[0],2) + Math.pow(p1[1]-p2[1],2),
      c = Math.pow(p2[0]-p0[0],2) + Math.pow(p2[1]-p0[1],2);
  return Math.acos( (a+b-c) / Math.sqrt(4*a*b) );
}

// Calculate Storm Relative Helicity in layer  
function calcLyrSRH(stMo,wnd1,wnd2) {
	dU = conKT2MS(wnd1[0]) - conKT2MS(wnd2[0])
	dV = conKT2MS(wnd1[1]) - conKT2MS(wnd2[1])
	Ubar = (conKT2MS(wnd2[0]) + conKT2MS(wnd1[0]))/2
	Vbar = (conKT2MS(wnd2[1]) + conKT2MS(wnd1[1]))/2
	Usr = Ubar - conKT2MS(stMo[0])
	Vsr = Vbar - conKT2MS(stMo[1])
	srh = (Vsr*dU)-(Usr*dV)
	return srh
}

// Calculate Storm Relative Helicity and derivations within layer  
function calcLyrHelVals(stMo,wnd1,wnd2,inT,inB,hgt) {
	//Total SRH Area
	lyrSRH = calcLyrSRH(stMo,wnd1,wnd2)
	if (lyrSRH>0){
		PlyrSRH = lyrSRH
		NlyrSRH = 0
	}else{
		PlyrSRH = 0
		NlyrSRH = lyrSRH
	}
		
	lyrFxHel = 0
	PlyrFxHel = 0
	NlyrFxHel = 0
	if (inB < 2000 && hgt >= inB && hgt < inT){
		PlyrFxHel = PlyrSRH
		NlyrFxHel = NlyrSRH
	}
	
	// Streamwise Vorticity of Shear Vector wrt Storm Motion (right hand rule)
	rad = findAngle(wnd2,wnd1,stMo)
	ang = rad * (180/Math.PI)
	if(!isNaN(ang)){
		if(ang <= 90){
			swratio = ang/90
		}else{
			swratio = (180-ang)/90
		}
	}else{
		swratio = 0
	}
	
	//Area of Streamwise Helicity 
	PlyrHelSw = PlyrSRH*swratio
	NlyrHelSw = NlyrSRH*swratio
	//Area of Streamwise Helicity Within Effective Inflow Layer
	PlyrHelFxSw = PlyrFxHel*swratio
	NlyrHelFxSw = NlyrFxHel*swratio
	
	return [[PlyrSRH,PlyrFxHel,PlyrHelSw,PlyrHelFxSw,swratio],[NlyrSRH,NlyrFxHel,NlyrHelSw,NlyrHelFxSw,swratio]]
}

//Calculates the integrated Helicity at notable levels
function hodoHelicity(stMo){
	//Have to store positive and negative separate or SW% can go above 100%
	totHelDat = [[0,0,0,0,0],[0,0,0,0,0]]
		
	inT = parseInt(document.getElementById("EFFT").innerHTML)
	inB = parseInt(document.getElementById("EFFB").innerHTML)
	
	// Integrate thru lower atmosphere and total Helicity
	for(var z=0;atmZ[z+1]<6000;z++){
		// Close out SFC to 500m Values
		if (atmZ[z]<500 && atmZ[z+1]>=500){
			HelDat05 = []
			wnd2 = interpLvl('WND',500,'AGL')
			lyrHelDat = calcLyrHelVals(stMo,atmWND[z],wnd2,inT,inB,500)
			for(var y=0;y<2;y++){
				partHel =[]
				for (var x=0;x<4;x++){partHel.push(totHelDat[y][x]+lyrHelDat[y][x])}
				HelDat05.push(partHel)
			}
		}
		// Close out SFC to 1000m Values
		if (atmZ[z]<1000 && atmZ[z+1]>=1000){
			HelDat1 = []
			wnd2 = interpLvl('WND',1000,'AGL')
			lyrHelDat = calcLyrHelVals(stMo,atmWND[z],wnd2,inT,inB,1000)
			for(var y=0;y<2;y++){
				partHel =[]
				for (var x=0;x<4;x++){partHel.push(totHelDat[y][x]+lyrHelDat[y][x])}
				HelDat1.push(partHel)
			}
		}
		// Close out SFC to 3000m Values
		if (atmZ[z]<3000 && atmZ[z+1]>=3000){
			HelDat3 = []
			wnd2 = interpLvl('WND',3000,'AGL')
			lyrHelDat = calcLyrHelVals(stMo,atmWND[z],wnd2,inT,inB,3000)
			for(var y=0;y<2;y++){
				partHel =[]
				for (var x=0;x<4;x++){partHel.push(totHelDat[y][x]+lyrHelDat[y][x])}
				HelDat3.push(partHel)
			}
		}
		// Running Total of Helicities
		lyrHelDat = calcLyrHelVals(stMo,atmWND[z],atmWND[z+1],inT,inB,atmZ[z])
		for(var y=0;y<2;y++){
			for (var x=0;x<4;x++){
				totHelDat[y][x] = totHelDat[y][x]+lyrHelDat[y][x]
			}
		}
	}
	
	dispHelTable(HelDat05,1)
	dispHelTable(HelDat1,2)
	dispHelTable(HelDat3,3)	
	
	//Display Effective Storm Relative Helicity for Tornado Specs
	esrh = Math.round(HelDat05[0][1] + HelDat05[1][1])
	document.getElementById("tblFCll").rows[1].cells[4].innerHTML = esrh
	fmtCell(document.getElementById("tblFCll").rows[1].cells[4],esrh,'srh05')
	
	//Streamwise Vorticity:  To Calculate % SW divide total SW SRH(index:2) by total SRH(index:0)
	if(HelDat05[0][2]>0){pos=(HelDat05[0][2]/HelDat05[0][0])}else{pos=0}
	if(HelDat05[1][2]>0){neg=(HelDat05[1][2]/HelDat05[1][0])}else{neg=0}
	swRatio = pos + neg
	eesrh = Math.round(HelDat05[0][3] + HelDat05[1][3])
	document.getElementById("tblFCll").rows[1].cells[3].innerHTML = swRatio.toFixed(2)
	fmtCell(document.getElementById("tblFCll").rows[1].cells[3],eesrh,'srh05')
}

//Displays the Helicity values in the Helicity table
function dispHelTable(dat,r){
	var x=document.getElementById("tblHel").rows[r].cells
	if(r==2){fmtScheme='srh1'}else if(r==3){fmtScheme='srh3'}else{fmtScheme='srh05'}
	for (var c=0;c<4;c++){
		x[c+1].innerHTML = Math.round(dat[0][c]+dat[1][c])
		fmtCell(x[c+1], dat[0][c]+dat[1][c], fmtScheme)
		if (c==2){
			if(dat[0][c]>0){pos=(dat[0][c]/dat[0][0])}else{pos=0}
			if(dat[1][c]>0){neg=(dat[1][c]/dat[1][0])}else{neg=0}
			swRatio = pos + neg
			x[c+1].innerHTML = swRatio.toFixed(2)
			fmtCell(x[c+1], dat[0][3]+dat[1][3], fmtScheme)
		}		
	}
}

//Calculates the Storm Relative Flow Dynamics at levels of interest
function stormRelFlows(stMo){
	inT = parseInt(document.getElementById("EFFT").innerHTML)
	inB = parseInt(document.getElementById("EFFB").innerHTML)
	
	stmHgt = defStormHeights()
	
	//SURFACE
	sfcSRW = [atmWND[0][0]-stMo[0],atmWND[0][1]-stMo[1]]
	dispKnots(document.getElementById("tblSRFlo").rows[1].cells[1],UVwndDisp(sfcSRW)[1],'srsfc')
	dispKnots(document.getElementById("tblFCsc").rows[1].cells[3],UVwndDisp(sfcSRW)[1],'srsfc')
	
	//INFLOW (Pressure/CAPE/SRW weighted)
	WTtotal = 0
	//Total pressure within inflow layer with CAPE/4 and SRW/6
	for (var z=0;atmZ[z]<inT;z++){
		lvlSRW = getDirSp([atmWND[z][0]-stMo[0],atmWND[z][1]-stMo[1]])
		if(atmZ[z]>=inB){WTtotal=WTtotal+atmP[z]+((atmEnDAT[z][4]/4)*(lvlSRW[1]/6))}
	}
	uAvg = 0
	vAvg = 0
	// Calculate the average using pressure weighting
	for (var z=0;atmZ[z]<inT;z++){
		lvlSRW = getDirSp([atmWND[z][0]-stMo[0],atmWND[z][1]-stMo[1]])
		if(atmZ[z]>=inB){
			wtLvl = atmP[z]+((atmEnDAT[z][4]/4)*(lvlSRW[1]/6))
			uAvg = uAvg + (atmWND[z][0] * wtLvl/WTtotal)
			vAvg = vAvg + (atmWND[z][1] * wtLvl/WTtotal)
		}	
	}
	//Pressure/CAPE/SRW Weighted Inflow
	wndInflow = [uAvg-stMo[0],vAvg-stMo[1]]
	dispKnots(document.getElementById("tblSRFlo").rows[0].cells[1],UVwndDisp(wndInflow)[1],'srif')
	
	//HAIL GROWTH ZONE (pressure weighted)
	Ptotal = 0
	//Total pressure within hail growth zone
	for (var z=0;atmT[z]>-30;z++){
		if(atmT[z]<=-10){Ptotal=Ptotal+atmP[z]}
	}
	uAvg = 0
	vAvg = 0
	// Calculate the average using pressure weighting
	for (var z=0;atmT[z]>-30;z++){
		if(atmT[z]<=-10){
			uAvg = uAvg + (atmWND[z][0] * atmP[z]/Ptotal)
			vAvg = vAvg + (atmWND[z][1] * atmP[z]/Ptotal)
		}	
	}
	//Pressure Weighted Hail Growth Zone SRW
	hgzSRW = [uAvg-stMo[0],vAvg-stMo[1]]
	//dispKnots(document.getElementById("tblSRFlo").rows[1].cells[3],UVwndDisp(hgzSRW)[1],'null')
	dispKnots(document.getElementById("tblGRenv").rows[3].cells[4],UVwndDisp(hgzSRW)[1],'null')

	//MUEL EXHAUST (Height Weighted from 65%MUEL to MUEL)
	wndZwt = wndAvgHgtWt(stmHgt[1],stmHgt[0])
	
	//Height Weighted Exhaust vs Storm Motion
	wndExhaust = [wndZwt[0]-stMo[0],wndZwt[1]-stMo[1]]
	dispKnots(document.getElementById("tblSRFlo").rows[1].cells[3],UVwndDisp(wndExhaust)[1],'null') 
	fmtCell(document.getElementById("tblSRFlo").rows[1].cells[3],UVwndDisp(wndExhaust)[1],'srexh')
	dispKnots(document.getElementById("tblRain").rows[1].cells[3],UVwndDisp(wndExhaust)[1],'null') 
	fmtCell(document.getElementById("tblRain").rows[1].cells[3],UVwndDisp(wndExhaust)[1],'srexh')

	//Microburst Table Displays
	calcLfsSrw()
	calcStormCon()
	calcMicroburstEnv()
}

// Calculates the height weighted average wind in a layer
function wndAvgHgtWt(Zini,Zend){
	Ztotal = 0
	//Total heights from storm starting point to end point
	for (var z=0;atmZ[z]<=Zend;z++){
		if(atmZ[z]>=Zini){Ztotal=Ztotal+atmZ[z]}	
	}
	uAvg = 0
	vAvg = 0
	// Calculate the average using height weighting
	for (var z=0;atmZ[z]<=Zend;z++){
		if(atmZ[z]>=Zini){
			uAvg = uAvg + (atmWND[z][0] * atmZ[z]/Ztotal)
			vAvg = vAvg + (atmWND[z][1] * atmZ[z]/Ztotal)
		}	
	}
	return [uAvg,vAvg]
}

// Calculates the pressure weighted average wind in a layer
function wndAvgPressWt(Pini,Pend){
	Ptotal = 0
	//Total pressures from storm starting point to end point
	for (var z=0;atmP[z]>=Pend;z++){
		if(atmP[z]<=Pini){Ptotal=Ptotal+atmP[z]}
	}
	uAvg = 0
	vAvg = 0
	//document.getElementById("divtest").innerHTML = uAvg
	// Calculate the average using pressure weighting
	for (var z=0;atmP[z]>=Pend;z++){
		if(atmP[z]<=Pini){
			uAvg = uAvg + (atmWND[z][0] * atmP[z]/Ptotal)
			vAvg = vAvg + (atmWND[z][1] * atmP[z]/Ptotal)
			//document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML + uAvg + "<br>"
		}	
	}
	return [uAvg,vAvg]
}

// Change the To From Direction Symbyote  
function gotFromDir() {
	fDir = parseInt(document.getElementById("smF").value)
	if (isNaN(fDir)){fDir = 0}
	fDir = Math.round(fDir/10)*10
	document.getElementById("smF").value = getDispDDD(fDir)
	document.getElementById("smT").value = getDispDDD(fDir+180)
	calcHodoVals()
}
function gotToDir() {
	fDir = parseInt(document.getElementById("smT").value)
	if (isNaN(fDir)){fDir = 0}
	fDir = Math.round(fDir/10)*10
	document.getElementById("smT").value = getDispDDD(fDir)
	document.getElementById("smF").value = getDispDDD(fDir+180)
	calcHodoVals()
}

// Button the estimates the flow of Left/Right moving supercell thunderstorms the generates new table
function calcSplitMove(stMo){	
	if (document.getElementById("smAM").checked){
		newFlow = stMo
	}else{
		// Get splitting cell vector direction
		stMoDirSp = getDirSp(stMo)
		if(document.getElementById("smLM").checked){
			DDV = stMoDirSp[0] - 90
			if(DDV<0){DDV=DDV+360}
		}else if (document.getElementById("smRM").checked){
			DDV = stMoDirSp[0] + 90
			if(DDV>360){DDV=DDV-360}
		}
		// Add splitting cell vector to current storm motion vector to get new storm motion vector
		pt2 = getWndUV(DDV,14.6)
		newFlow = [stMo[0]+pt2[0],stMo[1]+pt2[1]]
	}
	return newFlow
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Skew-T Level Interrogation Popup Box
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Obtain Relative Position on skew-t where user clicked for more info
function getPosition(el) {
  var xPos = 0;
  var yPos = 0;
 
  while (el) {
    if (el.tagName == "BODY") {
      // deal with browser quirks with body/window/document and page scroll
      var xScroll = el.scrollLeft || document.documentElement.scrollLeft;
      var yScroll = el.scrollTop || document.documentElement.scrollTop;
 
      xPos += (el.offsetLeft - xScroll + el.clientLeft);
      yPos += (el.offsetTop - yScroll + el.clientTop);
    } else {
      // for all other non-BODY elements
      xPos += (el.offsetLeft - el.scrollLeft + el.clientLeft);
      yPos += (el.offsetTop - el.scrollTop + el.clientTop);
    }
 
    el = el.offsetParent;
  }
  return {
    x: xPos,
    y: yPos
  };
}

//Event Executes Level Interrogation Popup
function getClickPosition(e){
	var parentPosition = getPosition(e.currentTarget);
    var yPosition = e.clientY - parentPosition.y
		
	press = Math.round(y2Press(yPosition))
	dispLevelWx(press)
}

//Positions Popup window to declutter relative to data 
function dispLvelWxTable(p,x1,x2){
	var calTbl = document.getElementById("mcInterrogate").style
	calTbl.visibility = "visible"

	var yVal = coordY(p)
	yTop = yVal - 285
	if (yTop<30){yTop = yVal + 50}
	calTbl.top = yTop

	xLeft = x2 + 25
	if (xLeft>700){xLeft = x1 - 150}
	if (xLeft<5){xLeft = x1 + 25}
	calTbl.left = xLeft	
}

//Calculates/Interpolates Parameters and Displays in Popup Table 
function dispLevelWx(p){
	refreshDisplay()
	
	if (p > atmP[0]){p=atmP[0]}
		
	agl = interpLvl('AGL',p,'P')
	t = interpLvl('T',p,'P')
	dp = interpLvl('DP',p,'P')
	rh = interpLvl('RH',p,'P')
	wb = interpLvl('WB',p,'P')
	wind = interpLvl('WND',p,'P')
	dispWind = UVwndDisp(wind)
	mxr = Ws(dp,p)
	smxr = Ws(t,p)
	th = DALRtheta(t,p)
	the = calcThetaE(p,t,dp)
			
	document.getElementById("iLp").innerHTML = p + ' mb'
	document.getElementById("iLagl").innerHTML = Math.round(agl) + ' m ; ' + Math.round(conM2FT(agl)) + ' ft'
	document.getElementById("iLmsl").innerHTML = Math.round(agl + profDat[iHR][0][1]) + ' m ; ' + Math.round(conM2FT(agl + profDat[iHR][0][1])) + ' ft'
	document.getElementById("iLt").innerHTML = Math.round(t*10)/10 + ' &deg;C ; ' + Math.round(conC2F(t)) + ' &deg;F'
	document.getElementById("iLdp").innerHTML = Math.round(dp*10)/10 + ' &deg;C ; ' + Math.round(conC2F(dp)) + ' &deg;F'
	document.getElementById("iLwnd").innerHTML = dispWind[0]+"<b> | </b>"+dispWind[1]
	document.getElementById("iLrh").innerHTML = Math.round(rh*10)/10 + ' %'
	document.getElementById("iLwb").innerHTML = Math.round(wb*10)/10 + ' &deg;C'
	document.getElementById("iLw").innerHTML = Math.round(mxr*10)/10 + ' g/Kg'
	document.getElementById("iLws").innerHTML = Math.round(smxr*10)/10 + ' g/Kg'
	document.getElementById("iLth").innerHTML = Math.round(th*10)/10 + ' &deg;C ; ' + Math.round((273.15+th)*10)/10 + ' &deg;K'
	document.getElementById("iLthe").innerHTML = Math.round(the*10)/10 + ' &deg;C ; ' + Math.round((273.15+the)*10)/10 + ' &deg;K'
	
	x1 = coordX(dp,p) - 50
	x2 = coordX(t,p) + 50
	
	//document.getElementById("divtest").innerHTML = "x2: " + x2 + "t: " + t +"p: " + p	
	dispLvelWxTable(p,x1,x2)
	dispLvlLine(p,x1,x2)
	dispLevelOnHodo(wind)
}

// Marks the highlighted level on the hodograph for reference
function dispLevelOnHodo(lvlWnd){
	var hodo = document.getElementById("hodoCanvas");
	var ctx = hodo.getContext("2d");
		
	if (document.getElementById("srHodo").checked){
		srX = -1 * HOPXEXPAN * stMo[1]
		srY = 1 * HOPXEXPAN * stMo[0]
	}else{
		srX = 0
		srY = 0	
	}
	
	ctx.lineWidth = 2;
	ctx.strokeStyle = 'gray';
	ctx.fillStyle = 'gray';
	ctx.font = "11px Arial";
	ctx.setLineDash([])	
	//Sizing Window
	L = HODOSZ
	MP = HODOSZ/2
	//Hodograph X,Y coordinate System x = -v; y = -u
	hy = 1 * HOPXEXPAN * lvlWnd[0] - srY
	hx = -1 * HOPXEXPAN * lvlWnd[1] - srX
	ctx.beginPath();
	ctx.arc(MP+hx,MP+hy,10,0,6.3);
	ctx.rect(MP+hx-2,MP+hy-2,4,4)
	ctx.stroke();
}

// User Query Level Line displayed on Skew-T for reference
function dispLvlLine(p,x1,x2){
	var c = document.getElementById("skewtCanvas");
	var ctx = c.getContext("2d");
	ctx.strokeStyle = 'gray';
	ctx.fillStyle = 'gray';
	ctx.lineWidth = 2;
	ctx.setLineDash([3,3])
	y = coordY(p)
	ctx.beginPath();
	ctx.moveTo(x1,y);
	ctx.lineTo(x2,y);
	ctx.stroke();
}

//Clears the popup table
function clrLvlView() {
	document.getElementById("mcInterrogate").style.visibility ="hidden"
	refreshDisplay()
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Skew-T and Hodograph Editor 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Display the Editor Table
function viewEditor(){
	var calTbl = document.getElementById("mcEditor").style
	calTbl.visibility = "visible"
	calTbl.top = 30
	calTbl.left = 50
	iniEditor()
}

// Populate Editor Table 
function iniEditor(){
	//Clear Table
	for (var z=0;z<35;z++){
		document.getElementById("P"+(z)).innerHTML = ''
		document.getElementById("T"+(z)).value = ''
		document.getElementById("DP"+(z)).value = ''
		document.getElementById("WD"+(z)).value = ''
		document.getElementById("WS"+(z)).value = ''
	}
	//Input values into table
	for (var z=0;z<atmP.length-1;z++){
		document.getElementById("P"+(z)).innerHTML = atmP[z]
		document.getElementById("T"+(z)).value = atmT[z]
		document.getElementById("DP"+(z)).value = atmDP[z]
		wnd = UVwndVals(atmWND[z])
		document.getElementById("WD"+(z)).value = wnd[0]
		document.getElementById("WS"+(z)).value = wnd[1]
		if (z>=34){break}
	}
}

//Blend Surface Temp Correction into a mixed atmosphere
function smoothEdit(){
	t = parseFloat(document.getElementById("T0").value)
	th = DALRtheta(t,atmP[0])
	thLvl = DALRtheta(atmT[1],atmP[1])
	for (var z=1;thLvl<th;z++){
		t = DALRtemp(th,atmP[z])
		document.getElementById("T"+(z)).value = Math.round(t*10)/10
		thLvl = DALRtheta(atmT[z+1],atmP[z+1])
	}
	applyEditor()
}

// Alter temperature values and apply updates
function applyEditor(){
	for (var z=0;z<atmP.length-1;z++){
		t = parseFloat(document.getElementById("T"+(z)).value)
		dp = parseFloat(document.getElementById("DP"+(z)).value)
		if (dp>t){dp=t}
		rh = Math.round(1000*ES(dp)/ES(t))/10
		atmT[z] = t
		atmDP[z] = dp
		atmRH[z] = rh
		wb = getWetBulbTemp(z)
		atmWB[z] = wb
		ddd = parseFloat(document.getElementById("WD"+(z)).value)
		ss = parseFloat(document.getElementById("WS"+(z)).value)
		atmWND[z] = getWndUV(ddd,ss)
		if (z>=34){break}
	}
	newProfDisplay()
}

// Remove the Editor Table from display
function clrEditor(){
	document.getElementById("mcEditor").style.visibility = "hidden"
}

// Display the Hodograph Effective Inflow Editor Table
function viewEditEIFL(){
	var calTbl = document.getElementById("mcEditEIFL").style
	calTbl.visibility = "visible"
	calTbl.top = 35
	calTbl.left = 955
}

function clrEIFLedit(){
	document.getElementById("mcEditEIFL").style.visibility = "hidden"
	iniHodograph()
}

//Calculate Hot Dry Windy Index
function calcHDW(){
	vpd = ((ES(atmT[0])-ES(atmDP[0])) + (ES(atmT[1])-ES(atmDP[1])))/2
	wnd = wndAvgPressWt(atmP[0],interpLvl("P",1524,"AGL"))
	mps = conKT2MS(UVwndDisp(wnd)[1])
	hdw = vpd * mps
	return [hdw,vpd,mps]
}

function autoVIV(){
	icao = document.getElementById("manICAO").value.toUpperCase()
	for(i=0;i<obsDat.length;i++){if(icao==obsDat[i][0]){break}}
	vt = validTimes[iHR].replace(' - ','<br>')
	for(t=0;t<fcstHrs.length;t++){if(vt==fcstHrs[t]){break}}
	atmT[0] = obsDat[i][1][t]
	atmDP[0] = obsDat[i][2][t]
	sfcDDDSS = obsDat[i][3][t].slice(0,6).split('|')
	atmWND[0] = getWndUV(sfcDDDSS[0],sfcDDDSS[1])
	newProfDisplay()
	
}

function compObs(){
	document.getElementById("btnVIV").style.visibility = "hidden";
	icao = document.getElementById("manICAO").value.toUpperCase()
	for(i=0;i<obsDat.length;i++){if(icao==obsDat[i][0]){break}}
	if (i<obsDat.length-1){
		vt = validTimes[iHR].replace(' - ','<br>')
		for(t=0;t<fcstHrs.length;t++){if(vt==fcstHrs[t]){break}}
		
		if (t < obsDat[i][1].length){
			vivT = obsDat[i][1][t]
			var c = document.getElementById("skewtCanvas");
			var ctx = c.getContext("2d");
			ctx.strokeStyle = 'black';
			ctx.fillStyle = 'black';
			ctx.font = "11px Arial";
			ctx.lineWidth = 1;
			ctx.setLineDash([])
			
			vivT = obsDat[i][1][t]
			yT = coordY(atmP[0]) 
			xT = coordX(vivT,atmP[0]) 
			ctx.beginPath();
			ctx.moveTo(xT, yT);
			ctx.lineTo(xT, yT+10);
			ctx.fillText("VIV-T", xT-12, yT+22);
			ctx.stroke();
			
			vivDP = obsDat[i][2][t]
			xDP = coordX(vivDP,atmP[0]) 
			ctx.beginPath();
			ctx.moveTo(xDP, yT);
			ctx.lineTo(xDP, yT+10);
			ctx.fillText("VIV-Td", xDP-13, yT+22);
			ctx.stroke();
			document.getElementById("btnVIV").style.visibility = "visible";
		}
	}
	
	
		
	/*
		ctx.strokeStyle = 'gray';
	ctx.fillStyle = 'black';
	ctx.font = "13px Arial";
	ctx.lineWidth = 1;
	ctx.setLineDash([])
	for (var i=0;i<Temps.length;i++){
		x1 = coordX(Temps[i],pStart)
		y1 = coordY(pStart)
		x2 = coordX(Temps[i],50)
		y2 = coordY(50)
		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.fillText(Temps[i], x1, HT-1);
		ctx.stroke();	
	
		//Draw Dew Point Mixing Ratio to the LCL 
	dpt0 = interpLvl("DP",parP[0],"P")
	//Exception for ML parcel (find
	if (iPARCEL == atmEnDAT.length-1){
		dpt0 = mxratio(Ws(parT[iLCL],parP[iLCL]),parP[0])
	}
	ctx.lineWidth = 1
	ctx.strokeStyle = '#537827'
	ctx.setLineDash([])
	ctx.beginPath();
	y1 = coordY(parP[0])
	x1 = coordX(dpt0,parP[0]) 
	ctx.moveTo(x1, y1);
	y2 = coordY(parP[iLCL])
	x2 = coordX(parT[iLCL],parP[iLCL])
	ctx.lineTo(x2,y2)
	ctx.stroke()
	document.getElementById("divtest").innerHTML = validTimes[iHR].replace(' - ','<br>')  
	document.getElementById("divtest").innerHTML = document.getElementById("divtest").innerHTML +'<BR>' + fcstHrs[0]
	document.getElementById("divtest").innerHTML = "test HDW"
	hdw = calcHDW()
	document.getElementById("divtest").innerHTML = hdw
	*/
}
//document.getElementById("divtest").innerHTML = "LCL"



</script>	
	
</head>
<body onLoad="startUpDoc()">
<table width="98%" border=0>
<tr>
	<td>
		<select onchange="changeLmarg()" name="lmargParam" id="lmargParam" style="font-size: 8pt"> 
			<option value="mAGL">mAGL</option>
			<option value="ftAGL">ftAGL</option>
			<option value="mMSL">mMSL</option> 
			<option value="ftMSL">ftMSL</option>
			<option value="RH">RH</option> 
			<option value="Temp">Temp</option> 
			<option value="Theta">Theta</option> 
			<option value="ThetaE">ThetaE</option> 
			<option value="Press">Press</option> 
		</select>

	</td>
	<td> 
	<button class="btn btn-primary" id="loadMap" onClick="viewMapLoad()">Map</button> &nbsp; 
	<input size="2" type="text" id="manICAO" value="KDMA">
	<button class="btn btn-primary" id="loadICAO" onClick="loadCSV()">Load</button> &nbsp; &nbsp; 
	<script>
	var input = document.getElementById("manICAO");
	input.addEventListener("keypress", function(event){
		if (event.key==="Enter"){
			event.preventDefault();
			document.getElementById("loadICAO").click();
		}
	});
	</script>
	<input type="button" onclick="getObsMetar()" value="Obs/METAR">

	Tools: 
	<div class="tooltip"><img class="btn btn-primary" onClick="viewMxTx()" src="img/ncw_btn.png" height=20>	<span class="tooltiptext"><br><br>Winds</span></div>
	<div class="tooltip"><img class="btn btn-primary" onClick="viewFog()" src="img/fg_btn.png" height=20>	<span class="tooltiptext"><br><br>Fog</span></div>
	<div class="tooltip"><img class="btn btn-primary" onClick="viewFZpro('Freezing Drizzle')" src="img/fzdz_btn.png" height=20>	<span class="tooltiptext"><br><br>Freezing<br>Drizzle</span></div>
	<div class="tooltip"><img class="btn btn-primary" onClick="viewFZpro('Freezing Rain')" src="img/fzra_btn.png" height=20>	<span class="tooltiptext"><br><br>Freezing<br>Rain</span></div>
	<div class="tooltip"><img class="btn btn-primary" onClick="viewFZpro('Snow')" src="img/sn_btn.png" height=20>	<span class="tooltiptext"><br><br>Snow</span></div>
	<div class="tooltip"><img class="btn btn-primary" onClick="viewRAdisp()" src="img/ra_btn.png" height=20>	<span class="tooltiptext"><br><br>Rain</span></div>
	<div class="tooltip"><img class="btn btn-primary" onClick="viewTSdisp()" src="img/ts_btn.png" height=20>	<span class="tooltiptext"><br><br>Thunderstorms</span></div>
	<div class="tooltip"><img class="btn btn-primary" onClick="viewDCAPE()" src="img/tswind_btn.png" height=20>	<span class="tooltiptext"><br><br>Microburst<br>Winds</span></div>
	<div class="tooltip"><img class="btn btn-primary" onClick="viewHail()" src="img/hail_btn.png" height=20>	<span class="tooltiptext"><br><br>Hail</span></div>
	<div class="tooltip"><img class="btn btn-primary" onClick="viewTorn()" src="img/torn_btn.png" height=20>	<span class="tooltiptext"><br><br>Tornado</span></div>
	<div class="tooltip"><img class="btn btn-primary" onClick="plotCompProf()" src="img/profcomp_btn.png" height=20><span class="tooltiptext"><br><br>Compare<br>Profiles</span></div>
	<div class="tooltip"><img class="btn btn-primary" onClick="viewTurb()" src="img/turb_btn.png" height=20><span class="tooltiptext"><br><br>Turbulence</span></div>
	&nbsp; &nbsp; <span style="font-size: 8pt">Villaran Skew-T v2.54</span>		
	</td>
	<td width="65"></td>
	<td></td>
</tr><tr>
	<td valign="top" width="50">
		<table id="lmarg" style="font-size: 7pt">
			<tr><td>115</td><td></td></tr>
			<tr><td style="padding-top: 20px">125</td><td style="padding-top: 20px"></td></tr>
			<tr><td style="padding-top: 48px">150</td><td style="padding-top: 48px"></td></tr>
			<tr><td style="padding-top: 44px">175</td><td style="padding-top: 44px"></td></tr>
			<tr><td style="padding-top: 40px">200</td><td style="padding-top: 40px"></td></tr>
			<tr><td style="padding-top: 31px">225</td><td style="padding-top: 31px"></td></tr>
			<tr><td style="padding-top: 26px">250</td><td style="padding-top: 26px"></td></tr>
			<tr><td style="padding-top: 23px">275</td><td style="padding-top: 23px"></td></tr>
			<tr><td style="padding-top: 20px">300</td><td style="padding-top: 20px"></td></tr>
			<tr><td style="padding-top: 15px">325</td><td style="padding-top: 15px"></td></tr>
			<tr><td style="padding-top: 14px">350</td><td style="padding-top: 14px"></td></tr>
			<tr><td style="padding-top: 12px">375</td><td style="padding-top: 12px"></td></tr>
			<tr><td style="padding-top: 10px">400</td><td style="padding-top: 10px"></td></tr>
			<tr><td style="padding-top: 10px">425</td><td style="padding-top: 10px"></td></tr>
			<tr><td style="padding-top: 9px">450</td><td style="padding-top: 9px"></td></tr>
			<tr><td style="padding-top: 8px">475</td><td style="padding-top: 8px"></td></tr>
			<tr><td style="padding-top: 7px">500</td><td style="padding-top: 7px"></td></tr>
			<tr><td style="padding-top: 6px">525</td><td style="padding-top: 6px"></td></tr>
			<tr><td style="padding-top: 5px">550</td><td style="padding-top: 5px"></td></tr>
			<tr><td style="padding-top: 4px">575</td><td style="padding-top: 4px"></td></tr>
			<tr><td style="padding-top: 3px">600</td><td style="padding-top: 3px"></td></tr>
			<tr><td style="padding-top: 2px">625</td><td style="padding-top: 2px"></td></tr>
			<tr><td style="padding-top: 2px">650</td><td style="padding-top: 2px"></td></tr>
			<tr><td style="padding-top: 0px">675</td><td style="padding-top: 0px"></td></tr>
			<tr><td style="padding-top: 0px">700</td><td style="padding-top: 0px"></td></tr>
			<tr><td style="padding-top: 1px;padding-bottom: 0px">725</td><td style="padding-top: 1px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 1px;padding-bottom: 0px">750</td><td style="padding-top: 1px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">775</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">800</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">825</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">850</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">875</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">900</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">925</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">950</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">975</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">1000</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">1025</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">1050</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
		</table>
	</td>
	<td valign="top" width="850">
		<canvas id="skewtCanvas" width="850" height="850" style="border:1px solid #d3d3d3; background-color: #DFECFA">
		<script>
			document.getElementById("skewtCanvas").addEventListener("click", getClickPosition, false);
		</script>
	</td>
	<td valign="top" width = "60">
		<table id="rmarg" style="font-size: 7pt">
			<tr><td>115</td><td></td></tr>
			<tr><td style="padding-top: 20px">125</td><td style="padding-top: 20px"></td></tr>
			<tr><td style="padding-top: 48px">150</td><td style="padding-top: 48px"></td></tr>
			<tr><td style="padding-top: 44px">175</td><td style="padding-top: 44px"></td></tr>
			<tr><td style="padding-top: 40px">200</td><td style="padding-top: 40px"></td></tr>
			<tr><td style="padding-top: 31px">225</td><td style="padding-top: 31px"></td></tr>
			<tr><td style="padding-top: 26px">250</td><td style="padding-top: 26px"></td></tr>
			<tr><td style="padding-top: 23px">275</td><td style="padding-top: 23px"></td></tr>
			<tr><td style="padding-top: 20px">300</td><td style="padding-top: 20px"></td></tr>
			<tr><td style="padding-top: 15px">325</td><td style="padding-top: 15px"></td></tr>
			<tr><td style="padding-top: 14px">350</td><td style="padding-top: 14px"></td></tr>
			<tr><td style="padding-top: 12px">375</td><td style="padding-top: 12px"></td></tr>
			<tr><td style="padding-top: 10px">400</td><td style="padding-top: 10px"></td></tr>
			<tr><td style="padding-top: 10px">425</td><td style="padding-top: 10px"></td></tr>
			<tr><td style="padding-top: 9px">450</td><td style="padding-top: 9px"></td></tr>
			<tr><td style="padding-top: 8px">475</td><td style="padding-top: 8px"></td></tr>
			<tr><td style="padding-top: 7px">500</td><td style="padding-top: 7px"></td></tr>
			<tr><td style="padding-top: 6px">525</td><td style="padding-top: 6px"></td></tr>
			<tr><td style="padding-top: 5px">550</td><td style="padding-top: 5px"></td></tr>
			<tr><td style="padding-top: 4px">575</td><td style="padding-top: 4px"></td></tr>
			<tr><td style="padding-top: 3px">600</td><td style="padding-top: 3px"></td></tr>
			<tr><td style="padding-top: 2px">625</td><td style="padding-top: 2px"></td></tr>
			<tr><td style="padding-top: 2px">650</td><td style="padding-top: 2px"></td></tr>
			<tr><td style="padding-top: 0px">675</td><td style="padding-top: 0px"></td></tr>
			<tr><td style="padding-top: 0px">700</td><td style="padding-top: 0px"></td></tr>
			<tr><td style="padding-top: 1px;padding-bottom: 0px">725</td><td style="padding-top: 1px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 1px;padding-bottom: 0px">750</td><td style="padding-top: 1px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">775</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">800</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">825</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">850</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">875</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">900</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">925</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">950</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">975</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">1000</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">1025</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
			<tr><td style="padding-top: 0px;padding-bottom: 0px">1050</td><td style="padding-top: 0px;padding-bottom: 0px"></td></tr>
		</table>
	</td>
	<td valign="top">
		<span id="HODOGRAPH" >
		<canvas id="hodoCanvas" width="550" height="550" style="border:1px solid #d3d3d3; background-color: #DFECFA">
		</span>
		<table width="550" border="1">
			<tr>
				<td valign="top" width="275">
					<table>
						<caption>Storm Motion</caption>
						<tr>
							<td>From:<input size="1" type="text" id="smF" value="270" onFocusOut="gotFromDir()"></td> <td>To: <input size="1" type="text" id="smT" value="090" onfocusout="gotToDir()"></td> 
							<td colspan=2>at: <input size="1" type="text" id="smM" value="10" onFocusOut="calcHodoVals()"> kts</td>
						</tr>
					</table>
					<hr>
					<table width="275" style="font-size: 11pt" id="tblHel">
						<caption>Helicity</caption>
						<tr>
							<td>Layer</th> <td>SRH</td> <td>ESRH</td> <td>SW%</td> <td>ESSRH</td>
						</tr><tr>
							<th>500m</th> <td></td> <td></td> <td></td> <td></td> 
						</tr><tr>
							<th>1 Km</th> <td></td> <td></td> <td></td> <td></td> 
						</tr><tr>
							<th>3 Km</th> <td></td> <td></td> <td></td> <td></td> 
						</tr>
					</table>
				</td><td valign="top">
					<table id="tblShear" width="250" style="font-size: 11pt">
						<tr><th width="100">Shear</th><th width="75">Bulk</th><th width="75">Total</th></tr>
						<tr><td>SFC-6KM</td><td align="center">00</td><td align="center">00</td></tr>
						<tr><td>Effective</td><td align="center">00</td><td align="center">00</td></tr>
						<tr><td>Storm</td><td align="center">00</td><td align="center">00</td></tr>
					</table>
					<table id="tblSRFlo" width="250" style="font-size: 11pt">
						<caption>Storm Relative Flows</caption>
						<tr><td width="75">Inflow</td><td width="50">25</td><td width="75">Exhaust</td><td>25</td></tr>
						<tr><td>Surface</td><td>25</td><td>EL Exh</td><td>25</td></tr>
					</table>
				</td>
			</tr>
		</table>
	</td>
</tr><tr>
	<td>
		<button class="btn btn-primary" onClick="viewEditor()"><img src="img/editor.png" height=15></button>
		<button id="btnVIV" onClick="autoVIV()">VIV</button>
	</td>
	<td align='center' valign="top">
	<button class="btn btn-primary" onClick="nextHR(-6)">-6 HR</button>
	<button class="btn btn-primary" onClick="nextHR(-1)"><- Prior HR</button> &nbsp; 
	<span id='skewtCaption'> Heading Caption </span> &nbsp; 
	<button class="btn btn-primary" onClick="nextHR(1)">Next HR -></button>
	<button class="btn btn-primary" onClick="nextHR(6)">+6 HR</button></td>
	<td></td>
	
	<td><button class="btn btn-primary" onClick="testFunc()">TESTING</button></td>
	
</tr>
</table>



<span id='divtest'> Stand By Test</span>
<!-- ********************************************************************************************************************************************
*************************************************************************************************************************************************
*************************************************************          TOOLS           **********************************************************
*************************************************************************************************************************************************
<!-- *****************************************************************************************************************************************-->
<span id="mcMxTx" class="minicalc" style='visibility: hidden'>
<table>
<tr><td>
	<table id="tblMxTx" border="1" style="color: #E9E9E9;"> 
		<tr><th>AGL</th> <th>Temp</th> <th>&Gamma;</th> <th>DDD</th> <th>SS</th> <th>BTW</th></tr>
		<tr><th>090</th> <td><input size="2" type="text" id="manT1" value="00.0"></td> <td align="center">0.0</td> <td><input size="1" type="text" id="manD1" value="000"></td> <td><input size="1" type="text" id="manS1" value="00"></td> <td align="center"></td></tr>
		<tr><th>070</th> <td><input size="2" type="text" id="manT2" value="00.0"></td> <td align="center">0.0</td> <td><input size="1" type="text" id="manD2" value="000"></td> <td><input size="1" type="text" id="manS2" value="00"></td> <td align="center"></td></tr>
		<tr><th>050</th> <td><input size="2" type="text" id="manT3" value="00.0"></td> <td align="center">0.0</td> <td><input size="1" type="text" id="manD3" value="000"></td> <td><input size="1" type="text" id="manS3" value="00"></td> <td align="center"></td></tr>
		<tr><th>040</th> <td><input size="2" type="text" id="manT4" value="00.0"></td> <td align="center">0.0</td> <td><input size="1" type="text" id="manD4" value="000"></td> <td><input size="1" type="text" id="manS4" value="00"></td> <td align="center"></td></tr>
		<tr><th>030</th> <td><input size="2" type="text" id="manT5" value="00.0"></td> <td align="center">0.0</td> <td><input size="1" type="text" id="manD5" value="000"></td> <td><input size="1" type="text" id="manS5" value="00"></td> <td align="center"></td></tr>
		<tr><th>020</th> <td><input size="2" type="text" id="manT6" value="00.0"></td> <td align="center">0.0</td> <td><input size="1" type="text" id="manD6" value="000"></td> <td><input size="1" type="text" id="manS6" value="00"></td> <td align="center"></td></tr>
		<tr><th>010</th> <td><input size="2" type="text" id="manT7" value="00.0"></td> <td align="center">0.0</td> <td><input size="1" type="text" id="manD7" value="000"></td> <td><input size="1" type="text" id="manS7" value="00"></td> <td align="center"></td></tr>
		<tr><th>005</th> <td><input size="2" type="text" id="manT8" value="00.0"></td> <td align="center">0.0</td> <td><input size="1" type="text" id="manD8" value="000"></td> <td><input size="1" type="text" id="manS8" value="00"></td> <td align="center"></td></tr>
		<tr><th>SFC</th> <td><input size="2" type="text" id="manT9" value="00.0"></td> <td style="color: #464F4E">-00.0</td> <td><input size="1" type="text" id="manD9" value="000"></td> <td><input size="1" type="text" id="manS9" value="00"></td>  <td style="color: #464F4E"> <input type="button" onclick="mixDown()" value="Mix"></td></tr>
		<tr><th colspan="3">Downward<br>Forcing</th> <td colspan="3" align="center"><input size="1" type="text" id="manDF" value="00">%</td></tr>
	</table>
</td><td align="center">
	<table id="dispMxTx" border="1" style="color: #E9E9E9;"> 
		<tr><th>maxBTW</th> <td>00</td> <th>maxFTW</th> <td>00</td> </tr>
		<tr><th>mixBTW</th> <td>00</td> <th>mixFTW</th> <td>00</td> </tr>
		<tr><th colspan="4">Momentum Transfer</th></tr>
		<tr><th colspan="4">00</th></tr>
	</table>
	<br> <br>
	<input type="button" onclick="updateMxTxTbl()" value="Calculate">
	<br> <br>
	<input type="button" onclick="clrMxTx()" value="Close">

</td></tr>
</table>
</span>
<!-- ************************************************************** Freezing Drizzle Monitor *********************************************-->
<span id="mcFZpro" class="minicalc" style='visibility: hidden'>
	<table id="tblAccum" border="1" style="color: #E9E9E9;font-size: 14px">
		<caption>Accumulation</caption>
		<tr><th>Method</th> <th>SLR</th> <th>Tot</th> </tr>
		<tr><td>Villaran</td> <td align="center" id="slrV">00.0</td> <td align="center" id="snV">0.0"</td> </tr>
		<tr><td>Kuchera</td> <td align="center" id="slrK">00.0</td> <td align="center" id="snK">0.0"</td> </tr>
		<tr><td>AFMAN </td> <td align="center" id="slrA">00.0</td> <td align="center" id="snA">0.0"</td> </tr>
		<tr><td colspan='2'>Liq Eq Precip</td> <td align="center"><input size="1" type="text" id="manLiqPrecip" value="0.0" onFocusOut="updateSNtot()">"</td> </tr>
	</table>
	<script>
	var input = document.getElementById("manLiqPrecip");
	input.addEventListener("keypress", function(event){
		if (event.key==="Enter"){
			event.preventDefault();
			updateSNtot()
		}
	});
	</script>
	<hr>
	<table id="tblFZpro" border="1" style="color: #E9E9E9;font-size: 14px">
		<caption>Freezing Profile</caption>
		<tr><th>AGL</th> <th>Temp</th> <th>T<sub>dp<sub></th> <th>RH%</th> </tr>
		<tr><th>200</th>  <td></td>  <td></td>  <td></td> </td> </tr> 
		<tr><th>170</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>140</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>110</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>090</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>070</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>050</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>040</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>030</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>025</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>020</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>015</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>010</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>005</th>  <td></td>  <td></td>  <td></td> </td> </tr>
		<tr><th>SFC</th>  <td></td>  <td></td>  <td></td> </td> </tr>
	</table>
	<p align="center">
		<input type="button" onclick="clrFZDZ()" value="Close">
	</p>
</span>
<!-- ************************************************************** Hail *********************************************-->
<!-- Hail Parameters -->
<span id="mcHail" class="minicalc" style='visibility: hidden'>
<table id="tblGRemb" border="1" style="color: #E9E9E9; font-size: 13px;">
	<caption>Hail Embryo Residence</caption>
	<tr class="tbldk"><th width="25">Lyr</th> <th width="50" style="font-size: 11px;">w-ECAPE</th> <th width="50">w-CAPE</th> <th width="50" style="font-size: 11px;">LFC-FZ</th> <th width="50">w-RH%</th> <th width="50">Inflow</th> </tr> 
	<tr class="tbllt"><th>MU</th> <td align="center">j/kg</td> <td align="center">km</td> <td align="center">j/kg</td> <td align="center">%</td> <td align="center">kts</td> </tr> 
	<tr class="tbllt"><th>SFC</th> <td align="center">j/kg</td> <td align="center">km</td> <td align="center">j/kg</td> <td align="center">%</td> <td align="center">kts</td> </tr>
</table>
<hr />
<table id="tblGRpot" border="1" style="color: #E9E9E9; font-size: 13px;">
	<caption>Hail Growth Potential</caption>
	<tr class="tbldk"><th width="25">Lyr</th> <th width="50">ECAPE</th> <th width="50" style="font-size: 11px;">FZL-MPL</th> <th width="50">CAPE</th> <th width="50" style="font-size: 11px;">FZL-MPL</th> <th  width="50">RH</th> </tr> 
	<tr class="tbllt"><th>MU</th> <td align="center">j/kg</td> <td align="center">km</td> <td align="center">j/kg</td> <td align="center">km</td> <td align="center">%</td></tr> 
	<tr class="tbllt"><th>SFC</th> <td align="center">j/kg</td> <td align="center">km</td> <td align="center">j/kg</td> <td align="center">km</td> <td align="center">%</td></tr> 
</table>
<hr />
<table id="tblGRenv" border="1" style="color: #E9E9E9; font-size: 13px;">
	<caption>Hail Environment Specs</caption>
	<tr class="tbldk"> <th width="55">Eff BS</th> <th width="55">Shr Line</th> <th width="55">1/1-6%</th> <th width="55">BWD1-6</th>  <th width="55">BWD1-12</th> </tr> 
	<tr class="tbllt"> <td align="center"></td> <td align="center"></td> <td align="center"></td> <td align="center"></td>  <td align="center"></td></tr>
	<tr class="tbldk"> <th>WBZ</th> <th>FZ LVL</th> <th>PWI</th> <th width="55">&Gamma;<sub>HGZ</sub></th> <th width="55">SRW<sub>HGZ</sub></th> </tr> 
	<tr class="tbllt"> <td align="center" style="color: #470052; font-weight: bold"></td> <td align="center" style="color: #470052; font-weight: bold"></td> <td align="center"></td> <td align="center"></td> <td align="center"></td></tr> 
</table>
	<center><input type="button" onclick="viewHailGraph()" value="Graph"> - - <input type="button" onclick="clrHailview()" value="Close"></center>
</span>
<span id="mcHailGraph" class="minicalc" style='visibility: hidden'>
	<canvas id="grGraphCanvas" width="475" height="450" style="border:1px solid #d3d3d3; background-color: #DFECFA"></canvas><br>
	<center>
	<input type="radio" id="grGraphEnv" name="grGraph" value="HailEnv" onchange="bgHailGraph()" checked>
		<label for="HailEnv">Hail Environment</label> 
	<input type="radio" id="grGraphWcape" name="grGraph" value="wCAPE" onchange="bgHailGraph()" >
		<label for="wCAPE">wCAPE vs 0-1 Kine</label>  
	<input type="radio" id="grGraphSize" name="grGraph" value="sizeDepth" onchange="bgHailGraph()" >
		<label for="sizeDepth">Hail Size vs Depth</label>
	</center>
</span>
<!-- ************************************************************** Tornado Monitor *********************************************-->
<span id="mcTorn" class="minicalc" style='visibility: hidden;'>
<table id="tblFCup" border="1" style="color: #E9E9E9; font-size: 13px;">
	<caption>Updraft Energy</caption>
	<tr class="tbldk"><th width="30"></th> <th width="55">CIN</th> <th width="55">CAPE</th> <th width="55">ECAPE</th> <th width="55">&#1121;<sub>max</sub> </th>  </tr>
	<tr class="tbllt"><th>SFC</th>  <td align="center"></td>  <td align="center"></td>  <td align="center"></td> <td align="center"></td></tr>
	<tr class="tbllt"><th>ML</th>  <td align="center"></td>  <td align="center"></td>  <td align="center"></td> <td align="center"></td></tr>
</table>
<table id="tblFCsc" border="1" style="color: #E9E9E9; font-size: 13px;">
	<caption>Tornadic Supercell Parameters</caption>
	<tr class="tbldk"><th width="50">SCP</th>  <th width="50">STP</th>  <th width="50">Eff BS</th>  <th width="50">SRW<sub>sfc</sub></th> <th width="50">Hgt<sub>LCL<sub></th> </tr> 
	<tr class="tbllt"><td align="center"></td> <td align="center"></td> <td align="center"></td> <td align="center"></td> <td align="center"></td></tr>
</table>
<table id="tblFCll" border="1" style="color: #E9E9E9; font-size: 13px;">
	<caption>Low-Level Shear Parameters</caption>
	<tr class="tbldk"><th width="50">1/1-6%</th>  <th width="50">BWD0-1</th>  <th width="50">BWD0-3</th>  <th width="50">SW Vort</sub></th> <th width="50">ESRH<sub>0.5</sub></th> </tr>
	<tr class="tbllt"><td align="center"></td> <td align="center"></td> <td align="center"></td> <td align="center"></td> <td align="center"></td></tr>
</table>
<center><input type="button" onclick="clrTornview()" value="Close"></center>
</span>
<!-- ************************************************************** Thunderstorms Parcel Level  *********************************************-->
<span id="mcParcel" class="minicalc" style='visibility: hidden;'>
<table id="tblparStat" border="1" style="color: #E9E9E9; font-size: 13px;">
	<caption>Parcel Energy Specs</caption>
	<tr class="tbldk"><th width="40">CIN</th> <th width="40">CAPE</th> <th width="40" style="font-size: 11px;">NCAPE</th> <th width="32">LCL</th> <th width="32">LFC</th> <th width="32">EL</th> <th width="32">MPL</th></tr>
	<tr class="tbllt"><td align="center">1000</td>  <td align="center"></td>  <td align="center"></td>  <td align="center"></td> <td align="center"></td>  <td align="center"></td> <td align="center"></td></tr>
	<tr class="tbldk"><th>BDPE</th> <th>ECAPE</th> <th>&#1121;<sub>max</sub></th> <th>&epsilon;</th> <th>R<sub>UD</sub></th> <th>LNB</th> <th>OST</th></tr>
	<tr class="tbllt"><td align="center">500</td>  <td align="center">850</td>  <td align="center">1200</td>  <td align="center">45</td> <td align="center"></td>  <td align="center"></td> <td align="center"></td></tr>
</table>
<center><input type="button" onclick="clrTSview()" value="Close"></center>
</span>
<!-- ************************************************************** General Sounding Parcel Energy  *********************************************-->
<span id="mcEnergy" class="minicalc" style='visibility: visible; position: absolute; top: 32px; left: 594px'>
<table id="tblEnergy" border="1" style="color: #E9E9E9; font-size: 13px;">
	<caption>Profile Energy Specs</caption>
	<tr class="tbldk"><th width="30">PCL</th> <th width="42">CIN</th> <th width="42">CAPE</th> <th width="42">ECAPE</th> <th width="32">LCL</th> <th width="32">EL</th> </tr>
	<tr class="tbllt"><th>MU</th>  <td align="center"></td>  <td align="center"></td>  <td align="center"></td> <td align="center"></td>  <td align="center"></td> </tr> 
	<tr class="tbllt"><th>ML</th>  <td align="center"></td>  <td align="center"></td>  <td align="center"></td> <td align="center"></td>  <td align="center"></td> </tr>
	<tr class="tbllt"><th>SFC</th>  <td align="center"></td>  <td align="center"></td>  <td align="center"></td> <td align="center"></td>  <td align="center"></td> </tr>
	<tr class="tbldk"><th>SCP</th> <th>GDI</th>  <th>PWI</th> <th>&Gamma;<sub>mid</sub></th> <th>T<sub>C</sub></th> <th>TeD</th></tr>
	<tr class="tbllt"><td align="center"></td>  <td align="center"></td> <td align="center"></td> <td align="center"></td> <td align="center"></td> <td align="center"></td> </tr>
</table>
</span>
<!-- ************************************************************** Convective Winds   *********************************************-->
<span class="minicalc" id="mcDCAPE"> 
	<table style="font-size: 9pt" id="tblUpDown" border="1">
		<caption style="font-size: 11pt">Storm Updraft</caption>
		<tr class="tbldk"> <th width="75">MUCAPE</th> <th width="75">Inflow</th> <th width="75">Exhaust</th> <th width="75">Con Ratio</th> </tr>
		<tr class="tbllt"> <td align="center"></td> <td align="center"></td> <td align="center"></td> <td align="center"></td> </tr>
	</table>
    <table style="font-size: 9pt" id="tblLFS" border="1">
		<caption style="font-size: 11pt">Downdraft - level of free sink (LFS)</caption>
		<tr class="tbldk"> <th width="75">DCAPE</th> <th width="75">LFS</th> <th width="75">LFS SRW</th> <th width="75">Con Ratio</th> </tr>
		<tr class="tbllt"> <td id="lfsDCAPE" align="center"></td> <td id="lfsAGL" align="center"></td> <td id="lfsSRW" align="center"> </td> <td id="lfsCon" align="center"> </td> </tr>
    </table>
<table style="font-size: 9pt">
	<caption style="font-size: 11pt">Microburst Calculator</caption>
	<tr><td>
    <table id="tblCutDRWind" style="font-size: 9pt" border="1">
    <tr class="tbldk"><th>Max</th> <th>Env vs <br>SH</th> <th width="20">Dry</th> <th width="20">Wet</th> <th width="20">Hyb</th></tr>
    <tr>
    <td rowspan="3" ><input id="MXgust" type="button" onClick="addEnv(1,0)" value="1" style="font-size: 9pt"></td>
    <th class="tbldk">+TSRA</th>
    <td><input id="DSgust" type="button" onClick="addEnv(1,1)" value=".75" style="font-size: 9pt"></td>
    <td><input id="WSgust" type="button" onClick="addEnv(1,2)" value=".95" style="font-size: 9pt"></td>
    <td><input id="HSgust" type="button" onClick="addEnv(1,3)" value=".90" style="font-size: 9pt"></tr><tr>
    <th class="tbldk">Isold</th>
    <td><input id="DLgust" type="button" onClick="addEnv(2,1)" value=".65" style="font-size: 9pt"></td>
    <td><input id="WLgust" type="button" onClick="addEnv(2,2)" value=".80" style="font-size: 9pt"></td>
    <td><input id="HLgust" type="button" onClick="addEnv(2,3)" value=".75" style="font-size: 9pt"></td></tr><tr>
    <th class="tbldk">Virga</th>
    <td><input id="DVgust"  type="button" onClick="addEnv(3,1)" value=".50" style="font-size: 9pt"></td>
    <td> </td>
    <td><input id="HVgust" type="button" onClick="addEnv(3,3)" value=".60" style="font-size: 9pt"></td></tr>
    </table> 
</td><td valign="top">
    <table style="font-size: 11pt">
    <tr><td>Downrush:</td><td id="tblDRWS"></td></tr>
    <tr><td>Env Flow:</td><td id="tblDDD"></td><td id="tblSS"></td></tr>
    </table>

    <table id="tblDRdir" style="font-size: 11pt" border="1">
    <tr>
    <td width="30" align="center">0</td> <td width="30" align="center">0</td> <td width="30" align="center">0</td>
    </tr><tr>
    <td align="center">0</td> <td style="background-color: black; color: black">0</td> <td align="center">0</td>
    </tr><tr>
    <td align="center">0</td> <td align="center">0</td> <td align="center">0</td>
    </tr>
    </table> 
</td></tr></table>
<center><input type="button" onclick="clrDRtbl()" value="Close"></center> 
</span>
<span class="minicalc" id="parDCAPE">
	<div onClick="closeDPAR()" align="right"> | X | </div>
	<table>
		<caption style="font-size: 11pt">Downdraft Parcel</caption>
		<tr><td>
		<div id="DElapse"></div>
		<center>Entrainment vs Precip Intensity</center>
		<input id="60dbz" type="button" onClick="dbzDCAPE(1)" value="1" style="font-size: 8pt">
		<input id="50dbz" type="button" onClick="dbzDCAPE(2)" value="2" style="font-size: 8pt">
		<input id="40dbz" type="button" onClick="dbzDCAPE(3)" value="3" style="font-size: 8pt">
		<input id="3060dbz" type="button" onClick="dbzDCAPE(4)" value="4" style="font-size: 8pt">
		<input id="2050dbz" type="button" onClick="dbzDCAPE(5)" value="5" style="font-size: 8pt">
		<input id="40dbz" type="button" onClick="dbzDCAPE(6)" value="6" style="font-size: 8pt">
		<input id="30dbz" type="button" onClick="dbzDCAPE(7)" value="7" style="font-size: 8pt">
		<input id="20dbz" type="button" onClick="dbzDCAPE(8)" value="8" style="font-size: 8pt">
		<input id="10dbz" type="button" onClick="dbzDCAPE(9)" value="9" style="font-size: 8pt">
		</td></tr>
	</table>
</span>

<!-- ************************************************************** Effective Inflow Levels   *********************************************-->
<!-- Hodograph Info -->
<span id="dispEIFL" style="visibility: visible; position: absolute; top: 34px; left: 993px">
	<table style="font-size: 11pt; font-weight: 800; color: brown; background-color: #DFECFA" width="100">
		<caption style="background-color: #DFECFA">Effective Inflow</caption>
		<tr><td>Top</td><td id="EFFT"></td><td>m</td></tr>
		<tr><td>Base</td><td id="EFFB"></td><td>m</td></tr>
	</table>
	<center><input type="button" onclick="viewEditEIFL()" value="Edit"></center>
</span>
						
<span id="mcEditEIFL" class="minicalc" style="visibility: hidden">
	<table style="font-size: 11pt; font-weight: 800; color: brown; background-color: #9DAFC2" width="475">
		<caption style="background-color: #9DAFC2">Edit Effective Inflow</caption>
		<tr>
			<td colspan="7"><hr></td>
		</tr><tr>
			<td><input type="radio" id="hgtEIFL" name="manEIFL" value="hgtFx"><label for="hgtFx">Manual Height</label></td> 
			<td align="right">Base:</td> <td align="center"><input size="2" type="text" id="manEFFB" value="2000"></td> <td align="left">m</td> 
			<td align="right">Top:</td> <td align="center"><input size="2" type="text" id="manEFFT" value="4000"></td> <td align="left">m</td>
		</tr><tr>
			<td colspan="7"><hr></td>
		</tr><tr>
			<td><input type="radio" id="enEIFL" name="manEIFL" value="enFx" checked><label for="enFx">Energy Thresholds</label> </td> 
			<td align="right">CIN:</td> <td align="center"><input size="1" type="text" id="manEFCIN" value="-150"></td> <td align="left">J/Kg</td> 
			<td align="right">CAPE:</td> <td align="center"><input size="1" type="text" id="manEFCAPE" value="100"></td> <td align="left">J/Kg</td>
		</tr><tr>
			<td colspan="7"><hr></td>
		</tr><tr>
			<td colspan="7" align="center"> <input type="button" onclick="clrEIFLedit()" value="Apply"></td>
		</tr>
	</table>
</span>

<span id="editStMo" style="visibility: visible; position: absolute; top: 515px; left: 993px">
	<table style="font-size: 11pt; font-weight: 800; color: brown; background-color: #DFECFA" width="120">
		<tr><td>
			<input type="radio" id="smLM" name="stormMove" value="Left" onchange="iniHodograph()">
			<label for="Left">Left-Mover</label><br>
			<input type="radio" id="smAM" name="stormMove" value="Avg" onchange="iniHodograph()" checked>
			<label for="Avg">Avg Motion</label><br>
			<input type="radio" id="smRM" name="stormMove" value="Right" onchange="iniHodograph()">
			<label for="Right">Right-Mover</label>
		</td></tr>
		</table>
</span>

<span id="editStRel" style="visibility: visible; position: absolute; top: 561px; left: 1423px">
<div id="datview" style="font-size: 11pt; font-weight: 800; color: brown; background-color: #DFECFA">
Storm Relative <input type="checkbox" id="srHodo" onchange="updateHodograph()"></div>
</span>

<span id="hodoZoom" style="visibility: visible; position: absolute; top: 34px; left: 1450px">
	<table><tr><th>
		<button class="btn btn-primary" onClick="HoMove('U')">&#129053;</button><br>
		<button class="btn btn-primary" onClick="HoMove('L')">&#129052;</button><button class="btn btn-primary" onClick="HoMove('R')">&#129054;</button><br>
		<button class="btn btn-primary" onClick="HoMove('D')">&#129055;</button></td>
	</th><th>
		<button class="btn btn-primary" onClick="HoZoom('I')">+</button><br>
		<button class="btn btn-primary" onClick="HoZoom('O')"> - </button>
	</th><th>
		<button class="btn btn-primary" onClick="BifrostViewHodo()">BiFrost View</button><br>
	</th>
	</tr>
	</table>
</span>
<!--

-->
<!-- ************************************************************** Pop-Up Sounding Data   *********************************************-->
<span class="minicalc" id="mcInterrogate" > 
	<table border="1" style="font-size: 11pt">
	<tr><th align='left' width='50'>Press</th> <td id='iLp' width='125'></td></tr>
	<tr><th align='left'>AGL</th> <td id='iLagl'></td></tr>
	<tr><th align='left'>MSL</th> <td id='iLmsl'></td></tr>
	<tr><th align='left'>Wind</th> <td id='iLwnd'></td></tr>
	<tr><th align='left'>Temp</th> <td id='iLt'></td></tr>
	<tr><th align='left'>DwPt</th> <td id='iLdp'></td></tr>
	<tr><th align='left'>RH</th> <td id='iLrh'></td></tr>
	<tr><th align='left'>wb</th> <td id='iLwb'></td></tr>
	<tr><th align='left'>w</th> <td id='iLw'></td></tr>
	<tr><th align='left'>w<sub>s</sub></th> <td id='iLws'></td></tr>
	<tr><th align='left'>&theta;</th> <td id='iLth'></td></tr>
	<tr><th align='left'>&theta;<sub>e</sub></th> <td id='iLthe'></td></tr>
	</table>
	<center><input type="button" onclick="clrLvlView()" value="Close"></center>
</span>

<!-- ************************************************************** Heavy Rain   *********************************************-->
<span id="mcRain" class="minicalc" style='visibility: hidden; position: absolute; top: 32px; left: 290px'>
<table id="tblRain" border="1" style="color: #E9E9E9; font-size: 13px;">
	<caption>Heavy Precipitation Parameters</caption>
	<tr><th>MCS Steering</th>  <td></td>  <th>Eff Shear</td>  <td></td></tr>
	<tr><th>Derecho Steering</th>  <td></td>  <th>Storm Exhaust</th>  <td></td> </tr>
	<tr><th>Cold Pool Prop</th>  <td></td>  <th>Steering Flow</th>  <td></td> </tr>
</table>
	<center><input type="button" onclick="clrRainView()" value="Close"></center>
</span>

<!-- ************************************************************** Fog   *********************************************-->
<span id="mcFog" class="minicalc" style='visibility: hidden'>
<table id="tblFGcld" border="1" style="color: #E9E9E9; font-size: 13px;">
	<caption>Fog Visibility Parameters</caption>
	<tr class="tbldk"><th width="80">Cloud Layer</th> <th  width="50">Hgt</th> <th  width="50">RH<sub>Max</sub></th> </tr> 
	<tr class="tbllt"><th>High Etage</th> <td align="center">m</td> <td align="center">55%</td> </tr> 
	<tr class="tbllt"><th>Mid Etage</th> <td align="center">m</td> <td align="center">65%</td> </tr>
</table>
<hr />
<table id="tblFGlyr" border="1" style="color: #E9E9E9; font-size: 13px;">
<caption>Boundary Layer Conditions</caption>
	<tr class="tbldk"><th width="80">Fog Layer</th> <th width="33">Hgt</th> <th width="32">&Gamma;</th> <th width="32">RH%</th></tr>
	<tr class="tbllt"><th>Stable Layer</th>  <td align="center">600m</td> <td align="center">&Gamma;<sub>Min</sub></td>  <td align="center">%</td> </tr>
	<tr class="tbllt"><th>Mixing Layer</th>  <td align="center">600m</td> <td align="center">&Gamma;<sub>Min</sub></td>  <td align="center">%</td> </tr>
</table>
<hr />
<table id="tblFGsfc" border="1" style="color: #E9E9E9; font-size: 13px;">
	<caption>Surface Conditions</caption>
	<tr class="tbldk">  <th width="37">T</th>  <th width="37">T<sub>d</sub></th>  <th width="37">RH%</th> <th width="65">WND</th> </tr>
	<tr class="tbllt">  <td align="center">T</td>  <td align="center">T<sub>d</sub></td>  <td align="center">%</td> <td align="center">270|12</td></tr>
</table>
	<center><input type="button" onclick="clrFogView()" value="Close"></center>
</span>
<!-- ************************************************************** Turbulence   *********************************************-->
<span class="minicalc" id="mcTurb">
	<div onClick="closeTurb()" align="right"> | X | </div>
	<table>
		<caption style="font-size: 11pt">Vertical Wind Shear Profile</caption>
		<tr><td align="center">
			<input type="radio" id="ulTurb" name="TurbHgt" value="UpperTurb" onchange="iniTurb()">
			<label for="UpperTurb">Upper</label> - 
			<input type="radio" id="llTurb" name="TurbHgt" value="LowerTurb" onchange="iniTurb()" checked>
			<label for="LowerTurb">Lower</label>
		</td></tr>
		<tr><td>
			<div id="vwsTurb"></div>
		</td></tr>
	</table>
</span>

<!-- Compare To Different Time -->
<span class="minicalc" id="mcComp">
Comparison Profile
<div id="compSign" style="font-weight: 900">-</div><input size="1" type="text" id="compHR" value="24"> hrs<br>
<button class="btn btn-primary" onClick="compSwap(0)">prior</button> <button class="btn btn-primary" onClick="compSwap(1)">after</button>
</span>

<!-- EDIT SKEW-T TEMPS -->
<span class="minicalc" id="mcEditor">
<table style="font-size: 10px">
	<caption>Edit Skew-T</caption>
	<tr><td id="P35" align="center">P</td><td align="center">T</td><td align="center">T<sub>d</sub></td><td align="center">Wnd<sub>Dir</sub></td><td align="center">Wnd<sub>Sp</sub></td></tr>
	<tr><td id="P34"></td><td><input size="2" class="prof" type="text" id="T34" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP34" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD34" value="000"></td><td><input size="2" class="prof" type="text" id="WS34" value="00"></td></tr>
	<tr><td id="P33"></td><td><input size="2" class="prof" type="text" id="T33" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP33" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD33" value="000"></td><td><input size="2" class="prof" type="text" id="WS33" value="00"></td></tr>
	<tr><td id="P32"></td><td><input size="2" class="prof" type="text" id="T32" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP32" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD32" value="000"></td><td><input size="2" class="prof" type="text" id="WS32" value="00"></td></tr>
	<tr><td id="P31"></td><td><input size="2" class="prof" type="text" id="T31" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP31" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD31" value="000"></td><td><input size="2" class="prof" type="text" id="WS31" value="00"></td></tr>
	<tr><td id="P30"></td><td><input size="2" class="prof" type="text" id="T30" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP30" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD30" value="000"></td><td><input size="2" class="prof" type="text" id="WS30" value="00"></td></tr>
	<tr><td id="P29"></td><td><input size="2" class="prof" type="text" id="T29" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP29" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD29" value="000"></td><td><input size="2" class="prof" type="text" id="WS29" value="00"></td></tr>
	<tr><td id="P28"></td><td><input size="2" class="prof" type="text" id="T28" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP28" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD28" value="000"></td><td><input size="2" class="prof" type="text" id="WS28" value="00"></td></tr>
	<tr><td id="P27"></td><td><input size="2" class="prof" type="text" id="T27" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP27" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD27" value="000"></td><td><input size="2" class="prof" type="text" id="WS27" value="00"></td></tr>
	<tr><td id="P26"></td><td><input size="2" class="prof" type="text" id="T26" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP26" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD26" value="000"></td><td><input size="2" class="prof" type="text" id="WS26" value="00"></td></tr>
	<tr><td id="P25"></td><td><input size="2" class="prof" type="text" id="T25" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP25" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD25" value="000"></td><td><input size="2" class="prof" type="text" id="WS25" value="00"></td></tr>
	<tr><td id="P24"></td><td><input size="2" class="prof" type="text" id="T24" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP24" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD24" value="000"></td><td><input size="2" class="prof" type="text" id="WS24" value="00"></td></tr>
	<tr><td id="P23"></td><td><input size="2" class="prof" type="text" id="T23" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP23" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD23" value="000"></td><td><input size="2" class="prof" type="text" id="WS23" value="00"></td></tr>
	<tr><td id="P22"></td><td><input size="2" class="prof" type="text" id="T22" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP22" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD22" value="000"></td><td><input size="2" class="prof" type="text" id="WS22" value="00"></td></tr>
	<tr><td id="P21"></td><td><input size="2" class="prof" type="text" id="T21" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP21" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD21" value="000"></td><td><input size="2" class="prof" type="text" id="WS21" value="00"></td></tr>
	<tr><td id="P20"></td><td><input size="2" class="prof" type="text" id="T20" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP20" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD20" value="000"></td><td><input size="2" class="prof" type="text" id="WS20" value="00"></td></tr>
	<tr><td id="P19"></td><td><input size="2" class="prof" type="text" id="T19" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP19" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD19" value="000"></td><td><input size="2" class="prof" type="text" id="WS19" value="00"></td></tr>
	<tr><td id="P18"></td><td><input size="2" class="prof" type="text" id="T18" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP18" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD18" value="000"></td><td><input size="2" class="prof" type="text" id="WS18" value="00"></td></tr>
	<tr><td id="P17"></td><td><input size="2" class="prof" type="text" id="T17" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP17" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD17" value="000"></td><td><input size="2" class="prof" type="text" id="WS17" value="00"></td></tr>
	<tr><td id="P16"></td><td><input size="2" class="prof" type="text" id="T16" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP16" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD16" value="000"></td><td><input size="2" class="prof" type="text" id="WS16" value="00"></td></tr>
	<tr><td id="P15"></td><td><input size="2" class="prof" type="text" id="T15" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP15" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD15" value="000"></td><td><input size="2" class="prof" type="text" id="WS15" value="00"></td></tr>
	<tr><td id="P14"></td><td><input size="2" class="prof" type="text" id="T14" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP14" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD14" value="000"></td><td><input size="2" class="prof" type="text" id="WS14" value="00"></td></tr>
	<tr><td id="P13"></td><td><input size="2" class="prof" type="text" id="T13" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP13" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD13" value="000"></td><td><input size="2" class="prof" type="text" id="WS13" value="00"></td></tr>
	<tr><td id="P12"></td><td><input size="2" class="prof" type="text" id="T12" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP12" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD12" value="000"></td><td><input size="2" class="prof" type="text" id="WS12" value="00"></td></tr>
	<tr><td id="P11"></td><td><input size="2" class="prof" type="text" id="T11" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP11" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD11" value="000"></td><td><input size="2" class="prof" type="text" id="WS11" value="00"></td></tr>
	<tr><td id="P10"></td><td><input size="2" class="prof" type="text" id="T10" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP10" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD10" value="000"></td><td><input size="2" class="prof" type="text" id="WS10" value="00"></td></tr>
	<tr><td id="P9"></td><td><input size="2" class="prof" type="text" id="T9" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP9" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD9" value="000"></td><td><input size="2" class="prof" type="text" id="WS9" value="00"></td></tr>
	<tr><td id="P8"></td><td><input size="2" class="prof" type="text" id="T8" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP8" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD8" value="000"></td><td><input size="2" class="prof" type="text" id="WS8" value="00"></td></tr>
	<tr><td id="P7"></td><td><input size="2" class="prof" type="text" id="T7" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP7" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD7" value="000"></td><td><input size="2" class="prof" type="text" id="WS7" value="00"></td></tr>
	<tr><td id="P6"></td><td><input size="2" class="prof" type="text" id="T6" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP6" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD6" value="000"></td><td><input size="2" class="prof" type="text" id="WS6" value="00"></td></tr>
	<tr><td id="P5"></td><td><input size="2" class="prof" type="text" id="T5" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP5" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD5" value="000"></td><td><input size="2" class="prof" type="text" id="WS5" value="00"></td></tr>
	<tr><td id="P4"></td><td><input size="2" class="prof" type="text" id="T4" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP4" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD4" value="000"></td><td><input size="2" class="prof" type="text" id="WS4" value="00"></td></tr>
	<tr><td id="P3"></td><td><input size="2" class="prof" type="text" id="T3" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP3" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD3" value="000"></td><td><input size="2" class="prof" type="text" id="WS3" value="00"></td></tr>
	<tr><td id="P2"></td><td><input size="2" class="prof" type="text" id="T2" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP2" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD2" value="000"></td><td><input size="2" class="prof" type="text" id="WS2" value="00"></td></tr>
	<tr><td id="P1"></td><td><input size="2" class="prof" type="text" id="T1" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP1" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD1" value="000"></td><td><input size="2" class="prof" type="text" id="WS1" value="00"></td></tr>
	<tr><td id="P0"></td><td><input size="2" class="prof" type="text" id="T0" value="00.0"></td><td><input size="2" class="prof" type="text" id="DP0" value="00.0"></td><td><input size="2" class="prof" type="text" id="WD0" value="000"></td><td><input size="2" class="prof" type="text" id="WS0" value="00"></td></tr>
	<tr><td align="center">P</td><td align="center">T</td><td align="center">T<sub>d</sub></td><td align="center">Wnd<sub>Dir</sub></td><td align="center">Wnd<sub>Sp</sub></td>
	</table>
	<p align="center">
		<input type="button" onclick="smoothEdit()" value="Tsfc mix"> <input type="button" onclick="applyEditor()" value="Update"><br>
		<input type="button" onclick="clrEditor()" value="Close">
	</p>
</span>
<span class="minicalc" id="mcMap">
Load Skew-T
<div id="map"></div>
<center><input type="button" onclick="clrMap()" value="Close"></center>
</span>
<div id="tblDCAPElvl" style="visibility: hidden">0</div>
<script>
	var map = L.map('map').setView([38, -98], 4);  
	L.esri.basemapLayer('Topographic').addTo(map);

	var siteIcon = L.icon({
	iconUrl: "img/SqMark.png",
	iconSize: [11, 11],
	});
	
	for(var i=0;i<siteCoord.length;i++){	
		latlon = [siteCoord[i][1],siteCoord[i][2]]
		icaoARG = '"' + siteCoord[i][0] + '"'
		popTxt = siteCoord[i][0] + "<br><input type='button' onClick='mapLoad(" + icaoARG + ")' value='Load'>"
		L.marker([siteCoord[i][1],siteCoord[i][2]], {icon: siteIcon}).addTo(map).bindPopup(popTxt).addTo(map)
		//gradPts.push(gradPt)
	}

</script>

</body>  
</html>